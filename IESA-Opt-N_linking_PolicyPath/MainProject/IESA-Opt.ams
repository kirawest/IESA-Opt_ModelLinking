## ams_version=1.0

Model IESA_Opt_Package {
	Section Model_linking {
		Procedure Run_IESA {
			Body: {
				StatusMessage("Starting optimization...");
				! Step 1: Apply settings procedure
				Settings_Solve_Transition;
				StatusMessage("Settings for optimization are set");
				! Step 2: Solve the model
				SolveTransition;
				
				! Create a new Excel workbook to act as a signal
				   ! axll::CreateNewWorkbook(
				     !   WorkbookFilename: "U:/IESA-Opt-ModelLinking/Finish_Signal/procedure_done.xlsx",
				       ! FirstSheetName: "Signal"
				    !);
				StatusMessage("The transition is solved!");
			}
		}
		Procedure Settings_Solve_Transition {
			Body: {
				RetreiveExistingOutputFolders;
				RetreiveExistingInputFiles;
				DefaultInputLocation;
				runDataReading;
				periods_selection := {2022,2030,2040,2050}; !Assign here the years of which you want to do a similiation.
				CPUCores := 0; !This is the default which is zero. Depending on your environment you can opt to leave CPU cores alone.
				hoursPer_day := '24' ; !This is the default. Could be set to 1/6/8/24
				OutputFolderValue := 'custom'; !Customize the name of the output folder and file
				OutputFolderName := 'ResultsModelLinking' ; !Fill in the name
				!DefineSolverSettings
				!SolverChoice if you want to change the solver
				!SolverMethodChoice
				EnergyPricesChoice := 'Marginal Costs' ; !Default is set to shadow prices.
				!ShowViolations := 'Yes' ;! !Default is set to no.
				!SaveCaseValue := 'Yes';! !Default is set to no.
				!HourlyReportValue := 'Yes';! !Default is set to no.
				ActiveConstraintGroup := 'Linking scenario'; !Default is set to Base - this also includes RFNBO & EED policies
				!activeConstraints options can be found in ActiveConstraintGroups
			}
		}
	}
	Section Model_description {
		DeclarationSection Temporal_relations {
			Set hours {
				SubsetOf: hours_orig;
				Index: h, ih;
				Property: ElementsAreNumerical;
				Definition: {
					{ho | ho <= card(hours_Orig)*hoursPer_day/24}
				}
			}
			Set hours_orig {
				SubsetOf: Integers;
				Index: ho, iho, jho;
				Property: ElementsAreNumerical;
			}
			Set hours_inDay {
				SubsetOf: hours;
				Index: h_d, ih_d;
				Definition: {
					{h | h<=hoursPer_day}
				}
			}
			Set hoursPer_dayOptions {
				SubsetOf: Integers;
				Property: ElementsAreNumerical;
				Definition: {
					{24,8,6,1}
				}
			}
			Set range_type;
			Set q_hourWindow {
				SubsetOf: Integers;
				Index: q, iq;
				Property: ElementsAreNumerical;
				Definition: {
					{h | 365*hoursPer_day/hoursPer_quarter>=h>0}
				}
			}
			Set days {
				SubsetOf: Integers;
				Index: d, id;
				Property: ElementsAreNumerical;
				Definition: {
					{h | 365>=h>0}
				}
			}
			Set r_dayWindow {
				SubsetOf: Integers;
				Index: r, ir;
				Definition: {
					{h | ceil(365/daysPer_range)>=h>0}
				}
			}
			Set weeks {
				SubsetOf: Integers;
				Index: w, iw;
				Property: ElementsAreNumerical;
				Definition: {
					{h | 53>=h>0}
				}
			}
			Set months {
				SubsetOf: Integers;
				Index: m, im;
				Property: ElementsAreNumerical;
				Definition: {
					{h | 12>=h>0}
				}
			}
			Set seasons {
				SubsetOf: Integers;
				Index: s, is;
				Property: ElementsAreNumerical;
				Definition: {
					{h | 4>=h>0}
				}
			}
			Set b_semester {
				SubsetOf: Integers;
				Index: b, ib;
				Property: ElementsAreNumerical;
				Definition: {
					{h | 2>=h>0}
				}
			}
			Set periods {
				SubsetOf: Integers;
				Index: p, ip, jp;
				Property: ElementsAreNumerical;
				InitialData: {
					{2022,2025,2030,2035,2040,2045,2050}
				}
			}
			ElementParameter hoursPer_day {
				Range: hoursPer_dayOptions;
				Property: Constant;
				InitialData: '8';
			}
			ElementParameter hoursindayPer_hour {
				IndexDomain: h;
				Range: hours_inDay;
				Definition: {
					if(mod(h,hoursPer_day)=0) then
						hoursPer_day
					else
						mod(h,hoursPer_day)
					endif
				}
			}
			Parameter hoursPer_hourOrig {
				IndexDomain: ho;
				Definition: ceil(ho*hoursPer_day/24);
			}
			ElementParameter hoursOrigPer_hour {
				IndexDomain: h;
				Range: hours_orig;
				Definition: h*24/hoursPer_day;
			}
			ElementParameter quarterPer_hour {
				IndexDomain: h;
				Range: q_hourWindow;
				Definition: ceil(h/hoursPer_quarter);
			}
			ElementParameter dayPer_hour {
				IndexDomain: h;
				Range: days;
				Definition: ceil(h/hoursPer_day);
			}
			ElementParameter rangePer_hour {
				IndexDomain: h;
				Range: r_dayWindow;
				Definition: ceil(h/(hoursPer_day*daysPer_range));
			}
			ElementParameter weekPer_hour {
				IndexDomain: h;
				Range: weeks;
				Definition: ceil(h/(hoursPer_day*7));
			}
			ElementParameter monthPer_hour {
				IndexDomain: h;
				Range: months;
				Definition: monthPer_hourOrig(hoursOrigPer_hour(h));
			}
			ElementParameter monthPer_hourOrig {
				IndexDomain: ho;
				Range: Integers;
			}
			ElementParameter seasonPer_hour {
				IndexDomain: h;
				Range: seasons;
				Definition: ceil(4*h/card(h));
			}
			ElementParameter semesterPer_hour {
				IndexDomain: h;
				Range: b_semester;
				Definition: ceil(2*h/card(h));
			}
			ElementParameter rangePer_day {
				IndexDomain: d;
				Range: r_dayWindow;
				Definition: sum[ih | ih=hoursPer_day*d, rangePer_hour(ih)];
			}
			ElementParameter weekPer_day {
				IndexDomain: d;
				Range: weeks;
				Definition: sum[ih | ih=hoursPer_day*d, weekPer_hour(ih)];
			}
			ElementParameter monthPer_day {
				IndexDomain: d;
				Range: months;
				Definition: sum[ih | ih=hoursPer_day*d, monthPer_hour(ih)];
			}
			ElementParameter seasonPer_day {
				IndexDomain: d;
				Range: seasons;
				Definition: sum[ih | ih=hoursPer_day*d, seasonPer_hour(ih)];
			}
			ElementParameter semesterPer_day {
				IndexDomain: d;
				Range: b_semester;
				Definition: sum[ih | ih=hoursPer_day*d, semesterPer_hour(ih)];
			}
			Parameter hoursPer_quarter {
				Definition: max(1,hoursPer_day/4);
			}
			Parameter daysPer_range {
				Definition: 3;
			}
			Parameter transition_interval {
				Definition: val(last(periods)) - val(first(periods)) + 10;
			}
			Parameter modelled_transition_interval {
				Definition: val(last(periods_selection)) - val(first(periods_selection)) + last_period_length;
			}
			Parameter last_period_length {
				InitialData: 10;
			}
		}
		DeclarationSection System_info {
			Set typesInfo_tech {
				Index: tit, itit;
				Definition: {
					{'Name','Units_of_Capacity','Node','Category','Sector','Sub_sector','Activity','Units_of_Activity'}
				}
			}
			Set typesInfo_act {
				Index: tia, itia;
				Definition: {
					{'Node','Units_of_Activity'}
				}
			}
			Set sectors {
				SubsetOf: set_of_everything;
				Index: z, iz;
			}
			Set sectors_kev {
				SubsetOf: set_of_everything;
				Index: zk, izk;
			}
			Set node_names {
				Index: nn, inn, jnn;
			}
			Set tech_nominals {
				Index: tn, itn, jtn;
			}
			Set tech_flex {
				SubsetOf: technologies;
				Index: tff, itff;
				Definition: {
					{t in tech_hourlyCHPflex}+{t in tech_shedding}+{t in tech_flexible}
				}
			}
			Set tech_imports {
				SubsetOf: tech_balancers;
				Index: tim, itim, jtim;
				Definition: {
					{tb | (StringOccurrences(tech_name(tb),'Import')*IEM_node(nodePer_techBal(tb)))>0}
				}
			}
			Set energy_labels {
				SubsetOf: set_of_everything;
				Index: el, iel, jel;
			}
			Set renewables {
				SubsetOf: energy_labels;
				Definition: {
					!if ('Wind' in energy_labels) then
					!	{'Wind','Solar','Biomass','Bio-liquids','Other RE'}
					!endif
					{el | is_renewable(el)=1}
				}
			}
			StringParameter tech_name {
				IndexDomain: t;
			}
			ElementParameter tech_sector_kev {
				IndexDomain: t;
				Range: sectors_kev;
			}
			StringParameter tech_category {
				IndexDomain: t;
			}
			ElementParameter tech_sector {
				IndexDomain: t;
				Range: sectors;
			}
			StringParameter tech_subsector {
				IndexDomain: t;
			}
			ElementParameter tech_activity {
				IndexDomain: t;
				Range: activities_solve;
				Definition: {
					if (t in tech_balancers) then
						activityPer_tech(t)
					elseif (t in tech_infra) then
						infra_activity(t)
					endif
				}
			}
			StringParameter tech_units {
				IndexDomain: t;
			}
			StringParameter act_units {
				IndexDomain: a;
			}
			ElementParameter namePer_node {
				IndexDomain: n;
				Range: node_names;
			}
			Parameter IEM_node {
				IndexDomain: n;
				Range: binary;
			}
			Parameter IEM_sector {
				IndexDomain: z;
			}
			Parameter is_renewable {
				IndexDomain: el;
			}
			Parameter GWtoPJ_y {
				Definition: 3.6*8760/1000;
			}
			Parameter GWhtoPJ {
				Definition: 3.6/1000;
			}
			StringParameter tech_info {
				IndexDomain: (t,tit);
				Definition: {
					if (tit='Name') then
						tech_name(t)
					elseif (tit='Units_of_Capacity') then
						tech_units(t)
					elseif (tit='Node') then
						if (t in tech_balancers) then
							namePer_node(nodePer_techBal(t))
						elseif (t in tech_infra) then
							namePer_node(nodePer_techInfra(t))
						endif
					elseif (tit='Category') then
						tech_category(t)
					elseif (tit='Sector') then
						tech_sector(t)
					elseif (tit='Sub_sector') then
						tech_subsector(t)
					elseif (tit='Activity') then
						tech_activity(t)
					elseif (tit='Units_of_Activity') then
						act_units(tech_activity(t))
					endif
				}
			}
			StringParameter act_info {
				IndexDomain: (a,tia);
				Definition: {
					if (tia='Node') then
						namePer_node(nodePer_act(a))
					elseif (tia='Units_of_Activity') then
						act_units(a)
					endif
				}
			}
			StringParameter flexType_tech {
				IndexDomain: (tff);
				Definition: {
					if (tff in tech_hourlyCHPflex) then
						"CHP"
					elseif (tff in tech_shedding) then
						"Shedding"
					elseif (tff in tech_fDRshifting) then
						"Load Shifting"
					elseif (tff in tech_fBEshifting) then
						"Passive Storage"
					elseif (tff in tech_fStorage) then
						"Storage"
					elseif (tff in tech_fEVcharging) then
						"Smart Charging"
					elseif (tff in tech_fEVgrid) then
						"Vehicle-to-grid"
					endif
					!{,'Shedding','Storage','Load Shifting','Smart Charging','Vehicle-to-Grid','Passive Storage'}
				}
			}
			ElementParameter flexAct_tech {
				IndexDomain: (tff);
				Range: activities_hour;
				Definition: {
					if (tff in tech_hourlyCHPflex) then
						first({ah | dP_electricity(tff,ah)=1})
					elseif (tff in tech_shedding) then
						first({ah | dS_hourly(tff,ah)=1})
					else
						first({ah | dQ_hourly(tff,ah)=1})
					endif
					!{,'Shedding','Storage','Load Shifting','Smart Charging','Vehicle-to-Grid','Passive Storage'}
				}
			}
			StringParameter flex_info {
				IndexDomain: (tff,a);
				Definition: {
					if (a=flexAct_tech(tff)) then
						flexType_tech(tff)
					endif
				}
			}
			StringParameter scenario_description;
			StringParameter act_string {
				Definition: "Activity";
			}
			StringParameter day_string {
				Definition: "Day";
			}
			StringParameter energy_string {
				Definition: "Carrier";
			}
			StringParameter from_string {
				Definition: "from";
			}
			StringParameter hour_string {
				Definition: "Hour";
			}
			StringParameter name_string {
				Definition: "Name";
			}
			StringParameter node_string {
				Definition: "Node";
			}
			StringParameter sector_string {
				Definition: "Sector";
			}
			StringParameter sink_string {
				Definition: "Sink";
			}
			StringParameter source_string {
				Definition: "Source";
			}
			StringParameter techID_string {
				Definition: "Tech_ID";
			}
			StringParameter to_string {
				Definition: "to";
			}
			StringParameter type_string {
				Definition: "Type";
			}
			StringParameter type1_string {
				Definition: "Type1";
			}
			StringParameter type2_string {
				Definition: "Type2";
			}
			StringParameter week_string {
				Definition: "Week";
			}
		}
		DeclarationSection Balancing_description {
			Set set_of_everything;
			Set dispatch_type {
				Index: ym;
			}
			Set nodes {
				Index: n, jn;
			}
			Set nodes_IEM {
				SubsetOf: nodes;
				Index: ni, ini, jni;
				Definition: {
					{n | IEM_node(n)=1}
				}
			}
			Set activity_type {
				Index: ya;
			}
			Set aktivities {
				SubsetOf: set_of_everything;
				Index: a;
				Definition: activities_original+activities_group;
			}
			Set activities_solve {
				SubsetOf: aktivities;
				Index: as, ias;
				Definition: {
					{ao | sum[ag,groupOf_activities(ag,ao)]=0}+activities_group
				}
			}
			Set activities_original {
				SubsetOf: aktivities;
				Index: ao, iao;
			}
			Set activities_group {
				SubsetOf: aktivities;
				Index: ag;
			}
			Set activities_driver {
				SubsetOf: activities_solve;
				Index: av, iav;
				Definition: {
					{as |activityType_act(as)='Driver'}
				}
			}
			Set activities_energy {
				SubsetOf: activities_solve;
				Index: ae, iae;
				Definition: {
					{as |activityType_act(as)='Energy'} + {as |activityType_act(as)='Fix Energy'}
				}
			}
			Set activities_fixEnergy {
				SubsetOf: activities_solve;
				Index: af, iaf, jaf;
				Definition: {
					{as |activityType_act(as)='Fix Energy'}
				}
			}
			Set activities_materialConversion {
				SubsetOf: activities_solve;
				Index: amc, iamc, jamc;
				Definition: {
					{as | activityType_act(as)='Material conversion'}
				}
			}
			Set activities_energyNonFixed {
				SubsetOf: activities_solve;
				Index: aen, iaen, jaen;
				Definition: {
					{as |activityType_act(as)='Energy'}
				}
			}
			Set activities_emission {
				SubsetOf: activities_solve;
				Index: ac, iac;
				Definition: {
					{as | activityType_act(as)='Emission' and emissionTarget_bin(as)<>1 }
				}
			}
			Set activities_emissionFix {
				SubsetOf: activities_solve;
				Index: acf;
				Definition: {
					{a | activityType_act(a)='Emission' }
					
					! or actSolvePer_actOrig(a)='CO2 Air Feedstock end of lifetime' or actSolvePer_actOrig(a)='CO2 Air Int. Transport' or actSolvePer_actOrig(a)='CO2 CCUS Network'
				}
			}
			Set activities_target {
				SubsetOf: activities_solve;
				Index: act, iact, jact;
				Definition: {
					{as | emissionTarget_bin(as)=1 }
				}
			}
			Set activities_target_FeedStocks {
				SubsetOf: activities_solve;
				Index: atf, iatf, jatf;
				Definition: {
					{a | actSolvePer_actOrig(a)='CO2 Air Feedstock end of lifetime'}
				}
			}
			Set activities_target_Bunkers {
				SubsetOf: activities_solve;
				Index: atb, iatb, jatb;
				Definition: {
					{a | actSolvePer_actOrig(a)='CO2 Air Int. Transport'}
				}
			}
			Set activities_year {
				SubsetOf: activities_energy;
				Index: ay, iay, jay;
				Definition: {
					{ae | ((ae in activities_hour) + (ae in activities_day))=0}
				}
			}
			Set activities_balance {
				SubsetOf: activities_solve;
				Index: ab, iab;
				Definition: {
					{as | activityType_act(as)<>'Fix Energy' and activityType_act(as)<>'Emission' and activityType_act(as)<>'EmissionReport' and activityType_act(as)<>'Target' and activityType_act(as)<>'Material conversion'}
				}
			}
			Set activities_emissionReport {
				SubsetOf: activities_solve;
				Index: aer;
				Definition: {
					{as | activityType_act(as)='EmissionReport'}
				}
			}
			Set activities_credits {
				SubsetOf: activities_solve;
				Index: acr, iacr, jacr;
				Definition: {
					{as |activityType_act(as)='Credits'}
				}
			}
			Set technologies {
				Index: t, it, jt;
			}
			Set tech_balancers {
				SubsetOf: technologies;
				Index: tb, itb, jtb;
			}
			Set tech_emission {
				SubsetOf: technologies;
				Index: t_c;
				Definition: {
					{t |activityType_act(activityPer_tech(t))= 'Emission'} +
					{t |activityType_act(activityPer_tech(t))= 'EmissionReport'}
				}
			}
			Set tech_materialConversion {
				SubsetOf: technologies;
				Index: t_m;
				Definition: {
					{t |activityType_act(activityPer_tech(t))='Material conversion'}
				}
			}
			ElementParameter dispatchType_act {
				IndexDomain: a;
				Range: dispatch_type;
			}
			ElementParameter activityType_act {
				IndexDomain: a;
				Range: activity_type;
			}
			ElementParameter actSolvePer_actOrig {
				IndexDomain: ao;
				Range: activities_solve;
				Definition: {
					if (sum[ag, groupOf_activities(ag,ao)]=0) then
						ao
					else
						first({as | groupOf_activities(as,ao)=1})
					endif
				}
			}
			ElementParameter activityPer_techOrig {
				IndexDomain: tb;
				Range: activities_original;
			}
			ElementParameter activityPer_tech {
				IndexDomain: tb;
				Range: activities_solve;
				Definition: actSolvePer_actOrig(activityPer_techOrig(tb));
			}
			ElementParameter nodePer_act {
				IndexDomain: a;
				Range: nodes;
			}
			ElementParameter nodePer_techBal {
				IndexDomain: tb;
				Range: nodes;
				Definition: nodePer_act(activityPer_tech(tb));
			}
			ElementParameter labelPer_act {
				IndexDomain: as;
				Range: energy_labels;
			}
			Parameter emissionTarget {
				IndexDomain: (n,p);
			}
			Parameter emissionTarget_inclScope3 {
				IndexDomain: (n,p);
			}
			Parameter emissionTarget_inclScope3andFuelex {
				IndexDomain: p;
				Definition: sum[n|n='NL',emissionTarget_inclScope3(n,p)];
			}
			Parameter emissionTarget_inclbunkers {
				IndexDomain: (n,p);
				Definition: {
					data 
					{ ( NL, 2022 ) : 1000.000,  ( NL, 2025 ) :  425.000,  ( NL, 2030 ) :  142.500,  ( NL, 2035 ) :  113.600,
					  ( NL, 2040 ) :   78.800,  ( NL, 2045 ) :   44.600,  ( NL, 2050 ) :   15.900,  ( EU, 2022 ) : 2000.000,
					  ( EU, 2025 ) : 2000.000,  ( EU, 2030 ) : 2000.000,  ( EU, 2035 ) : 2000.000,  ( EU, 2040 ) : 2000.000,
					  ( EU, 2045 ) : 2000.000,  ( EU, 2050 ) : 2000.000,  ( XX, 2022 ) : 2000.000,  ( XX, 2025 ) : 2000.000,
					  ( XX, 2030 ) : 2000.000,  ( XX, 2035 ) : 2000.000,  ( XX, 2040 ) : 2000.000,  ( XX, 2045 ) : 2000.000,
					  ( XX, 2050 ) : 2000.000 }
				}
			}
			Parameter emissionTarget_cum {
				IndexDomain: n;
			}
			Parameter emissionTarget_bin {
				IndexDomain: a;
				Range: binary;
			}
			Parameter cumulative_CO2storage {
				IndexDomain: n;
			}
			Parameter XC_TransmissionLoss;
			Parameter HVtoMV_TransformerLoss;
			Parameter MVtoLV_TransformerLoss;
			Parameter HVtoLV_TransformerLoss;
			Parameter groupOf_activities {
				IndexDomain: (ag,ao);
				Range: binary;
			}
			Parameter activities_netVolumesOrig {
				IndexDomain: (ao,p);
			}
			Parameter activities_netVolumes {
				IndexDomain: (as,p);
				Definition: activities_netVolumesOrig(as,p)+sum[iao | groupOf_activities(as,iao)=1, activities_netVolumesOrig(iao,p)];
			}
			Parameter activity_balancesRef {
				IndexDomain: (tb,ao);
			}
			Parameter activity_EffImprov {
				IndexDomain: (tb,ao,p);
			}
			Parameter activity_balancesOrig {
				IndexDomain: (tb,ao,p);
				Definition: activity_balancesRef(tb,ao)*(1-activity_EffImprov(tb,ao,p));
			}
			Parameter activity_balances {
				IndexDomain: (tb,as,p);
				Definition: round((activity_balancesOrig(tb,as,p)+sum[iao | groupOf_activities(as,iao)=1, activity_balancesOrig(tb,iao,p)]),5);
			}
			Parameter vom_cost {
				IndexDomain: (tb,p);
			}
			Parameter cap2act {
				IndexDomain: t;
			}
			Parameter techUse_min {
				IndexDomain: (t,p);
			}
			Parameter techUse_max {
				IndexDomain: (t,p);
			}
			Variable tech_use {
				IndexDomain: (tb,ps);
				Range: nonnegative;
			}
			Constraint balance_activities {
				IndexDomain: (ab,ps);
				Definition: {
					sum[tb, tech_use(tb,ps)*activity_balances(tb,ab,ps)]+  !Reference activity balance
					sum[tf, sum[h, (deltaQ_UP(h,tf,ps)+deltaQ_DW(h,tf,ps))]*dQ_hourly(tf,ab)]+ !Impact of flexibility in hourly activities
					!sum[tg, sum[d, (deltaB_DW(d,tg,ps)-deltaB_UP(d,tg,ps))]*activity_balances(tg,ab,ps)]+ !Impact of gas buffers energy consumption
					sum[tk, sum[h, deltaU_CHP(h,tk,ps)]*activity_balances(tk,ab,ps)]+ !Impact of use deviation of CHPs
					sum[tk, sum[h, deltaP_CHP(h,tk,ps)]*dP_electricity(tk,ab)]+ !Impact in power of power output ratio deviation of CHPs
					sum[tk, sum[h, -CHP_eta(tk)*deltaP_CHP(h,tk,ps)/CHP_eps(tk,ps)]*dP_heat(tk,ab)]+ !Impact in heat of power output ratio deviation of CHPs
					sum[ts, sum[h, deltaS_shed(h,ts,ps)]*activity_balances(ts,ab,ps)] !Impact of shedding load
					-sum[tw, sum[h, deltaW_UP(h,tw,ps)]*dW_hourly(tw,ab)] !Demand increase due to pumping electricity in reservoirs
					>=activities_netVolumes(ab,ps) !Exogenous drivers
				}
			}
			Constraint balance_activitiesFix {
				IndexDomain: (af,ps);
				Definition: {
					sum[tb, tech_use(tb,ps)*activity_balances(tb,af,ps)]+  !Reference activity balance
					sum[tf, sum[h, (deltaQ_UP(h,tf,ps)+deltaQ_DW(h,tf,ps))]*dQ_hourly(tf,af)]+ !Impact of flexibility in hourly activities
					!sum[tg, sum[d, (deltaB_DW(d,tg,ps)-deltaB_UP(d,tg,ps))]*activity_balances(tg,as,ps)]+ !Impact of gas buffers energy consumption
					sum[tk, sum[h, deltaU_CHP(h,tk,ps)]*activity_balances(tk,af,ps)]+ !Impact of use deviation of CHPs
					sum[tk, sum[h, deltaP_CHP(h,tk,ps)]*dP_electricity(tk,af)]+ !Impact in power of power output ratio deviation of CHPs
					sum[tk, sum[h, -CHP_eta(tk)*deltaP_CHP(h,tk,ps)/CHP_eps(tk,ps)]*dP_heat(tk,af)]+ !Impact in heat of power output ratio deviation of CHPs
					sum[ts, sum[h, deltaS_shed(h,ts,ps)]*activity_balances(ts,af,ps)] !Impact of shedding load
					-sum[tw, sum[h, deltaW_UP(h,tw,ps)]*dW_hourly(tw,af)] !Demand increase due to pumping electricity in reservoirs
					=activities_netVolumes(af,ps) !Exogenous drivers
				}
			}
			Constraint balance_activities_matconv {
				IndexDomain: (amc,ps);
				Definition: {
					sum[tb, tech_use(tb,ps)*activity_balances(tb,amc,ps)]+  !Reference activity balance
					sum[tf, sum[h, (deltaQ_UP(h,tf,ps)+deltaQ_DW(h,tf,ps))]*dQ_hourly(tf,amc)]+ !Impact of flexibility in hourly activities
					!sum[tg, sum[d, (deltaB_DW(d,tg,ps)-deltaB_UP(d,tg,ps))]*activity_balances(tg,as,ps)]+ !Impact of gas buffers energy consumption
					sum[tk, sum[h, deltaU_CHP(h,tk,ps)]*activity_balances(tk,amc,ps)]+ !Impact of use deviation of CHPs
					sum[tk, sum[h, deltaP_CHP(h,tk,ps)]*dP_electricity(tk,amc)]+ !Impact in power of power output ratio deviation of CHPs
					sum[tk, sum[h, -CHP_eta(tk)*deltaP_CHP(h,tk,ps)/CHP_eps(tk,ps)]*dP_heat(tk,amc)]+ !Impact in heat of power output ratio deviation of CHPs
					sum[ts, sum[h, deltaS_shed(h,ts,ps)]*activity_balances(ts,amc,ps)] !Impact of shedding load
					-sum[tw, sum[h, deltaW_UP(h,tw,ps)]*dW_hourly(tw,amc)] !Demand increase due to pumping electricity in reservoirs
					=activities_netVolumes(amc,ps) !Exogenous drivers
				}
			}
			Constraint balance_activities_emissionsFix {
				IndexDomain: (acf,ps);
				Definition: {
					sum[t, 
						(tech_use(t,ps)+			! Reference activity balance
						sum[h, deltaU_CHP(h,t,ps)]+		! Impact of use deviation of CHPs
						sum[h, deltaS_shed(h,t,ps)])		! Impact of shedding load
						*activity_balances(t,acf,ps)
					]
					
					=0 !No emission should stay in the non-target emission activities
				}
			}
			Constraint balance_activities_EmissionTarget {
				IndexDomain: (n,ps) | n='NL';
				Definition: {
					!sum[(tb,act), (nodePer_techBal(tb)=n)*tech_use(tb,ps)*activity_balances(tb,act,ps)]  !Reference activity balance
					!              <= emissionTarget(n,ps)
					
					sum[(tb,act), (nodePer_techBal(tb)=n)*tech_use(tb,ps)*activity_balances(tb,act,ps)]+  !Reference activity balance
					sum[(tk,act), (nodePer_techBal(tk)=n)*sum[h, deltaU_CHP(h,tk,ps)]*activity_balances(tk,act,ps)]+ !Impact of use deviation of CHPs
					sum[(ts,act), (nodePer_techBal(ts)=n)*sum[h, deltaS_shed(h,ts,ps)]*activity_balances(ts,act,ps)] !Impact of shedding load
					
					!adjustment to avoid the incentive to create false negative emissions by exporting synfuels (moving emissions outside the scope of the targets)
					+sum[(tb,atf) | (tb='OPE01_03')*(nodePer_techBal(tb)='EU')<>0,(tech_use(tb,ps)*activity_balances(tb,atf,ps))] !transfer of emissions from synfuels for export (syn naphtha)
					+sum[(tb,atf) | (tb='OPE02_03')*(nodePer_techBal(tb)='EU')<>0,(tech_use(tb,ps)*activity_balances(tb,atf,ps))]  !transfer of emissions from synfuels for export (syn road fuels)
					+sum[(tb,atf) | (tb='OPE03_03')*(nodePer_techBal(tb)='EU')<>0,(tech_use(tb,ps)*activity_balances(tb,atf,ps))] !transfer of emissions from synfuels for export (syn kerosene)
					!adjustment to avoid the incentive to create false negative emissions by using synfuels for bunkers(moving emissions outside the scope of the targets)
					+sum[(tb,atb) | (tb='TNB01_05')*(nodePer_techBal(tb)='NL')<>0,(tech_use(tb,ps)*activity_balances(tb,atb,ps))] !transfer of emissions from syndiesel ship 
					+sum[(tb,atb) | (tb='TNB01_08')*(nodePer_techBal(tb)='NL')<>0,(tech_use(tb,ps)*activity_balances(tb,atb,ps))]  !transfer of emissions from methanol ship 
					+sum[(tb,atb) | (tb='TAI01_03')*(nodePer_techBal(tb)='NL')<>0,(tech_use(tb,ps)*activity_balances(tb,atb,ps))] !transfer of emissions from synkerosene airplane 
					!+sum[(tb,atb) | (tb='TAI01_05')*(nodePer_techBal(tb)='NL')<>0,(tech_use(tb,ps)*activity_balances(tb,atb,ps))] !transfer of emissions from e-kerosene airplane 
					
					<=  emissionTarget(n,ps)  ! Includes emissions coming from flexible processes.
				}
			}
			Constraint balance_activities_EmissionTarget_inclScope3 {
				IndexDomain: (n,ps);
				Definition: {
					!sum[(tb,act), (nodePer_techBal(tb)=n)*tech_use(tb,ps)*activity_balances(tb,act,ps)]  !Reference activity balance
					!	 <= emissionTarget(n,ps)
					
					sum[(tb,act), (nodePer_techBal(tb)=n)*tech_use(tb,ps)*activity_balances(tb,act,ps)]+  !Reference activity balance (ETS/non-ETS emissions)
					sum[(tk,act), (nodePer_techBal(tk)=n)*sum[h, deltaU_CHP(h,tk,ps)]*activity_balances(tk,act,ps)]+ !Impact of use deviation of CHPs
					sum[(ts,act), (nodePer_techBal(ts)=n)*sum[h, deltaS_shed(h,ts,ps)]*activity_balances(ts,act,ps)]+ !Impact of shedding load
					sum[(tb,atf), (nodePer_techBal(tb)=n)*tech_use(tb,ps)*activity_balances(tb,atf,ps)]+  !Reference activity balance (feedstock/end of life exported fuels)
					sum[(tb,atb), (nodePer_techBal(tb)=n)*tech_use(tb,ps)*activity_balances(tb,atb,ps)]  !Reference activity balance (bunkers)
					
					<=  emissionTarget_inclScope3(n,ps)
				}
			}
			Constraint balance_activities_EmissionTarget_inclScope3andFuelEx {
				IndexDomain: (ps);
				Definition: {
					!sum[(tb,act), (nodePer_techBal(tb)=n)*tech_use(tb,ps)*activity_balances(tb,act,ps)]  !Reference activity balance
					!	 <= emissionTarget(n,ps)
					
					sum[(tb,act), (nodePer_techBal(tb)='NL')*tech_use(tb,ps)*activity_balances(tb,act,ps)]+  !Reference activity balance (ETS/non-ETS emissions)
					sum[(tk,act), (nodePer_techBal(tk)='NL')*sum[h, deltaU_CHP(h,tk,ps)]*activity_balances(tk,act,ps)]+ !Impact of use deviation of CHPs
					sum[(ts,act), (nodePer_techBal(ts)='NL')*sum[h, deltaS_shed(h,ts,ps)]*activity_balances(ts,act,ps)]+ !Impact of shedding load
					sum[(tb,atf), (nodePer_techBal(tb)='NL')*tech_use(tb,ps)*activity_balances(tb,atf,ps)]+  !Reference activity balance (feedstock/end of life exported fuels)
					sum[(tb,atb), (nodePer_techBal(tb)='NL')*tech_use(tb,ps)*activity_balances(tb,atb,ps)]+  !Reference activity balance (bunkers)
					sum[(tb,atf), (nodePer_techBal(tb)='EU')*tech_use(tb,ps)*activity_balances(tb,atf,ps)]  !fuel exports
					
					<=  emissionTarget_inclScope3andFuelex(ps)  ! Includes emissions coming from flexible processes.
				}
			}
			Constraint balance_activities_EmissionTarget_inclBunkers {
				IndexDomain: (n,ps);
				Definition: {
					!sum[(tb,act), (nodePer_techBal(tb)=n)*tech_use(tb,ps)*activity_balances(tb,act,ps)]  !Reference activity balance
					!	 <= emissionTarget(n,ps)
					
					sum[(tb,act), (nodePer_techBal(tb)=n)*tech_use(tb,ps)*activity_balances(tb,act,ps)]+  !Reference activity balance (ETS/non-ETS emissions)
					sum[(tk,act), (nodePer_techBal(tk)=n)*sum[h, deltaU_CHP(h,tk,ps)]*activity_balances(tk,act,ps)]+ !Impact of use deviation of CHPs
					sum[(ts,act), (nodePer_techBal(ts)=n)*sum[h, deltaS_shed(h,ts,ps)]*activity_balances(ts,act,ps)]+ !Impact of shedding load
					sum[(tb,atb), (nodePer_techBal(tb)=n)*tech_use(tb,ps)*activity_balances(tb,atb,ps)]  !Reference activity balance (bunkers)
					
					<=  emissionTarget_inclbunkers(n,ps)
				}
			}
			Constraint capacity_technologies {
				IndexDomain: (t,ps);
				Definition: {
					tech_use(t,ps)<=cap2act(t)*techStock(t,ps)
					+sum[h, deltaW_UP(h,t,ps)]*(1-phs_Losses(t)) !Pumped hydro storage allows for a higher discharge
				}
			}
			Constraint emission_targetCum {
				IndexDomain: ni;
				Definition: {
					!The sum of the use of all the emissions released to air in each node
					sum[(tb,act,ps), tech_use(tb,ps) * (nodePer_act(act)=ni) * activity_balances(tb,act,ps) * period_weight(ps) * transition_interval]
					<= emissionTarget_cum(ni)
				}
			}
			Constraint storageCO2_cumulative {
				IndexDomain: ni;
				Definition: {
					!The sum of the use of all the CO2 stored in each node
					sum[(tb,ps), tech_use(tb,ps)*(tech_subsector(tb)="CCUS Storage")*period_weight(ps)*transition_interval]
					!The forced constraint
					<=cumulative_CO2storage(ni)
				}
			}
			Constraint min_techUse_constraint {
				IndexDomain: (t,ps);
				Definition: {
					(techUse_min(t,ps)<>0) * (
						tech_use(t,ps)+sum[h, PdeltaU_CHP(h,t,ps)]+sum[h, PdeltaS_shed(h,t,ps)] 
						- techUse_min(t,ps) 
						)
					>= 0
				}
			}
			Constraint max_techUse_constraint {
				IndexDomain: (t,ps);
				Definition: {
					(techUse_max(t,ps)<>0) * (
						tech_use(t,ps)+sum[h, deltaU_CHP(h,t,ps)]+sum[h, deltaS_shed(h,t,ps)]
						- techUse_max(t,ps)
						) 
					<= 0
				}
			}
		}
		DeclarationSection Transition_description {
			Set transition_type {
				Definition: {
					{'Sequential','Simultaneous'}
				}
			}
			Set periods_solve {
				SubsetOf: periods;
				Index: ps, ips, jps;
				Property: ElementsAreLabels;
			}
			Set periods_aux {
				SubsetOf: periods_solve;
				Index: pa;
				Property: ElementsAreNumerical;
				Definition: periods_solve;
			}
			Set actInv_ramp {
				SubsetOf: activities_solve;
				Index: ar, iar, jar;
				Definition: {
					{as | actChange_max(as)>0}
				}
			}
			Set techInv_ramp {
				SubsetOf: technologies;
				Index: tr, itr, jtr;
				Definition: {
					{t | techChange_max(t)>0}
				}
			}
			Parameter period_weight {
				IndexDomain: pss;
				Definition: {
					! Stair formulation
					if (pss=last(periods_selection)) then
						10/(val(last(periods_selection))-val(first(periods_selection))+10) !To weight for the inertia of the system after the last period considering 10 years
					else
						(val(pss+1)-val(pss))/(val(last(periods_selection))-val(first(periods_selection))+10) !To weight for the length of the period
					endif
					
					! INTRP formulation
					!if (pss=last(periods_selection)) then
					!	(10+(val(pss)-val(pss-1))/2)/(val(last(periods_selection))-val(first(periods_selection))+last_period_length) !For the last period
					!elseif (pss=first(periods_selection)) then
					!	((val(pss+1)-val(pss))/2)/(val(last(periods_selection))-val(first(periods_selection))+last_period_length) !For the first period
					!else
					!	((val(pss+1)-val(pss-1))/2)/(val(last(periods_selection))-val(first(periods_selection))+last_period_length) !For all intermediate periods
					!endif
				}
			}
			Parameter period_span {
				IndexDomain: pss;
				Definition: {
					if (pss=first(periods_selection)) then
						(val(pss)-2015)/5 !Hardcoded for 5 year time intervals
					else
						(val(pss)-val(pss-1))/5 !Hardcoded for 5 year time intervals
					endif
				}
			}
			Parameter inv_cost {
				IndexDomain: (t,p);
			}
			Parameter retro_cost {
				IndexDomain: (it,jt);
			}
			Parameter Salvage_value {
				IndexDomain: t;
			}
			Parameter fom_cost {
				IndexDomain: (t,p);
			}
			Parameter WACC {
				IndexDomain: t;
			}
			Parameter social_discount_rate {
				Range: [0, 1];
			}
			Parameter base_year {
				Range: {
					{2020..2100}
				}
			}
			Parameter social_discount_factor {
				IndexDomain: pss;
				Definition: (1+social_discount_rate)^(base_year-(val(pss)));
			}
			Parameter construction_time {
				IndexDomain: t;
			}
			Parameter ec_lifetime {
				IndexDomain: t;
			}
			Parameter CRF {
				IndexDomain: t;
				Definition: {
					[(1-(1+WACC(t))^(-1))/(1-(1+WACC(t))^(-ec_lifetime(t)))]*(1+WACC(t))^(0.5)
					!First element is Capital Recovery Factor (CRF) with discounting to beginning of year, followed by correction for mid-year discounting. Based on TIMES Documentation Part II, Section 6.2.12
					
					!WACC(t)/[1-((1+WACC(t))^(-construction_time(t)-ec_lifetime(t)))] Second version - now replaced with mid-year discounting by Kira
					!depreciation_rate(t)/(1-(1+depreciation_rate(t))^(-tec_lifetime(t))) Original - then construction time added. Corrected in v4.3 by Kira
				}
			}
			Parameter tec_lifetime {
				IndexDomain: t;
			}
			Parameter decomMat_NewInv {
				IndexDomain: (t,pa,ps);
				Definition: {
					(ps>(pa+tec_lifetime(t)))*(ps>=pa) !Years of the selection for which the period value is larger than the investment year (pa) plus the lifetime of the technology
					-(ps-1>(pa+tec_lifetime(t)))*(ps>=pa) !Subsequent years of the selection for which the period value is larger than the investment year (pa) plus the lifetime of the technology
				}
				Comment: {
					"This matrix is a parameter.
					Here we are identifying the year in which technologies will be decommisioned accordingly with their lifetime and the year in which investment occurs."
				}
			}
			Parameter retrofit_relations {
				IndexDomain: (it,jt);
			}
			Parameter actChange_maxOrig {
				IndexDomain: ao;
			}
			Parameter actChange_max {
				IndexDomain: as;
				Definition: {
					actChange_maxOrig(as)+sum[iao | groupOf_activities(as,iao)=1, actChange_maxOrig(iao)*activities_netVolumesOrig(iao,base_year)]/
					(sum[iao | groupOf_activities(as,iao)=1, activities_netVolumesOrig(iao,base_year)] + 1e-20)
				}
			}
			Parameter techChange_max {
				IndexDomain: t;
			}
			Parameter techStock_exist {
				IndexDomain: t;
			}
			Parameter decom_planned {
				IndexDomain: (t,p);
			}
			Parameter decom_plannedSel {
				IndexDomain: (t,ps);
				Definition: sum[ip | ps-1<ip<=ps,decom_planned(t,ip)];
				Comment: {
					"!Convert the decommisioning years from database terms to the solving selection terms 
					(i.e. identify in which years of the solution the planned decommisioning should be considered)
					For instance, it might be the case that the database specifies that decommisioning of exisiting stock will occur in 2025,
					but that we are solving for the set of 2020, 2030, 2040, and 2050. Then the planned decommisioning in the solution should
					be considered to determine the 2030 stock."
				}
			}
			Parameter techStock_min {
				IndexDomain: (t,p);
			}
			Parameter techStock_max {
				IndexDomain: (t,p);
			}
			Parameter no_eco_decom {
				IndexDomain: (t,p);
				Range: binary;
			}
			Parameter no_new_invest {
				IndexDomain: (t,p);
				Range: binary;
			}
			Variable cap_investments {
				IndexDomain: (t,ps);
				Range: nonnegative;
			}
			Variable retrofitting {
				IndexDomain: (it,jt,ps);
				Range: nonnegative;
			}
			Variable eco_decommisioning {
				IndexDomain: (t,ps);
				Range: nonnegative;
				Comment: "This refers to cummulative advanced decommisioning triggered by economical cost-effectiveness";
			}
			Variable decomStock {
				IndexDomain: (t,ps);
				Range: nonnegative;
				Definition: {
					decomStock(t,ps-1) !Decommisioning from previous period (CUMULATIVE) AS VARIABLE
					+decom_PlannedSel(t,ps) !Planned decommissioning of existing stock
					+sum[pa, decomMat_NewInv(t,pa,ps)*(cap_investments(t,pa)+sum[it, retrofitting(it,t,pa)])] !Planned decommisioning of new added stock (EVENT)
					+eco_decommisioning(t,ps) !Premature decommisioning (EVENT)
				}
				Comment: {
					"!Cumulative"
				}
			}
			Variable techStock {
				IndexDomain: (t,ps);
				Range: nonnegative;
				Definition: {
					if(ps=element(periods_selection,1)) then 
						techStock_exist(t) !stocks at the beggining of the year(CUMMULATIVE)
						+cap_investments(t,ps) !new investments (EVENT)
						+sum[it, retrofitting(it,t,ps)] !retrofitted aditions (EVENT)
						-sum[it, retrofitting(t,it,ps)] !retrofitted substractions (EVENT)
						-(decomStock(t,ps)-decomStock(t,ps-1)) !decommisioning in the year (EVENT as it is the difference of the cummulative)
					else
						techStock(t,ps-1) !use the stocks that are being used as variable
						+cap_investments(t,ps) !new investments (EVENT)
						+sum[it, retrofitting(it,t,ps)] !retrofitted aditions (EVENT)
						-sum[it, retrofitting(t,it,ps)] !retrofitted substractions (EVENT)
						-(decomStock(t,ps)-decomStock(t,ps-1)) !decommisioning in the year (EVENT as it is the difference of the cummulative)
					endif
				}
				Comment: {
					"!Cummulative"
				}
			}
			Constraint actStock_constraints {
				IndexDomain: (av,ps);
				Definition: sum[t | activityPer_tech(t)=av, techStock(t,ps)*cap2act(t)+sum[h, deltaS_shed(h,t,ps)]]=activities_netVolumes(av,ps);
			}
			Constraint techStockCap_contraints_mat {
				IndexDomain: (t_m,ps);
				Definition: techStock(t_m,ps)*cap2act(t_m)+sum[h, deltaS_shed(h,t_m,ps)]>=tech_use(t_m,ps);
			}
			Constraint minStock_constraints {
				IndexDomain: (t,ps);
				Definition: techStock(t,ps)>=techStock_min(t,ps);
			}
			Constraint maxStock_constraints {
				IndexDomain: (t,ps);
				Definition: techStock(t,ps)<=techStock_max(t,ps);
			}
			Constraint actInv_constraints {
				IndexDomain: (ar,ps);
				Definition: sum[t | activityPer_tech(t)=ar, cap_investments(t,ps)*cap2act(t)+sum[h, deltaS_shed(h,t,ps)]]<=activities_netVolumes(ar,ps)*actChange_max(ar)*period_span(ps)/100;
			}
			Constraint techInv_constraints {
				IndexDomain: (tr,ps);
				Definition: cap_investments(tr,ps)<=techChange_max(tr)*period_span(ps);
			}
			Constraint retrofit_constraint {
				IndexDomain: (it,jt,ps);
				Definition: {
					if(ps=element(periods_selection,1)) then
						retrofit_relations(it,jt)*techStock_exist(it)-retrofitting(it,jt,ps)
					else
						retrofit_relations(it,jt)*techStock(it,ps-1)-retrofitting(it,jt,ps)
					endif
					
					>=0
				}
			}
			Constraint eco_decom_constraint {
				IndexDomain: (t,ps);
				Definition: no_eco_decom(t,ps) * eco_decommisioning(t,ps) = 0;
			}
			Constraint eco_decom_max {
				IndexDomain: (t,ps);
				Definition: eco_decommisioning(t,ps)<=techStock_exist(t)-decom_plannedSel(t,ps);
			}
			Constraint limit_new_invest {
				IndexDomain: (t,ps);
				Definition: no_new_invest(t,ps) * cap_investments(t,ps) = 0;
				Comment: {
					"To be deleted after test: !sum[(ps)|no_new_invest(t,ps)=1,cap_investments(t,ps)]=0"
				}
			}
		}
		DeclarationSection Hourly_description {
			Set process_type {
				Index: yh;
			}
			Set profile_typeRead {
				SubsetOf: set_of_everything;
			}
			Set profile_type {
				SubsetOf: set_of_everything;
				Index: yp;
				Definition: profile_typeRead+activities_indirect;
			}
			Set activities_hour {
				SubsetOf: activities_solve;
				Index: ah, iah;
				Definition: {
					{as | dispatchType_act(as)='hourly'} + {as | dispatchType_act(as)='hourly-interconnected'}
				}
			}
			Set activities_indirect {
				SubsetOf: activities_solve;
				Index: ap, iap;
				Definition: {
					{as | dispatchType_act(as)='hourly-indirect'}
				}
			}
			Set activities_interconnected {
				SubsetOf: activities_hour;
				Index: ain, iain, jain;
				Definition: {
					{ah | dispatchType_act(ah)='hourly-interconnected'}
				}
			}
			Set tech_Operation {
				SubsetOf: tech_balancers;
				Index: tp;
				Definition: {
					{t |processType_tech(t)='Operation'} !The ones that are marked as so in the database
					+{t | (ord(activityPer_tech(t),activities_group)<>0)*(activity_balances(t,activityPer_tech(t),base_year)=-XC_TransmissionLoss)} !The cross border interconnection within the grouped network
					+{t | (ord(activityPer_tech(t),activities_group)<>0)*(activity_balances(t,activityPer_tech(t),base_year)=-HVtoMV_TransformerLoss)} !The transformers within the grouped network
					+{t | (ord(activityPer_tech(t),activities_group)<>0)*(activity_balances(t,activityPer_tech(t),base_year)=-MVtoLV_TransformerLoss)} !The transformers within the grouped network
					+{t | (ord(activityPer_tech(t),activities_group)<>0)*(activity_balances(t,activityPer_tech(t),base_year)=-HVtoLV_TransformerLoss)} !The transformers within the grouped network
				}
			}
			Set tech_hourlyDispatch {
				SubsetOf: tech_balancers;
				Index: th, ith;
				Definition: {
					{t |processType_tech(t)='Hourly dispatch'} !The ones that are marked as so in the database
					-{t | (ord(activityPer_tech(t),activities_group)<>0)*(activity_balances(t,activityPer_tech(t),base_year)=-XC_TransmissionLoss)} !The cross border interconnection within the grouped network
					-{t | (ord(activityPer_tech(t),activities_group)<>0)*(activity_balances(t,activityPer_tech(t),base_year)=-HVtoMV_TransformerLoss)} !The transformers within the grouped network
					-{t | (ord(activityPer_tech(t),activities_group)<>0)*(activity_balances(t,activityPer_tech(t),base_year)=-MVtoLV_TransformerLoss)} !The transformers within the grouped network
					-{t | (ord(activityPer_tech(t),activities_group)<>0)*(activity_balances(t,activityPer_tech(t),base_year)=-HVtoLV_TransformerLoss)} !The transformers within the grouped network
				}
			}
			Set tech_hourlyReport {
				SubsetOf: tech_balancers;
				Index: thh, ithh, jthh;
				Definition: {
					{th}+{tw}
				}
			}
			Set tech_rampDispatch {
				SubsetOf: tech_hourlyDispatch;
				Index: thr;
				Definition: {
					{t | ramping(t)>0}
				}
			}
			Set tech_hourlyInterconnection {
				SubsetOf: tech_hourlyDispatch;
				Index: thin, ithin, jthin;
				Definition: {
					{thh | tech_category(thh)='External' and tech_subsector(thh)="Inland generation"}
				}
			}
			ElementParameter processType_tech {
				IndexDomain: tb;
				Range: process_type;
			}
			ElementParameter profileType_techRead {
				IndexDomain: tb;
				Range: profile_type;
			}
			ElementParameter profileType_tech {
				IndexDomain: tb;
				Range: profile_type;
				Definition: {
					if (activityPer_tech(tb) in activities_indirect) then
						activityPer_tech(tb)
					elseif (CHP_prod(tb) in activities_indirect) then
						CHP_prod(tb)
					else
						profileType_techRead(tb)
					endif
				}
			}
			Parameter ramping {
				IndexDomain: tb;
			}
			Parameter hourly_profilesRead {
				IndexDomain: (h,yp);
				Definition: sum[ho, hourly_profilesReadOrig(ho,yp)*(hoursPer_hourOrig(ho)=h)];
			}
			Parameter hourly_profilesReadOrig {
				IndexDomain: (ho,yp);
			}
			Parameter hourly_profiles {
				IndexDomain: (h,yp);
				Definition: {
					if (yp in activities_indirect) then
						sum[itb | activity_balances(itb,yp,base_year)<0, hourly_profilesRead(h,profileType_techRead(itb))*activity_balances(itb,yp,base_year)]
						/sum[itb | activity_balances(itb,yp,base_year)<0, activity_balances(itb,yp,base_year)]
					else
						hourly_profilesRead(h,yp)
					endif
				}
			}
			Parameter interconnectedHourly_prices {
				IndexDomain: (h,ain,p);
				Definition: round(sum[ho, interconnectedHourly_pricesOrig(ho,ain,p)*(hoursPer_hourOrig(ho)=h)]/(24/hoursPer_day),2);
			}
			Parameter interconnectedHourly_pricesOrig {
				IndexDomain: (ho,ain,p);
			}
			Parameter vom_interconnected_hourly {
				IndexDomain: (h,thin,p);
				Definition: interconnectedHourly_prices(h,activityPer_techOrig(thin),p);
			}
			Parameter baseload_treshold {
				InitialData: 0.05;
			}
			Parameter shedding_inLoad {
				Range: binary;
				InitialData: 0;
			}
			Variable tech_useHourly {
				IndexDomain: (h,thh,ps);
				Range: nonnegative;
			}
			Constraint balance_activitiesHourly {
				IndexDomain: (h,ah,ps);
				Definition: {
					sum[th, tech_useHourly(h,th,ps)*activity_balances(th,ah,ps)]+ !Hourly dispatch units
					sum[tw, tech_useHourly(h,tw,ps)*activity_balances(tw,ah,ps)-deltaW_UP(h,tw,ps)*dW_hourly(tw,ah)]+ !Water Reservoirs
					sum[td, tech_useDaily(dayPer_hour(h),td,ps)*activity_balances(td,ah,ps)/hoursPer_day]+ !Daily dispatch units (asssuming flat hourly consumption of electricity)
					!sum[tg, (deltaB_DW(dayPer_hour(h),tg,ps)-deltaB_UP(dayPer_hour(h),tg,ps))*activity_balances(tg,ah,ps)/24]+ !Gas buffers consumption (asssuming flat hourly consumption of electricity)
					sum[tp, tech_use(tp,ps)*hourly_profiles(h,profileType_tech(tp))*activity_balances(tp,ah,ps)]+ !Operation of non dispatchable technologies
					sum[tf, (deltaQ_UP(h,tf,ps)+deltaQ_DW(h,tf,ps))*dQ_hourly(tf,ah)]+ !Demand respond of flexible technologies
					sum[tk, (tech_use(tk,ps)*hourly_profiles(h,profileType_tech(tk))+deltaU_CHP(h,tk,ps))*activity_balances(tk,ah,ps)]+ !Operation of flexible CHPs
					sum[tk, deltaP_CHP(h,tk,ps)*dP_electricity(tk,ah)]+ !Flexibility in Power/Heat range of CHP output
					sum[ts, (tech_use(ts,ps)*hourly_profiles(h,profileType_tech(ts))+deltaS_shed(h,ts,ps))*activity_balances(ts,ah,ps)] !Shedded use of technologies
					=0
				}
			}
			Constraint balance_yearlyhourly {
				IndexDomain: (th,ps);
				Definition: tech_use(th,ps)=sum[h,tech_useHourly(h,th,ps)];
			}
			Constraint capacity_techHourly {
				IndexDomain: (h,th,ps);
				Definition: tech_useHourly(h,th,ps)<=techStock(th,ps)*cap2act(th)*hourly_profiles(h,profileType_tech(th));
			}
			Constraint rampingUP_techHourly {
				IndexDomain: (h,thr,ps);
				Definition: {
					tech_useHourly(h,thr,ps)-tech_useHourly(h-1,thr,ps)*(h<>1)-tech_useHourly(card(hours),thr,ps)*(h=1)<=
					techStock(thr,ps)*cap2act(thr)*hourly_profiles(h,profileType_tech(thr))*ramping(thr)
				}
			}
			Constraint rampingDW_techHourly {
				IndexDomain: (h,thr,ps);
				Definition: {
					tech_useHourly(h,thr,ps)-tech_useHourly(h-1,thr,ps)*(h<>1)-tech_useHourly(card(hours),thr,ps)*(h=1)>=
					-techStock(thr,ps)*cap2act(thr)*hourly_profiles(h,profileType_tech(thr))*ramping(thr)
				}
			}
		}
		DeclarationSection Daily_description {
			Set activities_day {
				SubsetOf: activities_solve;
				Index: ad;
				Definition: {
					{as | dispatchType_act(as)='daily'}
				}
			}
			Set tech_dailyDispatch {
				SubsetOf: tech_balancers;
				Index: td, itd;
				Definition: {
					{t |processType_tech(t)='Daily dispatch'} !The ones that are marked as so in the database
					-{t | (ord(activityPer_tech(t),activities_group)<>0)*(activity_balances(t,activityPer_tech(t),base_year)=0)} !The intergrid compressors that cancel each other due to grouping
				}
			}
			Set tech_gasBuffer {
				SubsetOf: tech_balancers;
				Index: tg, itg;
				Definition: {
					{t |processType_tech(t)='Gas buffer'}
				}
			}
			ElementParameter buffer_activityOrig {
				IndexDomain: tb;
				Range: activities_original;
			}
			ElementParameter buffer_activity {
				IndexDomain: tb;
				Range: activities_day;
				Definition: actSolvePer_actOrig(buffer_activityOrig(tb));
			}
			Parameter dB_daily {
				IndexDomain: (tg,ad);
				Definition: buffer_activity(tg)=ad;
			}
			Parameter bufferUP_capacity {
				IndexDomain: tb;
			}
			Parameter bufferDW_capacity {
				IndexDomain: tb;
			}
			Parameter buffer_storage {
				IndexDomain: tb;
			}
			Variable tech_useDaily {
				IndexDomain: (d,td,ps);
				Range: nonnegative;
			}
			Variable deltaB_UP {
				IndexDomain: (d,tg,ps);
				Range: nonpositive;
			}
			Variable deltaB_DW {
				IndexDomain: (d,tg,ps);
				Range: nonnegative;
			}
			Variable deltaB_S {
				IndexDomain: (d,tg,ps);
				Range: nonpositive;
				Definition: {
					if (d=1) then
						deltaB_S(365,tg,ps)+deltaB_UP(d,tg,ps)+deltaB_DW(d,tg,ps)
					else
						deltaB_S(d-1,tg,ps)+deltaB_UP(d,tg,ps)+deltaB_DW(d,tg,ps)
					endif
				}
			}
			Constraint balance_activitiesDaily {
				IndexDomain: (d,ad,ps);
				Definition: {
					sum[th, sum[ih | dayPer_hour(ih)=d, tech_useHourly(ih,th,ps)*activity_balances(th,ad,ps)]]+ !Hourly dispatch units
					sum[td, tech_useDaily(d,td,ps)*activity_balances(td,ad,ps)]+ !Daily dispatch units
					sum[tg, (deltaB_UP(d,tg,ps)+deltaB_DW(d,tg,ps))*dB_daily(tg,ad)]+ !Daily buffer units
					!sum[tg, (deltaB_DW(d,tg,ps)-deltaB_UP(d,tg,ps))*activity_balances(tg,ad,ps)]+ !Gas buffers consumption 
					sum[tp, sum[ih | dayPer_hour(ih)=d, tech_use(tp,ps)*hourly_profiles(ih,profileType_tech(tp))*activity_balances(tp,ad,ps)]]+ !Operation of non dispatchable technologies
					sum[tk, sum[ih | dayPer_hour(ih)=d, (tech_use(tk,ps)*hourly_profiles(ih,profileType_tech(tk))+deltaU_CHP(ih,tk,ps))*activity_balances(tk,ad,ps)]]+ !Operation of flexible CHPs
					sum[ts, sum[ih | dayPer_hour(ih)=d, (tech_use(ts,ps)*hourly_profiles(ih,profileType_tech(ts))+deltaS_shed(ih,ts,ps))*activity_balances(ts,ad,ps)]] !Operation of shedding technologies
					=0
				}
			}
			Constraint balance_yearlyDaily {
				IndexDomain: (td,ps);
				Definition: tech_use(td,ps)=sum[d,tech_useDaily(d,td,ps)];
			}
			Constraint capacity_techDaily {
				IndexDomain: (d,td,ps);
				Definition: tech_useDaily(d,td,ps)<=techStock(td,ps)*cap2act(td)*sum[ih | dayPer_hour(ih)=d, hourly_profiles(ih,profileType_tech(td))];
			}
			Constraint balanceY_dB {
				IndexDomain: (tg,ps);
				Definition: sum[d, deltaB_UP(d,tg,ps)+deltaB_DW(d,tg,ps)]=0;
			}
			Constraint capacityUP_dB {
				IndexDomain: (d,tg,ps);
				Definition: deltaB_UP(d,tg,ps)>=-bufferUP_capacity(tg)*techStock(tg,ps);
			}
			Constraint capacityDW_dB {
				IndexDomain: (d,tg,ps);
				Definition: deltaB_DW(d,tg,ps)<=bufferDW_capacity(tg)*techStock(tg,ps);
			}
			Constraint cummulativeS_dB {
				IndexDomain: (d,tg,ps);
				Definition: deltaB_S(d,tg,ps)>=-techStock(tg,ps)*buffer_storage(tg)*bufferDW_capacity(tg);
			}
		}
		DeclarationSection CHPs_descritpion {
			Set tech_hourlyCHPflex {
				SubsetOf: tech_balancers;
				Index: tk;
				Definition: {
					{t |processType_tech(t)='CHP flexible'}
				}
			}
			Set tech_hourlyCHPflexH {
				SubsetOf: tech_hourlyCHPflex;
				Index: tk_h;
				Definition: {
					{tk | CHP_range(tk)='1 hour [h]'}
				}
			}
			Set tech_hourlyCHPflexD {
				SubsetOf: tech_hourlyCHPflex;
				Index: tk_d;
				Definition: {
					{tk | CHP_range(tk)='1 day [d]'}
				}
			}
			Set tech_hourlyCHPflexW {
				SubsetOf: tech_hourlyCHPflex;
				Index: tk_w;
				Definition: {
					{tk | CHP_range(tk)='1 week [w]'}
				}
			}
			ElementParameter CHP_prodOrig {
				IndexDomain: tb;
				Range: activities_solve;
			}
			ElementParameter CHP_prod {
				IndexDomain: tb;
				Range: activities_solve;
				Definition: actSolvePer_actOrig(CHP_prodOrig(tb));
			}
			ElementParameter CHP_fuelOrig {
				IndexDomain: tb;
				Range: activities_solve;
			}
			ElementParameter CHP_fuel {
				IndexDomain: tb;
				Range: activities_solve;
				Definition: actSolvePer_actOrig(CHP_fuelOrig(tb));
			}
			ElementParameter CHP_range {
				IndexDomain: tb;
				Range: range_type;
			}
			Parameter CHP_eps {
				IndexDomain: (tk,p);
				Definition: {
					sum[iah | dP_electricity(tk,iah)=1, activity_balances(tk,iah,p)]/
					(-activity_balances(tk,CHP_fuel(tk),p)-activity_balances(tk,CHP_prod(tk),p)/CHP_eta(tk))
				}
			}
			Parameter CHP_eta {
				IndexDomain: tb;
			}
			Parameter CHPdev_use {
				IndexDomain: tb;
			}
			Parameter CHPdev_PtoH {
				IndexDomain: tb;
			}
			Parameter dP_electricity {
				IndexDomain: (tk,ah);
				Definition: (activity_balances(tk,ah,base_year)>0)*(labelPer_act(ah)='Electricity');
			}
			Parameter dP_heat {
				IndexDomain: (tk,as);
				Definition: as=CHP_prod(tk);
			}
			Variable deltaU_CHP {
				IndexDomain: (h,tk,ps);
				Range: free;
			}
			Variable deltaP_CHP {
				IndexDomain: (h,tk,ps);
				Range: free;
			}
			Constraint balanceH_deltaHchp {
				IndexDomain: (h,tk_h,ps);
				Definition: {
					deltaU_CHP(h,tk_h,ps)*activity_balances(tk_h,CHP_prod(tk_h),ps)
					=
					CHP_eta(tk_h)*deltaP_CHP(h,tk_h,ps)/CHP_eps(tk_h,ps)
				}
				Comment: {
					"! Simplified version. We keep the older version below to be consistent with the similar daily and weekly constraints. 
					
					!!sum(H2h)=sum(H0h)
					!(tech_use(tk_h,ps)*hourly_profiles(h,profileType_tech(tk_h))+deltaU_CHP(h,tk_h,ps))
					!*activity_balances(tk_h,CHP_prod(tk_h),ps) !H1 due to dU
					!-CHP_eta(tk_h)*deltaP_CHP(h,tk_h,ps)/CHP_eps(tk_h,ps)
					!= !dH from H1 to H2 due to dP
					!(tech_use(tk_h,ps)*hourly_profiles(h,profileType_tech(tk_h)))
					!*activity_balances(tk_h,CHP_prod(tk_h),ps) !H0"
				}
			}
			Constraint balanceD_deltaHchp {
				IndexDomain: (d,tk_d,ps);
				Definition: {
					!sum(H2h)=sum(H0h)
					sum[ih | dayPer_hour(ih)=d,
					(tech_use(tk_d,ps)*hourly_profiles(ih,profileType_tech(tk_d))+deltaU_CHP(ih,tk_d,ps))*activity_balances(tk_d,CHP_prod(tk_d),ps) !H1 due to dU
					-CHP_eta(tk_d)*deltaP_CHP(ih,tk_d,ps)/CHP_eps(tk_d,ps)]= !dH from H1 to H2 due to dP
					sum[ih | dayPer_hour(ih)=d,
					(tech_use(tk_d,ps)*hourly_profiles(ih,profileType_tech(tk_d)))*activity_balances(tk_d,CHP_prod(tk_d),ps)]
				}
			}
			Constraint balanceW_deltaHchp {
				IndexDomain: (w,tk_w,ps);
				Definition: {
					!sum(H2h)=sum(H0h)
					sum[ih | weekPer_hour(ih)=w,
					(tech_use(tk_w,ps)*hourly_profiles(ih,profileType_tech(tk_w))+deltaU_CHP(ih,tk_w,ps))*activity_balances(tk_w,CHP_prod(tk_w),ps) !H1 due to dU
					-CHP_eta(tk_w)*deltaP_CHP(ih,tk_w,ps)/CHP_eps(tk_w,ps)]= !dH from H1 to H2 due to dP
					sum[ih | weekPer_hour(ih)=w,
					(tech_use(tk_w,ps)*hourly_profiles(ih,profileType_tech(tk_w)))*activity_balances(tk_w,CHP_prod(tk_w),ps)]
				}
			}
			Constraint capacityUP_deltaUchp {
				IndexDomain: (h,tk,ps);
				Definition: deltaU_CHP(h,tk,ps)<=tech_use(tk,ps)*hourly_profiles(h,profileType_tech(tk))*CHPdev_use(tk);
			}
			Constraint capacityDW_deltaUchp {
				IndexDomain: (h,tk,ps);
				Definition: deltaU_CHP(h,tk,ps)>=-tech_use(tk,ps)*hourly_profiles(h,profileType_tech(tk))*CHPdev_use(tk);
			}
			Constraint capacityUP_deltaPchp {
				IndexDomain: (h,tk,ps);
				Definition: {
					deltaP_CHP(h,tk,ps)<=
					(tech_use(tk,ps)*hourly_profiles(h,profileType_tech(tk))+deltaU_CHP(h,tk,ps))* !Use after dU, U1
					sum[iah | dP_electricity(tk,iah)=1, activity_balances(tk,iah,ps)]*CHPdev_PtoH(tk)
				}
			}
			Constraint capacityDW_deltaPchp {
				IndexDomain: (h,tk,ps);
				Definition: {
					deltaP_CHP(h,tk,ps)>=
					-(tech_use(tk,ps)*hourly_profiles(h,profileType_tech(tk))+deltaU_CHP(h,tk,ps))* !Use after dU, U1
					sum[iah | dP_electricity(tk,iah)=1, activity_balances(tk,iah,ps)]*CHPdev_PtoH(tk)
				}
			}
		}
		DeclarationSection Flex_description {
			Set flexibility_type {
				Index: yf;
			}
			Set tech_shedding {
				SubsetOf: tech_balancers;
				Index: ts;
				Definition: {
					{t |processType_tech(t)='Shedding'}
				}
			}
			Set tech_shedH {
				SubsetOf: tech_shedding;
				Index: ts_h;
				Definition: {
					{ts | shed_range(ts)='1 hour [h]'}
				}
			}
			Set tech_shedW {
				SubsetOf: tech_shedding;
				Index: ts_w;
				Definition: {
					{ts | shed_range(ts)='1 week [w]'}
				}
			}
			Set tech_reservoir {
				SubsetOf: tech_balancers;
				Index: tw, itw, jtw;
				Definition: {
					{t |processType_tech(t)='Water Reservoir'}
				}
			}
			Set tech_flexible {
				SubsetOf: tech_balancers;
				Index: tf;
				Definition: {
					{tb |flexibilityType_tech(tb)<>'none'}
				}
			}
			Set tech_flexLT {
				SubsetOf: tech_flexible;
				Index: tfl;
				Definition: {
					{tf |flexibilityType_tech(tf)<>'BE shifting'}
				}
				Comment: {
					"!Built Environment shifting in short term following sequential rules (i.e. you cannot reschedule load of the past in the future)"
				}
			}
			Set tech_fDRshifting {
				SubsetOf: tech_flexible;
				Index: tfs;
				Definition: {
					{tf |flexibilityType_tech(tf)='DR shifting'}
				}
			}
			Set tech_fBEshifting {
				SubsetOf: tech_flexible;
				Index: tfe;
				Definition: {
					{tf |flexibilityType_tech(tf)='BE shifting'}
				}
				Comment: {
					"!Built Environment shifting in short term following sequential rules (i.e. you cannot reschedule load of the past in the future)"
				}
			}
			Set tech_fStorage {
				SubsetOf: tech_flexible;
				Index: tfb;
				Definition: {
					{tf |flexibilityType_tech(tf)='Storage'}
				}
			}
			Set tech_fEV {
				SubsetOf: tech_flexible;
				Index: tfv;
				Definition: {
					{tf |flexibilityType_tech(tf)='EV smart charge'} + {tf |flexibilityType_tech(tf)='EV P-to-Grid'}
				}
			}
			Set tech_fEVcharging {
				SubsetOf: tech_fEV;
				Index: tfvc;
				Definition: {
					{tfv |flexibilityType_tech(tfv)='EV smart charge'}
				}
			}
			Set tech_fEVgrid {
				SubsetOf: tech_fEV;
				Index: tfvg;
				Definition: {
					{tfv |flexibilityType_tech(tfv)='EV P-to-Grid'}
				}
			}
			Set tech_fWithBattery {
				SubsetOf: tech_flexible;
				Index: tfwb;
				Definition: tech_fStorage+tech_fEV;
			}
			Set tech_flexD {
				SubsetOf: tech_flexible;
				Index: tf_d;
				Definition: {
					{tf | flex_range(tf)='1 day [d]'}
				}
			}
			Set tech_flexR {
				SubsetOf: tech_flexible;
				Index: tf_r;
				Definition: {
					{tf | flex_range(tf)='3 days [r]'}
				}
			}
			Set tech_flexW {
				SubsetOf: tech_flexible;
				Index: tf_w;
				Definition: {
					{tf | flex_range(tf)='1 week [w]'}
				}
			}
			Set tech_flexM {
				SubsetOf: tech_flexible;
				Index: tf_m;
				Definition: {
					{tf | flex_range(tf)='1 month [m]'}
				}
			}
			Set tech_flexS {
				SubsetOf: tech_flexible;
				Index: tf_s;
				Definition: {
					{tf | flex_range(tf)='1 season [s]'}
				}
			}
			Set tech_flexB {
				SubsetOf: tech_flexible;
				Index: tf_b;
				Definition: {
					{tf | flex_range(tf)='6 months [b]'}
				}
			}
			Set tech_flexY {
				SubsetOf: tech_flexible;
				Index: tf_y;
				Definition: {
					{tf | flex_range(tf)='1 year [y]'}
				}
			}
			ElementParameter flexibilityType_tech {
				IndexDomain: tb;
				Range: flexibility_type;
			}
			ElementParameter shed_range {
				IndexDomain: tb;
				Range: range_type;
			}
			ElementParameter hybrid_substitute {
				IndexDomain: tb;
				Range: activities_solve;
			}
			ElementParameter flex_activityOrig {
				IndexDomain: tb;
				Range: activities_original;
			}
			ElementParameter flex_activity {
				IndexDomain: tb;
				Range: activities_hour;
				Definition: actSolvePer_actOrig(flex_activityOrig(tb));
			}
			ElementParameter flex_range {
				IndexDomain: tb;
				Range: range_type;
			}
			ElementParameter profileType_EVuse {
				IndexDomain: tfv;
				Range: profile_type;
				Definition: {
					StringToElement(profile_type,profileType_tech(tfv)+" - Use",0);
				}
			}
			Parameter dQ_hourly {
				IndexDomain: (tf,ah);
				Definition: flex_activity(tf)=ah;
			}
			Parameter dS_hourly {
				IndexDomain: (ts,ah);
				Definition: activity_balances(ts,ah,base_year)<0;
			}
			Parameter dW_hourly {
				IndexDomain: (tw,ah);
				Definition: activity_balances(tw,ah,base_year)=1;
			}
			Parameter shed_capacity_percentage {
				IndexDomain: tb;
			}
			Parameter shed_capacity {
				IndexDomain: (ts,ps);
				Definition: {
					shed_capacity_percentage(ts) *
					max((h),hourly_profiles(h,profileType_tech(ts))) *  
					cap2act(ts)
				}
			}
			Parameter shed_volume {
				IndexDomain: tb;
			}
			Parameter phs_capacity {
				IndexDomain: tb;
			}
			Parameter phs_storage {
				IndexDomain: tb;
			}
			Parameter phs_losses {
				IndexDomain: tb;
			}
			Parameter hybrid_ratio {
				IndexDomain: tb;
			}
			Parameter flex_capacity_percentage {
				IndexDomain: tb;
				Range: [0, 1];
			}
			Parameter flex_capacity {
				IndexDomain: (tb,ps);
				Definition: {
					if flexibilityType_tech(tb)='Storage' then 
						flex_capacity_percentage(tb) *
						max((h),hourly_profiles(h,profileType_tech(tb))) * 
						cap2act(tb)
					else
						flex_capacity_percentage(tb) *
						max((h),hourly_profiles(h,profileType_tech(tb))) * 
						(-1 * activity_balances(tb,flex_activity(tb),ps)) *  !this line is removed for battery storage
						cap2act(tb)
					endif;
				}
			}
			Parameter flex_storage {
				IndexDomain: tb;
			}
			Parameter flex_losses {
				IndexDomain: tb;
			}
			Parameter flex_nnLoad {
				IndexDomain: tb;
			}
			Parameter avg_journey {
				IndexDomain: tb;
			}
			Parameter avg_speed {
				IndexDomain: tb;
			}
			Variable deltaS_shed {
				IndexDomain: (h,ts,ps);
				Range: nonpositive;
			}
			Variable deltaQ_UP {
				IndexDomain: (h,tf,ps);
				Range: nonpositive;
				Comment: {
					"!Be aware that DQ refere to change in the demand of the energy carrier, which implies a negative simbol in the balance. A negative value of DQ corresponds to an increase in the demand."
				}
			}
			Variable deltaQ_DW {
				IndexDomain: (h,tf,ps);
				Range: nonnegative;
			}
			Variable deltaQ_S {
				IndexDomain: (h,tfwb,ps);
				Range: nonpositive;
				Definition: {
					if (h=1) then
						deltaQ_S(card(hours),tfwb,ps)+deltaQ_UP(h,tfwb,ps)*(1-flex_Losses(tfwb))+deltaQ_DW(h,tfwb,ps)
					else
						deltaQ_S(h-1,tfwb,ps)+deltaQ_UP(h,tfwb,ps)*(1-flex_Losses(tfwb))+deltaQ_DW(h,tfwb,ps)
					endif
				}
			}
			Variable deltaQd_UP {
				IndexDomain: (d,tfl,ps);
				Range: nonpositive;
				Definition: sum[ih | dayPer_hour(ih)=d, deltaQ_UP(ih,tfl,ps)];
			}
			Variable deltaQd_DW {
				IndexDomain: (d,tfl,ps);
				Range: nonnegative;
				Definition: sum[ih | dayPer_hour(ih)=d, deltaQ_DW(ih,tfl,ps)];
			}
			Variable deltaW_UP {
				IndexDomain: (h,tw,ps);
				Range: nonnegative;
			}
			Variable deltaW_S {
				IndexDomain: (h,tw,ps);
				Range: nonnegative;
				Definition: {
					if (h=1) then
						deltaW_S(card(hours),tw,ps)						!Previous hour reserve
						+deltaW_UP(h,tw,ps)*(1-phs_Losses(tw))					!Pumped energy
						+techStock(tw,ps)*cap2act(tw)*hourly_profiles(h,profileType_tech(tw))	!Natural inflow to the reservoir
						-tech_useHourly(h,tw,ps)						!Discharged energy
					else
						deltaW_S(h-1,tw,ps)							!Previous hour reserve
						+deltaW_UP(h,tw,ps)*(1-phs_Losses(tw))					!Pumped energy
						+techStock(tw,ps)*cap2act(tw)*hourly_profiles(h,profileType_tech(tw))	!Natural inflow to the reservoir
						-tech_useHourly(h,tw,ps)						!Discharged energy
					endif
				}
			}
			Constraint balanceH_deltaS {
				IndexDomain: (h,ts_h,ps);
				Definition: deltaS_shed(h,ts_h,ps) >= -tech_use(ts_h,ps) * (shed_volume(ts_h)<>0) * (shed_volume(ts_h)<>0) * hourly_profiles(h,profileType_tech(ts_h));
			}
			Constraint balanceW_deltaS {
				IndexDomain: (w,ts_w,ps);
				Definition: {
					sum[ih | weekPer_hour(ih)=w, deltaS_shed(ih,ts_w,ps)]>=
					-tech_use(ts_w,ps)*shed_volume(ts_w)*sum[ih | weekPer_hour(ih)=w, hourly_profiles(ih,profileType_tech(ts_w))]
				}
			}
			Constraint capacity_deltaS {
				IndexDomain: (h,ts,ps);
				Definition: deltaS_shed(h,ts,ps) >= -1 * techStock(ts,ps) * shed_capacity(ts,ps);
			}
			Constraint sufficiency_deltaS {
				IndexDomain: (h,ts,ps);
				Definition: deltaS_shed(h,ts,ps)>=-tech_use(ts,ps)*hourly_profiles(h,profileType_tech(ts));
			}
			Constraint balanceQ_deltaQtfe {
				IndexDomain: (q,tfe,ps);
				Definition: {
					!sum[ih | hoursPer_quarter*(q+flex_range(tfe)-1)>=ih>hoursPer_quarter*(q-1), deltaQ_UP(ih,tfe,ps)+deltaQ_DW(ih,tfe,ps)*(1-flex_losses(tfe))]=0
					sum[ih | quarterPer_hour(ih)=q, deltaQ_UP(ih,tfe,ps)+deltaQ_DW(ih,tfe,ps)/(1-flex_losses(tfe))]=0
				}
			}
			Constraint balanceD_deltaQd {
				IndexDomain: (d,tf_d,ps);
				Definition: deltaQd_UP(d,tf_d,ps)+deltaQd_DW(d,tf_d,ps)/(1-flex_losses(tf_d))=0;
			}
			Constraint balanceR_deltaQd {
				IndexDomain: (r,tf_r,ps);
				Definition: sum[id | rangePer_day(id)=r, deltaQd_UP(id,tf_r,ps)+deltaQd_DW(id,tf_r,ps)/(1-flex_losses(tf_r))]=0;
			}
			Constraint balanceW_deltaQd {
				IndexDomain: (r,tf_w,ps);
				Definition: sum[id | weekPer_day(id)=r, deltaQd_UP(id,tf_w,ps)+deltaQd_DW(id,tf_w,ps)/(1-flex_losses(tf_w))]=0;
			}
			Constraint balanceM_deltaQd {
				IndexDomain: (m,tf_m,ps);
				Definition: sum[id | monthPer_day(id)=m, deltaQd_UP(id,tf_m,ps)+deltaQd_DW(id,tf_m,ps)/(1-flex_losses(tf_m))]=0;
			}
			Constraint balanceS_deltaQd {
				IndexDomain: (s,tf_s,ps);
				Definition: sum[id | seasonPer_day(id)=s, deltaQd_UP(id,tf_s,ps)+deltaQd_DW(id,tf_s,ps)/(1-flex_losses(tf_s))]=0;
			}
			Constraint balanceB_deltaQd {
				IndexDomain: (b,tf_b,ps);
				Definition: {
					!sum[ih | 24*(d+flex_range(tfs)-1)>=ih>24*(d-1), deltaQ_UP(ih,tfs,ps)+deltaQ_DW(ih,tfs,ps)*(1-flex_losses(tfs))]=0
					sum[id | semesterPer_day(id)=b, deltaQd_UP(id,tf_b,ps)+deltaQd_DW(id,tf_b,ps)/(1-flex_losses(tf_b))]=0
				}
			}
			Constraint balanceY_deltaQd {
				IndexDomain: (tf_y,ps);
				Definition: sum[d, deltaQd_UP(d,tf_y,ps)+deltaQd_DW(d,tf_y,ps)/(1-flex_losses(tf_y))]=0;
			}
			Constraint capacityUP_dQtfe {
				IndexDomain: (h,tfe,ps);
				Definition: {
					deltaQ_UP(h,tfe,ps)
					>=-
					(flex_capacity(tfe,ps)*techStock(tfe,ps)+hourly_profiles(h,profileType_tech(tfe))*activity_balances(tfe,flex_activity(tfe),ps)*tech_use(tfe,ps))*flex_nnLoad(tfe)
				}
				Comment: {
					"!Here we don\'t use (1-flex_nnLoad because we don\'t want to roast people in their homes this nnLoad stands for the operation band-wide"
				}
			}
			Constraint capacityUP_dQtfs {
				IndexDomain: (h,tfs,ps);
				Definition: {
					!deltaQ_UP(h,tfs,ps)>=-(flex_capacities(tfs)+hourly_profiles(h,profileType_tech(tfs))*activity_balances(tfs,'Electricity',ps))*tech_use(tfs,ps)*flex_comfort(tfs)
					deltaQ_UP(h,tfs,ps)
					>=-
					(flex_capacity(tfs,ps)*techStock(tfs,ps)+hourly_profiles(h,profileType_tech(tfs))*activity_balances(tfs,flex_activity(tfs),ps)*tech_use(tfs,ps))!*(1-flex_nnLoad(tfs))
				}
			}
			Constraint capacityUP_dQtfb {
				IndexDomain: (h,tfb,ps);
				Definition: deltaQ_UP(h,tfb,ps)>=-techStock(tfb,ps)*flex_capacity(tfb,ps);
			}
			Constraint capacityUP_dQtfv {
				IndexDomain: (h,tfv,ps);
				Definition: {
					deltaQ_UP(h,tfv,ps)>=
					-(flex_capacity(tfv,ps) *
					(techStock(tfv,ps)-tech_use(tfv,ps)*hourly_profiles(h,profileType_EVuse(tfv))/(avg_speed(tfv))*(24/hoursPer_day)) +
					tech_use(tfv,ps)*activity_balances(tfv,flex_activity(tfv),ps)*hourly_profiles(h,profileType_tech(tfv))
					)
				}
			}
			Constraint capacityUP_dW {
				IndexDomain: (h,tw,ps);
				Definition: {
					deltaW_UP(h,tw,ps)<=techStock(tw,ps)*phs_capacity(tw)*hourly_profiles(h,'Flat')*GWtoPJ_y !(HARDCODED)
				}
			}
			Constraint capacityDW_dQtfe {
				IndexDomain: (h,tfe,ps);
				Definition: {
					deltaQ_DW(h,tfe,ps)
					<=
					-hourly_profiles(h,profileType_tech(tfe))*activity_balances(tfe,flex_activity(tfe),ps)*tech_use(tfe,ps)*(1-flex_nnLoad(tfe))
				}
			}
			Constraint capacityDW_dQtfs {
				IndexDomain: (h,tfs,ps);
				Definition: {
					deltaQ_DW(h,tfs,ps)
					<=
					-hourly_profiles(h,profileType_tech(tfs))*activity_balances(tfs,flex_activity(tfs),ps)*tech_use(tfs,ps)*(1-flex_nnLoad(tfs))
				}
			}
			Constraint capacityDW_dQtfb {
				IndexDomain: (h,tfb,ps);
				Definition: deltaQ_DW(h,tfb,ps)<=techStock(tfb,ps)*flex_capacity(tfb,ps);
				Comment: {
					"!Assuming symetrical (dis)charging"
				}
			}
			Constraint capacityDW_dQtfvc {
				IndexDomain: (h,tfvc,ps);
				Definition: {
					deltaQ_DW(h,tfvc,ps)
					<=
					-tech_use(tfvc,ps)*activity_balances(tfvc,flex_activity(tfvc),ps)*hourly_profiles(h,profileType_tech(tfvc))*(1-flex_nnLoad(tfvc))
				}
			}
			Constraint capacityDW_dQtfvg {
				IndexDomain: (h,tfvg,ps);
				Definition: {
					deltaQ_DW(h,tfvg,ps)<=flex_capacity(tfvg,ps)*(techStock(tfvg,ps)
					-tech_use(tfvg,ps)*hourly_profiles(h,profileType_EVuse(tfvg))/(avg_speed(tfvg)*(24/hoursPer_day)))
				}
			}
			Constraint capacityDW_dW {
				IndexDomain: (h,tw,ps);
				Definition: {
					tech_useHourly(h,tw,ps)<=techStock(tw,ps)*hourly_profiles(h,'Flat')*GWtoPJ_y !(HARDCODED)
				}
			}
			Constraint cumulativeUP_dQtfe {
				IndexDomain: (q,tfe,ps);
				Definition: {
					!sum[ih | 6*q>=ih>6*(q-1), deltaQ_UP(ih,tfe,ps)] >=
					!sum[ih | 6*(q+flex_range(tfe))>=ih>6*(q-1)+1, hourly_profiles(ih,profileType_tech(tfe))*activity_balances(tfe,'Electricity',ps)*tech_use(tfe,ps)*flex_comfort(tfe)]
					sum[ih | hoursPer_quarter*q>=ih>hoursPer_quarter*(q-1), deltaQ_UP(ih,tfe,ps)] >=
					sum[ih | hoursPer_quarter*q>=ih>hoursPer_quarter*(q-1)+1, hourly_profiles(ih,profileType_tech(tfe))*activity_balances(tfe,flex_activity(tfe),ps)*tech_use(tfe,ps)]
				}
			}
			Constraint cumulativeUP_dQtfs {
				IndexDomain: (d,tfs,ps);
				Definition: {
					!sum[ih | 24*(d+flex_range(tfs)-1)>=ih>24*(d-1), deltaQ_UP(ih,tfs,ps)] >=
					!sum[ih | 24*(d+flex_range(tfs)-1)>=ih>24*(d-1), hourly_profiles(ih,profileType_tech(tfs))*activity_balances(tfs,'Electricity',ps)*tech_use(tfs,ps)*flex_comfort(tfs)*flex_range(tfs)]
					sum[ih | dayPer_hour(ih)=d, deltaQ_UP(ih,tfs,ps)] >=
					sum[ih | dayPer_hour(ih)=d, hourly_profiles(ih,profileType_tech(tfs))*activity_balances(tfs,flex_activity(tfs),ps)*tech_use(tfs,ps)]
				}
			}
			Constraint cumulativeDW_dQtfs {
				IndexDomain: (d,tfs,ps);
				Definition: {
					!sum[ih | 24*(d+flex_range(tfs)-1)>=ih>24*(d-1), deltaQ_DW(ih,tfs,ps)] <=
					!sum[ih | 24*(d+flex_range(tfs)-1)>=ih>24*(d-1), -hourly_profiles(ih,profileType_tech(tfs))*activity_balances(tfs,'Electricity',ps)*tech_use(tfs,ps)*flex_comfort(tfs)*flex_range(tfs)]
					sum[ih | dayPer_hour(ih)=d, deltaQ_DW(ih,tfs,ps)] <=
					sum[ih | dayPer_hour(ih)=d, -hourly_profiles(ih,profileType_tech(tfs))*activity_balances(tfs,flex_activity(tfs),ps)*tech_use(tfs,ps)]
				}
			}
			Constraint cumulativeDW_dQtfe {
				IndexDomain: (q,tfe,ps);
				Definition: {
					!sum[ih | 6*q>=ih>6*(q-1), deltaQ_DW(ih,tfe,ps)] <=
					!sum[ih | 6*q>=ih>6*(q-1), -hourly_profiles(ih,profileType_tech(tfe))*activity_balances(tfe,'Electricity',ps)*tech_use(tfe,ps)*flex_comfort(tfe)]
					sum[ih | hoursPer_quarter*q>=ih>hoursPer_quarter*(q-1), deltaQ_DW(ih,tfe,ps)] <=
					sum[ih | hoursPer_quarter*q>=ih>hoursPer_quarter*(q-1), -hourly_profiles(ih,profileType_tech(tfe))*activity_balances(tfe,flex_activity(tfe),ps)*tech_use(tfe,ps)]
				}
			}
			Constraint cumulativeS_dQtfb {
				IndexDomain: (h,tfb,ps);
				Definition: deltaQ_S(h,tfb,ps)>=-techStock(tfb,ps)*flex_storage(tfb)*flex_capacity(tfb,ps);
			}
			Constraint cumulativeS_dQtfv {
				IndexDomain: (h,tfv,ps);
				Definition: {
					deltaQ_S(h,tfv,ps)>=-
					(
					flex_storage(tfv)*flex_capacity(tfv,ps)*(techStock(tfv,ps)-tech_use(tfv,ps)*hourly_profiles(h,profileType_EVuse(tfv))/(avg_speed(tfv)*(24/hoursPer_day)))
					+
					tech_use(tfv,ps)*activity_balances(tfv,flex_activity(tfv),ps)
					*sum[ih | (h<ih<=h+avg_journey(tfv)/hoursPer_Day) + (h>=card(h)+1-avg_journey(tfv)/hoursPer_Day)*(1<=ih<h-card(h)+avg_journey(tfv)/hoursPer_Day),
					hourly_profiles(ih,profileType_EVuse(tfv))]
					)
				}
			}
			Constraint cumulativeS_dW {
				IndexDomain: (h,tw,ps);
				Definition: {
					deltaW_S(h,tw,ps)<=techStock(tw,ps)*phs_storage(tw)*GWhtoPJ !(HARDCODED)
				}
			}
			Constraint nonPos_Shed {
				IndexDomain: (h,ts,ps);
				Definition: deltaS_shed(h,ts,ps)<=0;
			}
		}
		DeclarationSection Infra_description {
			Set tech_infra {
				SubsetOf: technologies;
				Index: ti, iti;
			}
			Set tech_infraH {
				SubsetOf: tech_infra;
				Index: ti_h, iti_h;
				Definition: {
					{ti | infra_range(ti)='1 hour [h]'}
				}
			}
			Set tech_infraD {
				SubsetOf: tech_infra;
				Index: ti_d, iti_d;
				Definition: {
					{ti | infra_range(ti)='1 day [d]'}
				}
			}
			Set act_infraH {
				SubsetOf: activities_solve;
				Index: ai_h;
			}
			Set act_infraD {
				SubsetOf: activities_solve;
				Index: ai_d;
			}
			ElementParameter infra_activityOrig {
				IndexDomain: ti;
				Range: activities_original;
			}
			ElementParameter infra_activity {
				IndexDomain: ti;
				Range: activities_solve;
				Definition: actSolvePer_actOrig(infra_activityOrig(ti));
			}
			ElementParameter infra_range {
				IndexDomain: ti;
				Range: range_type;
			}
			ElementParameter nodePer_techInfra {
				IndexDomain: ti;
				Range: nodes;
				Definition: nodePer_act(infra_activity(ti));
			}
			Constraint infraVol_H {
				IndexDomain: (h,ai_h,ps);
				Definition: {
					sum[itb | activity_balances(itb,ai_h,ps)<0, activity_balances(itb,ai_h,ps)*(
					tech_useHourly(h,itb,ps) !Hourly dispatch units
					+tech_useDaily(dayPer_hour(h),itb,ps)/hoursPer_day !Daily dispatch units (asssuming flat daily consumption of electricity)
					!+(deltaB_DW(dayPer_hour(h),itb,ps)-deltaB_UP(dayPer_hour(h),itb,ps))/24 !Gas buffers consumption (asssuming flat hourly consumption of electricity)
					+tech_use(itb,ps)*hourly_profiles(h,profileType_tech(itb))  !Operation of all technologies
					+deltaS_shed(h,itb,ps))] !Shedding
					+sum[tf, (deltaQ_UP(h,tf,ps)+deltaQ_DW(h,tf,ps)*(1-(tf in tech_fStorage)))*dQ_hourly(tf,ai_h)] !Upwards response of flexible technologies
					>=
					-sum[iti_h | infra_activity(iti_h)=ai_h, techStock(iti_h,ps)*cap2act(iti_h)*24/hoursPer_day] !Maximum available rate at which infrastructure capacity allows to perform an activity [UoA/UoR]
				}
				Comment: {
					"! Hourly activities\' infrastructure are constrained by consumption only. This, as all the activities that require 
					hourly constraints are also balanced hourly (i.e. S_h=D_h)"
				}
			}
			Constraint infraVol_D {
				IndexDomain: (d,ai_d,ps);
				Definition: {
					sum[itb | activity_balances(itb,ai_d,ps)<0, activity_balances(itb,ai_d,ps)* !Only account for the demand
					(tech_useDaily(d,itb,ps) !Daily dispatch units
					!+deltaB_DW(d,itb,ps)-deltaB_UP(d,itb,ps) !Gas buffers consumption 
					+sum[ih | dayPer_hour(ih)=d, tech_useHourly(ih,itb,ps) !Hourly dispatch units
					+hourly_profiles(ih,profileType_tech(itb))*
					(tech_use(itb,ps) !Operation of non dispatchable technologies
					+deltaU_CHP(ih,itb,ps) !Operation of flexible CHPs
					+deltaS_shed(ih,itb,ps))])] !Operation of shedding technologies
					+sum[tg, deltaB_UP(d,tg,ps)*dB_daily(tg,ai_d)] !Daily buffer units
					>=
					-sum[iti_d | infra_activity(iti_d)=ai_d, techStock(iti_d,ps)*cap2act(iti_d)] !Maximum available rate at which infrastructure capacity allows to perform an activity [UoA/UoR]
				}
			}
		}
		DeclarationSection Optimization_declaration {
			Set periods_selection {
				SubsetOf: periods;
				Index: pss, ipss;
				Property: ElementsAreLabels;
				OrderBy: pss;
				InitialData: {
					{2050}
				}
			}
			Set BaseConstraints {
				SubsetOf: AllConstraints;
				Definition: {
					data 
					    { balance_activities                                   , balance_activitiesFix                                ,
					      balance_activities_matconv                           , balance_activities_emissionsFix                      ,
					      balance_activities_EmissionTarget                    , capacity_technologies                                ,
					!      balance_activities_EmissionTarget_inclScope3         , balance_activities_EmissionTarget_inclScope3andFuelEx , 
					      emission_targetCum                                   , storageCO2_cumulative                                ,
					      min_techUse_constraint                               , max_techUse_constraint                               ,
					      decomStock                                           , techStock                                            ,
					      actStock_constraints                                 , techStockCap_contraints_mat                          ,
					      minStock_constraints                                 , maxStock_constraints                                 ,
					      actInv_constraints                                   , techInv_constraints                                  ,
					      retrofit_constraint                                  , limit_new_invest                                     ,
					      eco_decom_constraint	                           , eco_decom_max                                        ,
					      balance_activitiesHourly                             , balance_yearlyhourly                                 ,
					      capacity_techHourly                                  , rampingUP_techHourly                                 ,
					      rampingDW_techHourly                                 , deltaB_S                                             ,
					      balance_activitiesDaily                              , balance_yearlyDaily                                  ,
					      capacity_techDaily                                   , balanceY_dB                                          ,
					      capacityUP_dB                                        , capacityDW_dB                                        ,
					      cummulativeS_dB                                      , balanceH_deltaHchp                                   ,
					      balanceD_deltaHchp                                   , balanceW_deltaHchp                                   ,
					      capacityUP_deltaUchp                                 , capacityDW_deltaUchp                                 ,
					      capacityUP_deltaPchp                                 , capacityDW_deltaPchp                                 ,
					      deltaQ_S                                             , deltaQd_UP                                           ,
					      deltaQd_DW                                           , deltaW_S                                             ,
					      balanceH_deltaS                                      , balanceW_deltaS                                      ,
					      capacity_deltaS                                      , sufficiency_deltaS                                   ,
					      balanceQ_deltaQtfe                                   , balanceD_deltaQd                                     ,
					      balanceR_deltaQd                                     , balanceW_deltaQd                                     ,
					      balanceM_deltaQd                                     , balanceS_deltaQd                                     ,
					      balanceB_deltaQd                                     , balanceY_deltaQd                                     ,
					      capacityUP_dQtfe                                     , capacityUP_dQtfs                                     ,
					      capacityUP_dQtfb                                     , capacityUP_dQtfv                                     ,
					      capacityUP_dW                                        , capacityDW_dQtfe                                     ,
					      capacityDW_dQtfs                                     , capacityDW_dQtfb                                     ,
					      capacityDW_dQtfvc                                    , capacityDW_dQtfvg                                    ,
					      capacityDW_dW                                        , cumulativeUP_dQtfe					  ,
					      cumulativeUP_dQtfs				   , cumulativeDW_dQtfs					  ,
					      cumulativeDW_dQtfe				   , cumulativeS_dQtfb 					  ,
					      cumulativeS_dQtfv 				   , cumulativeS_dW					  ,
					      nonPos_Shed                                          , infraVol_H                                           , 
					      infraVol_D      
					      }
				}
			}
			Set ADAPTConstraints {
				SubsetOf: AllConstraints;
				Definition: {
					data 
					    { Adapt_SectoTarget_emi_R          , Adapt_SectoTarget_emi_A          , Adapt_SectoTarget_emi_T          ,
					      Adapt_SectoTarget_emi_I          , Adapt_SectoTarget_emi_E          , Adapt_SectoTarget_emi30_BunkerNav,
					      Adapt_SectoTarget_emi35_BunkerNav, Adapt_SectoTarget_emi40_BunkerNav, Adapt_SectoTarget_emi45_BunkerNav,
					      Adapt_SectoTarget_emi50_BunkerNav, Adapt_SectoTarget_emi30_BunkerAvi, Adapt_SectoTarget_emi35_BunkerAvi,
					      Adapt_SectoTarget_emi40_BunkerAvi, Adapt_SectoTarget_emi45_BunkerAvi, Adapt_SectoTarget_emi50_BunkerAvi,
					      Adapt_RefinProd_2030             , Adapt_RefinProd_2050             , Adapt_FinalEnergy_2030           ,
					      CO2_credits_Avi                  , CO2_credits_Nav                  }
				}
			}
			Set ADAPTbunkerConstraints {
				SubsetOf: AllConstraints;
				Definition: {
					data 
					    { Adapt_SectoTarget_emi_R          , Adapt_SectoTarget_emi_A          , Adapt_SectoTarget_emi_T          ,
					      Adapt_SectoTarget_emi_I          , Adapt_SectoTarget_emi_E          , Adapt_SectoTarget_emi30_BunkerNav,
					      Adapt_SectoTarget_emi35_BunkerNav, Adapt_SectoTarget_emi40_BunkerNav, Adapt_SectoTarget_emi45_BunkerNav,
					      Adapt_SectoTarget_emi50_BunkerNav, Adapt_SectoTarget_emi30_BunkerAvi, Adapt_SectoTarget_emi35_BunkerAvi,
					      Adapt_SectoTarget_emi40_BunkerAvi, Adapt_SectoTarget_emi45_BunkerAvi, Adapt_SectoTarget_emi50_BunkerAvi,
					      Adapt_RefinProd_2030             , Adapt_RefinProd_2050             , Adapt_FinalEnergy_2030           ,
					      CO2_credits_Avi                  , CO2_credits_Nav                  , ESAF_Aviation                        ,
					      SAF_Aviation                         ,
					      H2_credits_Avi                   , SectorTarget_emi_BunkerNav      }
				}
			}
			Set TRANSFORMConstraints {
				SubsetOf: AllConstraints;
				Definition: {
					data{
						! Transform scenario constraints
						Transform_SectoTarget_emi_R, Transform_SectoTarget_emi_A, Transform_SectoTarget_emi_T, Transform_SectoTarget_emi_I, Transform_SectoTarget_emi_E
						, Transform_SectoTarget_emi_BunkerAvi
						, Transform_SectoTarget_emi_BunkerNav
						, Transform_RefinProd_2030
						, Transform_RefinProd_2050
						, Transform_FinalEnergy_2030  
					}
				}
			}
			Set BasewithBunkers {
				SubsetOf: AllConstraints;
				Definition: {
					data 
					    { balance_activities                                   , balance_activitiesFix                                ,
					      balance_activities_matconv                           , balance_activities_emissionsFix                      ,
					      balance_activities_EmissionTarget_inclBunkers                    , capacity_technologies                                ,
					 !     balance_activities_EmissionTarget_inclScope3         , balance_activities_EmissionTarget_inclScope3andFuelEx , 
					      emission_targetCum                                   , storageCO2_cumulative                                ,
					      min_techUse_constraint                               , max_techUse_constraint                               ,
					      decomStock                                           , techStock                                            ,
					      actStock_constraints                                 , techStockCap_contraints_mat                          ,
					      minStock_constraints                                 , maxStock_constraints                                 ,
					      actInv_constraints                                   , techInv_constraints                                  ,
					      retrofit_constraint                                  , limit_new_invest                                     ,
					      eco_decom_constraint	                           , eco_decom_max                                        ,
					      balance_activitiesHourly                             , balance_yearlyhourly                                 ,
					      capacity_techHourly                                  , rampingUP_techHourly                                 ,
					      rampingDW_techHourly                                 , deltaB_S                                             ,
					      balance_activitiesDaily                              , balance_yearlyDaily                                  ,
					      capacity_techDaily                                   , balanceY_dB                                          ,
					      capacityUP_dB                                        , capacityDW_dB                                        ,
					      cummulativeS_dB                                      , balanceH_deltaHchp                                   ,
					      balanceD_deltaHchp                                   , balanceW_deltaHchp                                   ,
					      capacityUP_deltaUchp                                 , capacityDW_deltaUchp                                 ,
					      capacityUP_deltaPchp                                 , capacityDW_deltaPchp                                 ,
					      deltaQ_S                                             , deltaQd_UP                                           ,
					      deltaQd_DW                                           , deltaW_S                                             ,
					      balanceH_deltaS                                      , balanceW_deltaS                                      ,
					      capacity_deltaS                                      , sufficiency_deltaS                                   ,
					      balanceQ_deltaQtfe                                   , balanceD_deltaQd                                     ,
					      balanceR_deltaQd                                     , balanceW_deltaQd                                     ,
					      balanceM_deltaQd                                     , balanceS_deltaQd                                     ,
					      balanceB_deltaQd                                     , balanceY_deltaQd                                     ,
					      capacityUP_dQtfe                                     , capacityUP_dQtfs                                     ,
					      capacityUP_dQtfb                                     , capacityUP_dQtfv                                     ,
					      capacityUP_dW                                        , capacityDW_dQtfe                                     ,
					      capacityDW_dQtfs                                     , capacityDW_dQtfb                                     ,
					      capacityDW_dQtfvc                                    , capacityDW_dQtfvg                                    ,
					      capacityDW_dW                                        , cumulativeUP_dQtfe					  ,
					      cumulativeUP_dQtfs				   , cumulativeDW_dQtfs					  ,
					      cumulativeDW_dQtfe				   , cumulativeS_dQtfb 					  ,
					      cumulativeS_dQtfv 				   , cumulativeS_dW					  ,
					      nonPos_Shed                                          , infraVol_H                                           , 
					      infraVol_D      
					      }
				}
			}
			Set RFNBOConstraints {
				SubsetOf: AllConstraints;
				Definition: {
					data 
					    { CO2_credits_Avi            , CO2_credits_Nav            , eSAF_Aviation                 , SAF_Aviation                  ,
					      H2_credits_Avi             , SectorTarget_emi_BunkerNav, H2_credits_Nav             , RFNBO_industry        ,
					      RFNBO_transport            , H2_credits_transport       , H2_credits_industry        }
				}
			}
			Set LinkingConstraints {
				SubsetOf: AllConstraints;
				Definition: data { EED_FinalEnergy_2030 };
			}
			Set BaseScope3Constraints {
				SubsetOf: AllConstraints;
				Definition: {
					data 
					    { balance_activities                                   , balance_activitiesFix                                ,
					      balance_activities_matconv                           , balance_activities_emissionsFix                      ,
					 !     balance_activities_EmissionTarget                    , 
					 capacity_technologies                                ,
					 !    balance_activities_EmissionTarget_inclScope3         , 
					 balance_activities_EmissionTarget_inclScope3andFuelEx , 
					      emission_targetCum                                   , storageCO2_cumulative                                ,
					      min_techUse_constraint                               , max_techUse_constraint                               ,
					      decomStock                                           , techStock                                            ,
					      actStock_constraints                                 , techStockCap_contraints_mat                          ,
					      minStock_constraints                                 , maxStock_constraints                                 ,
					      actInv_constraints                                   , techInv_constraints                                  ,
					      retrofit_constraint                                  , limit_new_invest                                     ,
					      eco_decom_constraint	                           , eco_decom_max                                        ,
					      balance_activitiesHourly                             , balance_yearlyhourly                                 ,
					      capacity_techHourly                                  , rampingUP_techHourly                                 ,
					      rampingDW_techHourly                                 , deltaB_S                                             ,
					      balance_activitiesDaily                              , balance_yearlyDaily                                  ,
					      capacity_techDaily                                   , balanceY_dB                                          ,
					      capacityUP_dB                                        , capacityDW_dB                                        ,
					      cummulativeS_dB                                      , balanceH_deltaHchp                                   ,
					      balanceD_deltaHchp                                   , balanceW_deltaHchp                                   ,
					      capacityUP_deltaUchp                                 , capacityDW_deltaUchp                                 ,
					      capacityUP_deltaPchp                                 , capacityDW_deltaPchp                                 ,
					      deltaQ_S                                             , deltaQd_UP                                           ,
					      deltaQd_DW                                           , deltaW_S                                             ,
					      balanceH_deltaS                                      , balanceW_deltaS                                      ,
					      capacity_deltaS                                      , sufficiency_deltaS                                   ,
					      balanceQ_deltaQtfe                                   , balanceD_deltaQd                                     ,
					      balanceR_deltaQd                                     , balanceW_deltaQd                                     ,
					      balanceM_deltaQd                                     , balanceS_deltaQd                                     ,
					      balanceB_deltaQd                                     , balanceY_deltaQd                                     ,
					      capacityUP_dQtfe                                     , capacityUP_dQtfs                                     ,
					      capacityUP_dQtfb                                     , capacityUP_dQtfv                                     ,
					      capacityUP_dW                                        , capacityDW_dQtfe                                     ,
					      capacityDW_dQtfs                                     , capacityDW_dQtfb                                     ,
					      capacityDW_dQtfvc                                    , capacityDW_dQtfvg                                    ,
					      capacityDW_dW                                        , cumulativeUP_dQtfe					  ,
					      cumulativeUP_dQtfs				   , cumulativeDW_dQtfs					  ,
					      cumulativeDW_dQtfe				   , cumulativeS_dQtfb 					  ,
					      cumulativeS_dQtfv 				   , cumulativeS_dW					  ,
					      nonPos_Shed                                          , infraVol_H                                           , 
					      infraVol_D      
					      }
				}
			}
			Set activeConstraints {
				SubsetOf: AllConstraints;
				Definition: {
					if ActiveConstraintGroup = 'Base' then
						BaseConstraints
					elseif ActiveConstraintGroup = 'ADAPT' then
						BaseConstraints + ADAPTConstraints
					elseif ActiveConstraintGroup = 'TRANSFORM' then
						BaseConstraints + TRANSFORMConstraints
					elseif ActiveConstraintGroup = 'ADAPT + bunker aviation & navigation policy' then
						BaseConstraints + ADAPTbunkerConstraints
					elseif ActiveConstraintGroup = 'ADAPT with bunkers in single constraint' then
						BasewithBunkers + ADAPTConstraints
					!elseif ActiveConstraintGroup = 'Base + DMI' then
					!	BaseConstraints + DMIConstraints
					!elseif ActiveConstraintGroup = 'Base + DMI without emissions' then
					!	DMIConstraintswithoutEmissions
					elseif ActiveConstraintGroup = 'Base + Bunkers in a single constraint' then
						BasewithBunkers
					elseif ActiveConstraintGroup = 'Base + RFNBO targets' then
						BaseConstraints + RFNBOConstraints
					elseif ActiveConstraintGroup = 'Linking scenario' then
						BaseConstraints + LinkingConstraints
						!BaseConstraints + RFNBOConstraints + LinkingConstraints
					elseif ActiveConstraintGroup = 'Linking scenario + Scope 3' then
						BaseScope3Constraints + LinkingConstraints
						!BaseScope3Constraints + RFNBOConstraints + LinkingConstraints
					endif;
				}
			}
			Set activeVariables {
				SubsetOf: AllVariables;
				Definition: {
					data 
					    { tech_use           , cap_investments    , retrofitting       , eco_decommisioning , decomStock         , techStock          ,
					      tech_useHourly     , tech_useDaily      , deltaB_UP          , deltaB_DW          , deltaB_S           , deltaU_CHP         ,
					      deltaP_CHP         , deltaQ_UP          , deltaQ_DW          , deltaQ_S           , deltaQd_UP         , deltaQd_DW         ,
					      deltaS_shed        , deltaW_UP          , deltaW_S           , totalCosts }
				}
			}
			Variable totalCosts {
				Range: free;
				Definition: {
					!Objective function, revised from previous versions
					sum[ps, 
						social_discount_factor(ps) *							!social discount rate assigns weights to different periods
						(
							! CAPEX
							+ sum[(t,jp), InvMat_lifeTime(t,jp,ps)*					!lifetime matrix
							(cap_investments(t,jp)*inv_cost(t,jp)*CRF(t))]				!New investments
					
							+ sum[(t,jp), InvMat_lifeTime(t,jp,ps)*(
							sum[it, retrofitting(it,t,ps) * CRF(t) * (retro_cost(it,t) + p_epsilon)] !Retrofitting costs (based on Excel database input). Epsilon set to 0 to save memory, can be removed later if not needed.
							)]
							- sum[(t), (eco_decommisioning(t,ps) - eco_decommisioning(t,ps-1)) * Salvage_value(t) * inv_cost(t,ps) * CRF(t)]  ! Recovered salvage value
					
							! FOM
							+ sum[(t), techStock(t,ps) * fom_cost(t,ps)] !Fixed costs
							! VOM
							+ sum[t, tech_use(t,ps) * (vom_cost(t,ps) + p_epsilon)] !Variable costs (including fuel costs)
							+ sum[(h,thin), tech_useHourly(h,thin,ps) * vom_interconnected_hourly(h,thin,ps)]!Electricity costs of interconnected nodes
							+ sum[(h,t), (deltaU_CHP(h,t,ps) + deltaS_shed(h,t,ps)) * vom_cost(t,ps)] !Deviations in tech use due to flexibility
							!CO2 tax (set to 0 in Emi02_01 if not included)
							+ sum[t, tech_use(t,ps)*CO2_ETS_costs(t,ps)]
							!Misc
							+ p_epsilon * sum[(h,tf), deltaQ_DW(h,tf,ps) - deltaQ_UP(h,tf,ps)] !To avoid multiple solutions
							+ p_epsilon * sum[(h,ts), deltaS_shed(h,ts,ps)] !To avoid multiple solutions
					
						)
					]
				}
			}
			MathematicalProgram LeastCostPlanning {
				Objective: totalCosts;
				Direction: minimize;
				Constraints: activeConstraints;
				Variables: activeVariables;
				Type: LP;
			}
			MathematicalProgram LeastCostPlanning_Violations {
				Objective: totalCosts;
				Direction: minimize;
				Constraints: activeConstraints;
				Variables: activeVariables;
				Type: LP;
				ViolationPenalty: ViolationLevels;
			}
			Parameter ViolationLevels {
				IndexDomain: IndexVariablesConstraints;
				Definition: {
					data{
						'tech_use' : 10000 ,
						'techStock' : 10000  ,
						'tech_useHourly' : 100 ,
						'tech_useDaily' : 500 ,
						'balance_activitiesHourly' : 101 
					};
				}
			}
			Parameter p_epsilon {
				Definition: 0;
			}
			Parameter PtotalCosts {
				Definition: {
						sum[ps, 
						social_discount_factor(ps)*
						period_weight(ps)*modelled_transition_interval*					!Accounts for the fact that only single years of costs are included rather than totals. Period weight defines share of period in total interval, transition interval is the length of the scenario time horizon
						(
							! CAPEX
							+sum[(t,jp), InvMat_lifeTime(t,jp,ps)*						!lifetime matrix
							(cap_investments(t,jp)*inv_cost(t,jp)*CRF(t)				!New investments
							+sum[(it,jt), retrofitting(it,jt,ps)*CRF(jt)*(retro_cost(it,jt)+p_epsilon)] !Retrofitting costs (based on Excel database input)
							!-eco_decommisioning(t,jp)*(1-salvage_value(t))*inv_cost(t,jp)*annuity_fac(t) 	!Salvage value at end of lifetime (temporarily removed, should be modelled with the possibility to consider a positive cost, a zero, or a "negative" cost representing recovered value)
							)]
							! FOM
							+sum[(t), techStock(t,ps)*fom_cost(t,ps)] !Fixed costs
							! VOM
							+sum[t, tech_use(t,ps)*(vom_cost(t,ps)+p_epsilon)] !Variable costs (including fuel costs)
							+sum[(h,thin), tech_useHourly(h,thin,ps)*(vom_interconnected_hourly(h,thin,ps)+1e-6)]!Electricity costs of interconnected nodes
							+sum[(h,t), (deltaU_CHP(h,t,ps)+deltaS_shed(h,t,ps))*vom_cost(t,ps)] !Deviations in tech use due to flexibility
							!Misc
							+1e-6*sum[(h,tf), deltaQ_DW(h,tf,ps)-deltaQ_UP(h,tf,ps)] !To avoid multiple solutions
							+1e-6*sum[(h,ts), deltaS_shed(h,ts,ps)] !To avoid multiple solutions
					
						)
					]
				}
			}
			Parameter capCosts {
				Definition: {
						sum[ps, 
						social_discount_factor(ps)*
						period_weight(ps)*modelled_transition_interval*					!Accounts for the fact that only single years of costs are included rather than totals. Period weight defines share of period in total interval, transition interval is the length of the scenario time horizon
						(
							! CAPEX
							+sum[(t,jp), InvMat_lifeTime(t,jp,ps)*						!lifetime matrix
							(cap_investments(t,jp)*inv_cost(t,jp)*CRF(t)				!New investments
							+sum[(it,jt), retrofitting(it,jt,ps)*CRF(jt)*(retro_cost(it,jt)+p_epsilon)] !Retrofitting costs (based on Excel database input)
							!-eco_decommisioning(t,jp)*(1-salvage_value(t))*inv_cost(t,jp)*annuity_fac(t) 	!Salvage value at end of lifetime (temporarily removed, should be modelled with the possibility to consider a positive cost, a zero, or a "negative" cost representing recovered value)
							)]
						)
					]
				}
			}
			Parameter fomCosts {
				Definition: {
						sum[ps, 
						social_discount_factor(ps)*
						period_weight(ps)*modelled_transition_interval*					!Accounts for the fact that only single years of costs are included rather than totals. Period weight defines share of period in total interval, transition interval is the length of the scenario time horizon
						(
							! FOM
							+sum[(t), techStock(t,ps)*fom_cost(t,ps)] !Fixed costs
					
						)
					]
				}
			}
			Parameter vomCosts {
				Definition: {
						sum[ps, 
						social_discount_factor(ps)*
						period_weight(ps)*modelled_transition_interval*					!Accounts for the fact that only single years of costs are included rather than totals. Period weight defines share of period in total interval, transition interval is the length of the scenario time horizon
						(
							! VOM
							+sum[t, tech_use(t,ps)*(vom_cost(t,ps)+1e-6)] !Variable costs (including fuel costs)
							+sum[(h,thin), tech_useHourly(h,thin,ps)*(vom_interconnected_hourly(h,thin,ps)+1e-6)]!Electricity costs of interconnected nodes
							+sum[(h,t), (deltaU_CHP(h,t,ps)+deltaS_shed(h,t,ps))*vom_cost(t,ps)] !Deviations in tech use due to flexibility
							!Misc
							+1e-6*sum[(h,tf), deltaQ_DW(h,tf,ps)-deltaQ_UP(h,tf,ps)] !To avoid multiple solutions
							+1e-6*sum[(h,ts), deltaS_shed(h,ts,ps)] !To avoid multiple solutions
					
						)
					]
				}
			}
		}
	}
	Section Model_run {
		Procedure CheckMemoryMPs {
			Body: {
				for IndexGeneratedMathematicalPrograms do
					MemoryUseMPs(IndexGeneratedMathematicalPrograms) := GMP::Instance::GetMemoryUsed(IndexGeneratedMathematicalPrograms);
					endfor;
			}
		}
		Procedure TechStock_roundUP {
			Body: {
				!Get rid of negative stocks and maximum stocks
				techStock(t,pss):=max(techStock(t,pss),0);
				techStock(t,pss):=min(techStock(t,pss),techStock_max(t,pss));
				
				!!Option 1. Just add a bit of stock to all natinal technologies
				!techStock(tn,pss):=techStock(tn,pss)+(techStock(tn,pss)>0)*1e-7;
				
				
				!Option 2. Compute to ensure feasibilities
				!Check that the Stocks are sufficient to meet demand up to 1e-9
				
				!!Via the loop
				!for (ipss in periods_selection) do
				!	for (iad in activities_driver) do
				!		if (activityScope_act(iad)<>'External') then;
				!			if(sum[itb | activityPer_tech(itb)=iad, techStock(itb,ipss)*cap2act(itb)]<activities_netVolumes(iad,ipss)) then;
				!				techStock(tb,ipss):=techStock(tb,ipss)+
				!				(activityPer_tech(tb)=iad)*(techStock(tb,ipss)=max(itb | activityPer_tech(itb)=iad, techStock(itb,ipss)))
				!				*(activities_netVolumes(iad,ipss)-sum[jtb | activityPer_tech(jtb)=iad, techStock(jtb,ipss)*cap2act(jtb)])
				!				/cap2act(tb);
				!			endif;
				!		endif;
				!	endfor;
				!endfor;
				!
				!techStock(tn,pss):=techStock(tn,pss)+(activityType_act(activityPer_tech(tn))='Energy')*(techStock(tn,pss)>0)*1e-7;
				
				
				!Without loop
				techStock(t,pss):=techStock(t,pss)
				+(activityType_act(activityPer_tech(t))='Driver') !If technology meets a driver activity
				*(techStock(t,pss)=max[it | activityPer_tech(it)=activityPer_tech(t), techStock(it,pss)]) !If technology has the maximum stock of technologies meeting that activity
				*(sum[it | activityPer_tech(it)=activityPer_tech(t), techStock(it,pss)*cap2act(it)]<activities_netVolumes(activityPer_tech(t),pss)) !If the activity of that technology is violating the constraint... not necessary, but to prevent
				*(activities_netVolumes(activityPer_tech(t),pss)-sum[it | activityPer_tech(it)=activityPer_tech(t), techStock(it,pss)*cap2act(it)])/cap2act(t) !The necessary stock to make the constraint feasible
				+(activityType_act(activityPer_tech(t))='Energy')*((techStock_max(t,pss)-techStock(t,pss))>1e-7)*1e-7 !Add a bit of stock to energy technologies
				+(activityType_act(activityPer_tech(t))='Emission')*(techStock(t,pss)>0)*((techStock_max(t,pss)-techStock(t,pss))>=1e-8)*(techStock_max(t,pss)-techStock(t,pss)) !Add a bit of stock to emission technologies
				;
			}
		}
		Procedure DeleteAllGMPs {
			Body: {
				!First remove all the solversessions that currently might be active
				while card(IndexSolverSessions) do gmp::Instance::DeleteSolverSession(first(IndexSolverSessions)) ; endwhile ;
				!Now remove any of the GMPs that might still be present
				while card(IndexGeneratedMathematicalPrograms) do gmp::Instance::Delete(first(IndexGeneratedMathematicalPrograms)) ; endwhile ;
			}
		}
		DeclarationSection GMP_formulation {
			Set ScenarioVariants {
				SubsetOf: InputFilesSetBatch;
				Index: SV, SV1;
			}
			ElementParameter FinishedSolSes {
				Range: AllSolverSessions;
			}
			ElementParameter GMP_planning {
				Range: AllGeneratedMathematicalPrograms;
			}
			StringParameter GMP_selection;
			ElementParameter BatchSolve_GMP {
				IndexDomain: SV;
				Range: AllGeneratedMathematicalPrograms;
			}
			ElementParameter BatchSolve_SolSes {
				IndexDomain: SV;
				Range: AllSolverSessions;
			}
			Parameter MaxParallelWorkers {
				InitialData: 4;
			}
			Parameter ActiveParallelWorkers;
			Parameter ActiveBufferGMP;
		}
		DeclarationSection Mathematical_Program_Details {
			Quantity SI_Time_Duration {
				BaseUnit: s;
				Conversions: minute->s : #-># * 60;
				Comment: "Expresses the value for the duration of periods.";
			}
			Set FixedTunningOptions {
				SubsetOf: AllOptions;
			}
			Set MathProgramDetails {
				Index: mps;
				Definition: {
					{
					'Solver',
					'Type of the Mathematical Program',
					'Solution Energy Units',
					'Solution Money Units',
					'GMP',
					'Number of Constraints',
					'Number of Variables',
					'Number of Nonzeros',
					'Number of Iterations',
					'Generation Time',
					'Solving Time',
					'Elapsed Time',
					'Used Memory',
					'Peak Memory',
					'Objective Function Value',
					'Date of Run',
					'Solver Status',
					'Mathematical Program Status',
					'Total Run Time',
					'Database Version',
					'Model Version',
					'Hours per day'
					}
				}
			}
			Set run_number {
				SubsetOf: Integers;
				Index: rn, irn;
				Property: ElementsAreNumerical;
				Definition: {
					{h | h <= 100}
				}
			}
			ElementParameter run_numberState {
				Range: run_number;
			}
			ElementParameter ProgressWindow {
				Range: AllProgressCategories;
			}
			ElementParameter AY_GMP {
				IndexDomain: pss;
				Range: AllGeneratedMathematicalPrograms;
			}
			ElementParameter pres_AY_GMP {
				IndexDomain: pss;
				Range: AllGeneratedMathematicalPrograms;
			}
			Parameter ThreadLimiter;
			ElementParameter AY_SolverSession {
				IndexDomain: pss;
				Range: AllSolverSessions;
			}
			StringParameter MathProgramParameters {
				IndexDomain: (mps,rn);
			}
			StringParameter ReferenceTime;
			StringParameter ReferenceTime_IYP;
			StringParameter ReferenceTime_Generation;
			Parameter MemoryUseMPs {
				IndexDomain: IndexGeneratedMathematicalPrograms;
			}
		}
		DeclarationSection Solver_Settings_Declaration {
			StringParameter solver_selection {
				Definition: "GUROBI 9.0";
			}
			StringParameter StringCPU {
				Definition: {
					EnvironmentGetString("NUMBER_OF_PROCESSORS", StringCPU);
				}
			}
			Parameter NumCPU {
				Range: integer;
				Definition: {
					val(StringCPU);
				}
			}
			Parameter techStock_tolerance {
				InitialData: 1e-4;
			}
			Parameter Feasibility_tolerance {
				InitialData: 1e-7;
			}
			Parameter Optimality_tolerance {
				InitialData: 1e-7;
			}
			Parameter BarrierConvergence_tolerance {
				InitialData: 1e-7;
			}
		}
		Procedure GMP_details {
			Arguments: run_step,GMP_name,time_stamp;
			Body: {
				MathProgramParameters('Solver',run_step) := GMP::Instance::GetSolver(GMP_name);
				MathProgramParameters('Type of the Mathematical Program',run_step) := GMP::Instance::GetMathematicalProgrammingType(GMP_name) ;
				MathProgramParameters('Solution Energy Units',run_step) := "PJ" ;
				MathProgramParameters('Solution Money Units',run_step) := "M€" ;
				MathProgramParameters('Hours per day',run_step) := hoursPer_day;
				MathProgramParameters('GMP',run_step) := GMP_name ;
				MathProgramParameters('Number of Constraints',run_step) := GMP::Instance::GetNumberOfRows(GMP_name);
				MathProgramParameters('Number of Variables',run_step) := GMP::Instance::GetNumberOfColumns(GMP_name);
				MathProgramParameters('Number of Nonzeros',run_step) := GMP::Instance::GetNumberOfNonzeros(GMP_name);
				MathProgramParameters('Number of Iterations',run_step) := GMP::Solution::GetIterationsUsed(GMP_name,1);
				MathProgramParameters('Solving Time',run_step) := round(GMP::Solution::GetTimeUsed(GMP_name,1)/6000,1) + " [min]";
				MathProgramParameters('Elapsed Time',run_numberState) := round(CurrentToMoment([minute],time_stamp),1) + " [min]" ;
				MathProgramParameters('Used Memory',run_step) := round(MemoryInUse(),1) + " [MB]";
				MathProgramParameters('Peak Memory',run_step) := round(GMP::Solution::GetMemoryUsed(GMP_name,1),1) + " [MB]";
				MathProgramParameters('Objective Function Value',run_step) := round(GMP::Solution::GetObjective(GMP_name,1),2) + " [" + "M€" + "]";
				MathProgramParameters('Date of Run',run_numberState) := time_stamp;
				MathProgramParameters('Solver Status',run_step) := GMP::Solution::GetSolverStatus(GMP_name,1);
				MathProgramParameters('Mathematical Program Status',run_step) := GMP::Solution::GetProgramStatus(GMP_name,1);
			}
			ElementParameter run_step {
				Range: run_number;
			}
			ElementParameter GMP_name {
				Range: AllGeneratedMathematicalPrograms;
			}
			StringParameter time_stamp;
		}
		Procedure DefineSolverSettings {
			Body: {
				!Procedure to define the required AIMMS and solver settings
				option linear_presolve := 'Off';
				option Remove_Doubletons := 'Always';
				option scale_model := 'Off';
				option accept_basis := 1 ;
				option always_store_marginals := 1 ;
				option display_infeasibility_analysis := 1 ;
				option infeasibility_finder := on ;
				option listing_number_precision := 20 ;
				option remove_doubletons := 'always' ;
				option rounding_compatibility := 'Aimms_3_7' ;
				option solver_listing_messages := 4 ;
				option Enhanced_Long_Run_Responsiveness := 1 ;
				option progress_time_interval := 10 ;
				
				! Set options to default
				option "GUROBI 12.0".Method := 2 ;
				option "GUROBI 12.0".Numeric_focus := 2 ; !2 default
				option "GUROBI 12.0".Log_to_console := 1 ;
				option "GUROBI 12.0".Output_file := 1 ;
				option "GUROBI 12.0".Presolve := -1 ; !-1 default
				option "GUROBI 12.0".Presolve_aggregation := 1 ;
				option "GUROBI 12.0".Presolve_aggregation_fill := -1 ;
				option "GUROBI 12.0".Presolve_dual := -1 ;
				option "GUROBI 12.0".Presolve_passes := -1 ;
				option "GUROBI 12.0".ScaleFlag := -1 ; !-1 default
				!option "GUROBI 12.0".BarHomogenous := 1; !not default to include this, testing performance
				!option "GUROBI 12.0".DualReduction :=0; !not default to include this, useful for numerical stability debugging
				!option "GUROBI 12.0".Quad :=1; !NOT default, for severe numerical issues
				!option "GUROBI 12.0".DisplayInterval := 1; ! not default, used for debugging
				
				! For Gurobi 12.0
				if hoursPer_day >= 12 then 
					! Options for 24h runs
					option "GUROBI 12.0".Barrier_crossover := 0;
					if (SolveMethodChoice = 'Barrier') then 
						option "GUROBI 12.0".Method := 2 ;
					elseif (SolveMethodChoice = 'Concurrent') then
						option "GUROBI 12.0".Method := 3 ;
					endif;
					option "GUROBI 12.0".Numeric_focus := 3 ; !2 defai;t
					option "GUROBI 12.0".Log_to_console := 1 ;
					option "GUROBI 12.0".Output_file := 1 ;
					option "GUROBI 12.0".Presolve := 1 ; !1 default (conservative)
					option "GUROBI 12.0".Presolve_aggregation := 2 ;
					option "GUROBI 12.0".Presolve_aggregation_fill := 5 ;
					option "GUROBI 12.0".Presolve_dual := 0 ;
					option "GUROBI 12.0".Presolve_passes := 2 ;
					option "GUROBI 12.0".Presolve_row_reduction := 1 ;
				!	option "GUROBI 12.0".BarHomogenous := 1; !not default to include this, testing performance
				elseif (6 <= hoursPer_day <= 8) then
					!Options for 8h runs
					option "GUROBI 12.0".Barrier_crossover := 0; !-1 default (automatic)
					if (SolveMethodChoice = 'Barrier') then 
						option "GUROBI 12.0".Method := 2 ;
					elseif (SolveMethodChoice = 'Concurrent') then
						option "GUROBI 12.0".Method := 3 ;
					endif;
					option "GUROBI 12.0".Log_to_console := 1 ;
					option "GUROBI 12.0".Output_file := 1 ;
					option "GUROBI 12.0".Presolve_row_reduction := 0 ;
				else
					option "GUROBI 12.0".Barrier_crossover := 0; 
					if (SolveMethodChoice = 'Barrier') then 
						option "GUROBI 12.0".Method := 2 ;
					elseif (SolveMethodChoice = 'Concurrent') then
						option "GUROBI 12.0".Method := 3 ;
					endif;
					option "GUROBI 12.0".Log_to_console := 1 ;
					option "GUROBI 12.0".Output_file := 1 ;
					option "GUROBI 12.0".Presolve_row_reduction := 0 ;
				
				endif;
				
				
				!Apply desired settings for the each solver
				! For CPLEX 22.1
					if (SolveMethodChoice = 'Barrier') then
						option 'CPLEX 22.1'.LP_Method := 'Barrier';
					elseif (SolveMethodChoice = 'Concurrent') then
						option 'CPLEX 22.1'.LP_Method := 'Concurrent';
					endif;
					option 'CPLEX 22.1'.Global_thread_limit := CPUCores;
				!	option 'CPLEX 22.1'.Barrier_progress_solution := 1;
					option 'CPLEX 22.1'.Barrier_convergence_tolerance := BarrierConvergence_tolerance;
					option 'CPLEX 22.1'.Solution_type := 'nonbasic';	
					option 'CPLEX 22.1'.feasibility := Feasibility_tolerance;
					option 'CPLEX 22.1'.optimality := Optimality_tolerance;
					option 'CPLEX 22.1'.parallel_mode := 'Opportunistic';
				!	option 'CPLEX 22.1'.preprocessing_reduction_types := 'No primal and dual reductions';
					option 'CPLEX 22.1'.presolve_pass_dual := 'Off';
					option 'CPLEX 22.1'.barrier_start_algorithm := 'Primal average, estimate dual';
					if (crossover_enabling = 'yes') then
						option 'CPLEX 22.1'.Solution_type := 'basic';
				!		option 'CPLEX 22.1'.Barrier_crossover_algorithm := 'Automatic';
				!		option 'CPLEX 22.1'.presolve_pass_dual := 'On';
				!		option 'CPLEX 22.1'.preprocessing_reduction_types := 'Both primal and dual reductions';
					endif;
				
				StatusMessage("Solver options were succesfully updated");
			}
			Comment: "Make sure the solver version here matches with your installed solver version.";
		}
		Section Tuning {
			DeclarationSection TuneParms {
				Set FixedOptions {
					SubsetOf: AllOptions;
				}
			}
			Procedure TuningProcedure {
				Body: {
					! Start the profiler
					ProfilerStart() ;  
					
					!Assign the periods to solve
					periods_solve := periods_selection;
					
					!First remove all the solversessions that currently might be active
					DeleteAllGMPs;
					
					option linear_presolve := 'Off';
					option Remove_Doubletons := 'Always';
					option scale_model := 'Off';
					option accept_basis := 1 ;
					option always_store_marginals := 1 ;
					option display_infeasibility_analysis := 1 ;
					option infeasibility_finder := on ;
					option listing_number_precision := 20 ;
					option remove_doubletons := 'always' ;
					option rounding_compatibility := 'Aimms_3_7' ;
					option solver_listing_messages := 4 ;
					option Enhanced_Long_Run_Responsiveness := 1 ;
					option progress_time_interval := 10 ;
					
					! Set options to default
					option "GUROBI 12.0".Method := 2 ;
					option "GUROBI 12.0".Numeric_focus := 0 ;
					option "GUROBI 12.0".Log_to_console := 1 ;
					option "GUROBI 12.0".Output_file := 1 ;
					option "GUROBI 12.0".Presolve := -1 ;
					option "GUROBI 12.0".Presolve_aggregation := 1 ;
					option "GUROBI 12.0".Presolve_aggregation_fill := -1 ;
					option "GUROBI 12.0".Presolve_dual := -1 ;
					option "GUROBI 12.0".Presolve_passes := -1 ;
					option "GUROBI 12.0".Scale := -1 ;
					
					option "GUROBI 12.0".Barrier_crossover := 0;
					option "GUROBI 12.0".Method := 2 ;
					
					GMP_planning := GMP::Instance::Generate(LeastCostPlanning);
					GMP::Tuning::TuneSingleGMP( GMP_planning, FixedOptions, 1);
				}
			}
		}
		Section SolveProcedures {
			Procedure SolveTransition {
				Body: {
					! Start the profiler
					ProfilerStart() ;  
					
					!Delete all identifiers
					cleanup AllIdentifiers;
					
					!Declare the start time of Run for calculating Elapsed time
					ReferenceTime := CurrentToString("%c%y-%m-%d %H:%M:%S");
					
					!Declare folder names for saving output files
					if(OutputFolderValue = 'automatic') then
						OutputFolderName := CurrentToString("%c%y-%m-%d_%H.%M");
					endif;
					
					!Assign the periods to solve
					periods_solve := periods_selection;
					
					!First remove all the solversessions that currently might be active
					DeleteAllGMPs;
					
					! Set solver options
					DefineSolverSettings;
					
					!Solve the GMP
					!============================================================= Start of the Solve procedure =============================================================
					! Set the running state initial value
					run_numberState:=1;
					
					! Report database location and reset math program parameters reporting
					empty MathProgramParameters;
					MathProgramParameters('Database Version',1) := DataReadingLocation ;
					
					! Creating stopwatch for the generation time
					ReferenceTime_Generation := CurrentToString("%c%y-%m-%d %H:%M:%S");
					
					StatusMessage("ST... Generating the transition GMP for periods: " + SetAsString(periods_solve));
					! Create a solver session for GenMathProgram, which will create an element in the set AllSolverSessions, and assign the newly created element to the element parameter session.
					if ShowViolations = 'Yes' then
						GMP_planning := GMP::Instance::Generate(LeastCostPlanning_Violations);
					else
						GMP_planning := GMP::Instance::Generate(LeastCostPlanning);
					endif;
					
					for IndexGeneratedMathematicalPrograms do
						MemoryUseMPs(IndexGeneratedMathematicalPrograms) := GMP::Instance::GetMemoryUsed(IndexGeneratedMathematicalPrograms);
						endfor;
					
					if not GMP_planning then raise warning "Could not generate the GMP!"; AIMMSWav(Failed); return; endif;
					
					MathProgramParameters('Generation Time',run_numberState) := round(CurrentToMoment([minute],ReferenceTime_Generation),1);
					
					!Set solver
					GMP::Instance::SetSolver(GMP_planning,SolverChoice);
					StatusMessage("ST... Solving the transition GMP for periods: " + SetAsString(periods_solve) );
					
					! Solve the GMP
					GMP::Instance::Solve(GMP_planning ) ;
					
					! Get Progress window parameters for reporting purposes
					GMP_details(run_numberState,GMP_planning,ReferenceTime);
					
					StatusMessage("ST... Solving the transition GMP is Finished!");
					!============================================================= End of the Solve procedure =============================================================
					
					run_numberState:=run_numberState+1;
					
					Ptech_use(tb,pss):=tech_use(tb,pss);
					Ptech_useHourly(h,th,pss):=tech_useHourly(h,th,pss);
					Ptech_useDaily(d,td,pss):=tech_useDaily(d,td,pss);
					PdeltaQ_UP(h,tf,pss):=deltaQ_UP(h,tf,pss);
					PdeltaQ_DW(h,tf,pss):=deltaQ_DW(h,tf,pss);
					PdeltaQ_S(h,tfb,pss):=deltaQ_S(h,tfb,pss);
					PdeltaQd_UP(d,tfl,pss):=deltaQd_UP(d,tfl,pss);
					PdeltaQd_DW(d,tfl,pss):=deltaQd_DW(d,tfl,pss);
					PdeltaU_CHP(h,tk,pss):=deltaU_CHP(h,tk,pss);
					PdeltaB_UP(d,tg,pss):=deltaB_UP(d,tg,pss);
					PdeltaB_DW(d,tg,pss):=deltaB_DW(d,tg,pss);
					PdeltaB_S(d,tg,pss):=deltaB_S(d,tg,pss);
					PdeltaP_CHP(h,tk,pss):=deltaP_CHP(h,tk,pss);
					PdeltaS_shed(h,ts,pss):=deltaS_shed(h,ts,pss);
					Pcap_investments(t,pss):=cap_investments(t,pss);
					Pretrofitting(it,jt,pss):=retrofitting(it,jt,pss);
					Peco_decommisioning(t,pss):=eco_decommisioning(t,pss);
					PdecomStock(t,pss):=decomStock(t,pss);
					PtechStock(t,pss):=techStock(t,pss);
					StechStock(t,pss):=techStock(t,pss);
					Ptotal_costs:=totalCosts;
					
					if ShowViolations = 'Yes' then ViolationFinder; endif;
					
					if GMP::Solution::GetProgramStatus(GMP_planning,1) = 'Optimal' then
						!Extract the prices
						yearly_prices(as,p):=balance_activities(as,p).ShadowPrice;
						yearly_prices(as,pss):=yearly_prices(as,pss)/social_discount_factor(pss);
						Pyearly_prices(as,pss) := yearly_prices(as,pss); 
						CO2_prices(acf,p):= balance_activities_emissionsFix(acf,p).ShadowPrice;
						CO2_prices(acf,pss):= CO2_prices(acf,pss)/social_discount_factor(pss);
						PCO2_prices(acf,pss) := CO2_prices(acf,pss);
						CO2_price_single(n,p) := balance_activities_emissiontarget(n,p).ShadowPrice;
						CO2_price_single(n,pss) := CO2_price_single(n,pss)/social_discount_factor(pss);
					
						if (HourlyReportValue = 'yes') then
							hourly_prices(h,ah,p):=balance_activitiesHourly(h,ah,p).ShadowPrice;
							hourly_prices(h,ah,pss):=hourly_prices(h,ah,pss)/social_discount_factor(pss);
							daily_prices(d,ad,p):=balance_activitiesDaily(d,ad,p).ShadowPrice;
							daily_prices(d,ad,pss):=daily_prices(d,ad,pss)/social_discount_factor(pss);
						endif;
					
						!K_emission_constraints_basic(n,ps):=balance_activities_emissionTarget(n,ps).basic;
						!K_emission_constraints_inclScope3_basic(n,ps):=balance_activities_emissionTarget_inclScope3(n,ps).basic;
					
						! Write model version
						MathProgramParameters('Model Version',1) := project_name;
					
						! Create a directory for Output files
						if (DirectoryExists("Output/"+OutputFolderName) = 0) then DirectoryCreate("Output/"+OutputFolderName); endif;
					
						!Save the data file
						StatusMessage("Copying the input datafile ..." );
						FileCopy(DataReadingLocation,"Output/"+OutputFolderName+"/"+FindReplaceStrings(DataReadingLocation,"data\\",""));
					
						!Save the case file
						if (SaveCaseValue = 'yes') then
							StatusMessage("Saving the temp Case as a datafile ..." );
							CaseFileSave("Output/"+OutputFolderName+"/"+OutputFolderName+"_temp.data",AllIdentifiers);
						endif;
					
						!Round the post processing routines before saving and writing the data.
						EnergyCosts_calculator;
						PostProcessParameters;
						RoundParameters;
					
						!Save the case file
						if (SaveCaseValue = 'yes') then
							StatusMessage("Saving the Case as a datafile ..." );
							CaseFileSave("Output/"+OutputFolderName+"/"+OutputFolderName+".data",AllIdentifiers);
							FileDelete("Output/"+OutputFolderName+"/"+OutputFolderName+"_temp.data");
						endif;
					
						! Calculate the elapsed time for reporting purposes
						MathProgramParameters('Total Run Time',1) := round(CurrentToMoment([minute],ReferenceTime),2) + " [min]";
					
						!Write the output of the model
						StatusMessage("ST... Writing the Outputs ..." );
						runDataWritingTransition;
					
					
						!print constraint listing
						!GMP::Solution::RetrievefromModel(GMP_planning,1);
						!GMP::Solution::ConstraintListing(GMP_planning,1,"Output/"+OutputFolderName+"/"+OutputFolderName+"ConstraintListing.txt");
					
						!Play the alarm
						AIMMSWav(Finalized);
					
						StatusMessage("Solve transition is successfully finished!" );
					else
						! Calculate the elapsed time for reporting purposes
						MathProgramParameters('Total Run Time',1) := round(CurrentToMoment([minute],ReferenceTime),2) + " [min]";
						!Play the alarm
						AIMMSWav(Failed);
						StatusMessage("Error or no solution" );
					endif;
				}
			}
			Procedure SequentialBatchSolve {
				Body: {
					! Start the profiler
					ProfilerStart() ;  
					
					SBS_counter := 0;
					for (ifs in InputFilesSelection) do
						SBS_counter := SBS_counter + 1;
					
						DialogProgress("Batch Solving: " + ifs + ' | ' + SBS_counter + " out of " + SBS_length,Floor(100*SBS_counter/SBS_length));
					
						!Delete all identifyiers
						cleanup AllIdentifiers;
					
						DataReadingLocation := ifs;
						runDataReading;
					
						!Declare the start time of Run for calculating Elapsed time
						ReferenceTime := CurrentToString("%c%y-%m-%d %H:%M:%S");
					
						!Declare folder names for saving output files
						if (OutputFolderValue = 'automatic') then
							OutputFolderName := FindReplaceStrings(ifs,"data\\","") - ".xlsx" ;
						elseif (OutputFolderValue = 'custom') then
							OutputFolderName := OutputFolderPrefix + "_"  + FindReplaceStrings(ifs,"data\\","") - ".xlsx" ;
						endif;
					
						!Assign the periods to solve
						periods_solve := periods_selection;
					
						! Set solver options
						DefineSolverSettings;
					
						!Solve the GMP
						!============================================================= Start of the Solve procedure =============================================================
						! Set the running state initial value
						run_numberState:=1;
					
						! Report database location and reset math program parameters reporting
						empty MathProgramParameters;
						MathProgramParameters('Database Version',1) := FindReplaceStrings(DataReadingLocation,"data\\","") ;
					
						! Creating stopwatch for the generation time
						ReferenceTime_Generation := CurrentToString("%c%y-%m-%d %H:%M:%S");
					
						StatusMessage(SBS_counter + "/" + SBS_length + "  | Generating the transition GMP for periods: " + SetAsString(periods_solve) + ' | ' + ifs);
						! Create a solver session for GenMathProgram, which will create an element in the set AllSolverSessions, and assign the newly created element to the element parameter session.
						GMP_planning := GMP::Instance::Generate(LeastCostPlanning);
						if not GMP_planning then raise warning "Could not generate the GMP " + FindReplaceStrings(ifs,"data\\",""); AIMMSWav(Failed); SKIP; endif;
					
						MathProgramParameters('Generation Time',run_numberState) := round(CurrentToMoment([minute],ReferenceTime_Generation),1);
					
						!Set solver
						GMP::Instance::SetSolver(GMP_planning,SolverChoice);
						StatusMessage("ST... Solving the transition GMP for periods: " + SetAsString(periods_solve) );	
						! Solve the GMP
						GMP::Instance::Solve(GMP_planning ) ;
					
						! Get Progress window parameters for reporting purposes
						GMP_details(run_numberState,GMP_planning,ReferenceTime);
					
						StatusMessage(SBS_counter + "/" + SBS_length + " Solving the transition GMP is Finished!" + ' | ' + ifs);
						!============================================================= End of the Solve procedure =============================================================
					
						run_numberState:=run_numberState+1;
					
						!Save the variable values
						Ptech_use(tb,pss):=tech_use(tb,pss);
						Ptech_useHourly(h,th,pss):=tech_useHourly(h,th,pss);
						Ptech_useDaily(d,td,pss):=tech_useDaily(d,td,pss);
						PdeltaQ_UP(h,tf,pss):=deltaQ_UP(h,tf,pss);
						PdeltaQ_DW(h,tf,pss):=deltaQ_DW(h,tf,pss);
						PdeltaQ_S(h,tfb,pss):=deltaQ_S(h,tfb,pss);
						PdeltaQd_UP(d,tfl,pss):=deltaQd_UP(d,tfl,pss);
						PdeltaQd_DW(d,tfl,pss):=deltaQd_DW(d,tfl,pss);
						PdeltaU_CHP(h,tk,pss):=deltaU_CHP(h,tk,pss);
						PdeltaB_UP(d,tg,pss):=deltaB_UP(d,tg,pss);
						PdeltaB_DW(d,tg,pss):=deltaB_DW(d,tg,pss);
						PdeltaB_S(d,tg,pss):=deltaB_S(d,tg,pss);
						PdeltaP_CHP(h,tk,pss):=deltaP_CHP(h,tk,pss);
						PdeltaS_shed(h,ts,pss):=deltaS_shed(h,ts,pss);
						Pcap_investments(t,pss):=cap_investments(t,pss);
						Pretrofitting(it,jt,pss):=retrofitting(it,jt,pss);
						Peco_decommisioning(t,pss):=eco_decommisioning(t,pss);
						PdecomStock(t,pss):=decomStock(t,pss);
						PtechStock(t,pss):=techStock(t,pss);
						StechStock(t,pss):=techStock(t,pss);
						Ptotal_costs:=totalCosts;
					
						if GMP::Solution::GetProgramStatus(GMP_planning,1) = 'Optimal' then
							!Extract the prices
							!First extract the shadow prices for all the periods, then divide for the years of solution (where the weight is different than zero)
							yearly_prices(as,p):=balance_activities(as,p).ShadowPrice;
							yearly_prices(as,pss):=yearly_prices(as,pss)/social_discount_factor(pss);
							Pyearly_prices(as,pss) := yearly_prices(as,pss); 
							CO2_prices(acf,p):= balance_activities_emissionsFix(acf,p).ShadowPrice;
							CO2_prices(acf,pss):= CO2_prices(acf,pss)/social_discount_factor(pss);
							PCO2_prices(acf,pss) := CO2_prices(acf,pss);
							CO2_price_single(n,p) := balance_activities_emissiontarget(n,p).ShadowPrice;
							CO2_price_single(n,pss) := CO2_price_single(n,pss)/social_discount_factor(pss);
							!Save intrayear prices (shadow prices)
							hourly_prices(h,ah,p):=balance_activitiesHourly(h,ah,p).ShadowPrice;
							hourly_prices(h,ah,pss):=hourly_prices(h,ah,pss)/social_discount_factor(pss);
							daily_prices(d,ad,p):=balance_activitiesDaily(d,ad,p).ShadowPrice;
							daily_prices(d,ad,pss):=daily_prices(d,ad,pss)/social_discount_factor(pss);
					
							! Write model version
							MathProgramParameters('Model Version',1) := project_name;
					
							! Creat a directory for Output files
							if (DirectoryExists("Output/"+OutputFolderName) = 0) then DirectoryCreate("Output/"+OutputFolderName); endif;
					
							!Save the data file
							StatusMessage("Copying the input datafile ..." );
							FileCopy(DataReadingLocation,"Output/"+OutputFolderName+"/"+FindReplaceStrings(DataReadingLocation,"data\\",""));
					
					!		!Save the temporary case file
					!		if (SaveCaseValue = 'yes') then
					!			StatusMessage(BS_counter + "/" + BS_length + " Saving the temp Case as a datafile ..." );
					!			CaseFileSave("Output/"+OutputFolderName+"/"+OutputFolderName+"_temp.data",AllIdentifiers);
					!		endif;
					
							!Round the post processing routines before saving and writing the data.
							EnergyCosts_calculator;
							PostProcessParameters;
							RoundParameters;
					
							!Save the case file
							if (SaveCaseValue = 'yes') then
								StatusMessage(SBS_counter + "/" + SBS_length + "Saving the Case as a datafile ..." );
								CaseFileSave("Output/"+OutputFolderName+"/"+OutputFolderName+".data",AllIdentifiers);
					!			FileDelete("Output/"+OutputFolderName+"/"+OutputFolderName+"_temp.data");
							endif;
					
							! Calculate the elapsed time for reporting purposes
							MathProgramParameters('Total Run Time',1) := round(CurrentToMoment([minute],ReferenceTime),2) + " [min]";
					
							!Write the output of the model
							StatusMessage(SBS_counter + "/" + SBS_length + " Writing the Outputs ..."  + ' | ' + ifs);
							runDataWritingTransition;
					
							!Play the alarm
							AIMMSWav(Beep);
					
							StatusMessage(ifs + " is finished. " + " It took" + round(CurrentToMoment([minute],ReferenceTime),2) + " minutes");
						else
							! Calculate the elapsed time for reporting purposes
							MathProgramParameters('Total Run Time',1) := round(CurrentToMoment([minute],ReferenceTime),2) + " [min]";
					
							StatusMessage("Error or no solution for " + SBS_counter + " problem" );
						endif;
					
					endfor;
					
					!Play the alarm
					AIMMSWav(Finalized);
					
					StatusMessage("Batch Solve is finished.");
				}
			}
			Procedure ParallelBatchSolve {
				Body: {
					ProfilerStart() ; 
					
					! Choosing the barrier or warm start methods depending on the User's input. Default is Barrier. 
					if SolveMethodChoiceBatch = "Barrier" then
						ParallelBatchSolve_Barrier ;
					elseif SolveMethodChoiceBatch = "Warm Start" then
						ParallelBatchSolve_WarmStart_Inprogress ;
					endif;
				}
			}
			Procedure ParallelBatchSolve_Barrier {
				Body: {
					!Assign the periods to solve
					periods_solve := periods_selection;
					
					! Set solver options
					DefineSolverSettings;
					
					! Set output folder name
					if(OutputFolderValue = 'automatic') then
						OutputFolderName := CurrentToString("%c%y-%m-%d_%H.%M");
					endif;
					
					! Create a directory for Output files
					if (DirectoryExists("Output_Batch/"+OutputFolderName) = 0) then DirectoryCreate("Output_Batch/"+OutputFolderName); endif;
					
					!======================================= Batch Solve with Barrier method without crossover ========================
					! Asking the user on how many parallel workers to be used? this can be incorporated in the UI later. 
					if DialogGetNumber(formatString("Maximum %n  is allowed!" , min(CPUCores,32)), MaxParallelWorkers, 0, "How many parallel workers?") = 0 then Return; endif;
					
					if CPUCores = 0 then 
						option 'GUROBI 12.0'.Thread_limit := Floor(NumCPU/MaxParallelWorkers) ;
					else
						option 'GUROBI 12.0'.Thread_limit := Floor(CPUCores/MaxParallelWorkers) ;
					endif;
					
					DeleteAllGMPs ;
					empty BatchSolve_State,BatchSolve_ProgramState,BatchSolve_SolverState, BatchSolve_output, BatchSolve_totalCosts, BatchSolve_tech_use, BatchSolve_techStock, BatchSolve_yearly_prices, BatchSolve_CO2_price;
					
					! Initialization
					RetreiveExistingInputFiles ;
					DataReadingLocation := Element(InputFilesSet,1) ;
					runDataReading ;
					
					ScenarioVariants := InputFilesSelectionBatch ;
					ActiveParallelWorkers := 0 ;
					ActiveBufferGMP := 0 ;
					Repeat "main loop"
						! Read data and Generate GMPs
						if LoopCount("main loop") = 1 then 
							for (SV in ScenarioVariants) do "SV loop-1"
								if ActiveBufferGMP < MaxParallelWorkers then
									if not BatchSolve_GMP(SV) then
										StatusMessage("Reading scenario variant: " + SV);
										DataReadingBatch(SV);
										runDataReadingBatch;
										ActiveBufferGMP += 1 ;
										StatusMessage("Buffered GMPs = " + (ActiveBufferGMP) + 
											" | Active Workers = " + (ActiveParallelWorkers) + "/" + MaxParallelWorkers + 
											" | Generating scenario: " + SV + 
											" | Progress : " + round(100*(1-card(ScenarioVariants)/card(InputFilesSelectionBatch)),1) + "%");
										BatchSolve_GMP(SV) := GMP::Instance::Generate(LeastCostPlanning, "GMP_" + SV);
										GMP::Instance::SetSolver(BatchSolve_GMP(SV),SolverChoice);
									endif;
								endif;
								if LoopCount("SV loop-1") = min(5,card(ScenarioVariants)) then BREAK "SV loop-1"; endif;
						endfor;
							! Send GMPs to solver
							for (SV in ScenarioVariants) do "SV loop-2"
								if ActiveParallelWorkers < MaxParallelWorkers then
									if not BatchSolve_SolSes(SV) then
										BatchSolve_SolSes(SV) := GMP::Instance::CreateSolverSession(BatchSolve_GMP(SV), "SS_" + SV);
										if (ShowProgress = 'yes') then
											ProgressWindow :=  GMP::SolverSession::CreateProgressCategory(BatchSolve_SolSes(SV)) ;
											GMP::ProgressWindow::DisplayLine(7, "Instance", SV + " variation, " , ProgressWindow) ;
											GMP::ProgressWindow::FreezeLine(7,1, ProgressWindow) ;
										endif;
										ActiveParallelWorkers += 1 ; 
										ActiveBufferGMP -= 1 ;
										StatusMessage("Buffered GMPs = " + (ActiveBufferGMP) + 
											" | Active Workers = " + (ActiveParallelWorkers) + "/" + MaxParallelWorkers + 
											" | Solving scenario: " + SV + 
											" | Progress : " + round(100*(1-card(ScenarioVariants)/card(InputFilesSelectionBatch)),1) + "%");
										GMP::SolverSession::AsynchronousExecute(BatchSolve_SolSes(SV));
									endif;
								endif;
								if LoopCount("SV loop-2") = min(5,card(ScenarioVariants)) then BREAK "SV loop-2" ; endif;
							endfor;
							SKIP "main loop";
						else
							for (SV in ScenarioVariants) do 
								if ActiveBufferGMP < MaxParallelWorkers then
									if not BatchSolve_GMP(SV) then
										StatusMessage("Reading scenario variant: " + SV);
										DataReadingBatch(SV);
										runDataReadingBatch;
										ActiveBufferGMP += 1 ;
										StatusMessage("Buffered GMPs = " + (ActiveBufferGMP) + 
											" | Active Workers = " + (ActiveParallelWorkers) + "/" + MaxParallelWorkers + 
											" | Generating scenario: " + SV + 
											" | Progress : " + round(100*(1-card(ScenarioVariants)/card(InputFilesSelectionBatch)),1) + "%");
										BatchSolve_GMP(SV) := GMP::Instance::Generate(LeastCostPlanning, "GMP_" + SV);
										GMP::Instance::SetSolver(BatchSolve_GMP(SV),SolverChoice);
									endif;
								endif;
							endfor;
							! Send GMPs to solver
							for (SV in ScenarioVariants) do 
								if ActiveParallelWorkers < MaxParallelWorkers then
									if not BatchSolve_SolSes(SV) then
										BatchSolve_SolSes(SV) := GMP::Instance::CreateSolverSession(BatchSolve_GMP(SV), "SS_" + SV);
										if (ShowProgress = 'yes') then
											ProgressWindow :=  GMP::SolverSession::CreateProgressCategory(BatchSolve_SolSes(SV)) ;
											GMP::ProgressWindow::DisplayLine(7, "Instance", SV + " variation, " , ProgressWindow) ;
											GMP::ProgressWindow::FreezeLine(7,1, ProgressWindow) ;
										endif;
										ActiveParallelWorkers += 1 ; 
										ActiveBufferGMP -= 1 ;
										StatusMessage("Buffered GMPs = " + (ActiveBufferGMP) + 
											" | Active Workers = " + (ActiveParallelWorkers) + "/" + MaxParallelWorkers + 
											" | Solving scenario: " + SV + 
											" | Progress : " + round(100*(1-card(ScenarioVariants)/card(InputFilesSelectionBatch)),1) + "%");
										GMP::SolverSession::AsynchronousExecute(BatchSolve_SolSes(SV));
									endif;
								endif;
							endfor;
						endif;
					!	if LoopCount("main loop") = 1 then SKIP; endif;
						! Retrieve solutions once they are available
						FinishedSolSes := GMP::SolverSession::WaitForSingleCompletion(AllSolverSessionCompletionObjects);
						for (SV in ScenarioVariants) do
							if StringOccurrences(FinishedSolSes,SV) then 
								StatusMessage("Buffered GMPs = " + (ActiveBufferGMP) + 
									" | Active Workers = " + (ActiveParallelWorkers) + "/" + MaxParallelWorkers + 
									" | Retrieving scenario: " + SV + 
									" | Progress : " + round(100*(1-card(ScenarioVariants)/card(InputFilesSelectionBatch)),1) + "%");
								GMP::Solution::RetrieveFromSolverSession(BatchSolve_SolSes(SV), 1);
					
								for ifsb in InputFilesSelectionBatch do
									if (SV = ifsb) then
										BatchSolve_State(ifsb) := GMP::SolverSession::ExecutionStatus(BatchSolve_SolSes(SV));
										BatchSolve_ProgramState(ifsb) := GMP::SolverSession::GetProgramStatus(BatchSolve_SolSes(SV));
										BatchSolve_SolverState(ifsb) := GMP::SolverSession::GetSolverStatus(BatchSolve_SolSes(SV));
									endif;
								endfor;
					
								if (GMP::Solution::GetProgramStatus(BatchSolve_GMP(SV),1) <> 'Optimal') then
									StatusMessage("Not optimal scenario variant: " + SV);
									raise warning " ===== Could not find Optimal solution for GMP of " + SV ;
									for ifsb in InputFilesSelectionBatch do
										if (SV = ifsb) then BatchSolve_output(ifsb) := 0; endif;
									endfor;
									! Delete GMP and SolverSession to free-up RAM
									GMP::Instance::DeleteSolverSession(BatchSolve_SolSes(SV)) ;
									GMP::Instance::Delete(BatchSolve_GMP(SV));
									! Remove the scenario variant from the list
									ScenarioVariants -= SV;
								else
									GMP::Solution::SendToModel(BatchSolve_GMP(SV), 1);
									! Extract the results
									for ifsb in InputFilesSelectionBatch do
										if (SV = ifsb) then 
											BatchSolve_output(ifsb) := totalCosts ; 
											BatchSolve_totalCosts(ifsb) := round(totalCosts,2) ;
											BatchSolve_techStock(ifsb,t,pss) := round(techStock(t,pss),4) ;
											BatchSolve_tech_use(ifsb,tb,pss) := round(tech_use(tb,pss),4) ;
											BatchSolve_CO2_price(ifsb,n,pss) := round( -1 * balance_activities_EmissionTarget(n,pss).ShadowPrice / social_discount_factor(pss), 2) ;
											BatchSolve_yearly_prices(ifsb,as,pss) := round( -1 * balance_activities(as,pss).ShadowPrice / social_discount_factor(pss), 2) ;
											if (HourlyReportValue = 'yes') then
												BatchSolve_tech_use_h(ifsb,h,th,pss) := round(tech_useHourly(h,th,pss), 4);
												BatchSolve_tech_use_d(ifsb,d,td,pss) := round(tech_useDaily(d,td,pss), 4);
											endif;
											Batch_Writer;
											if (SaveCaseValue = 'yes') then
												StatusMessage(ifsb + " / " + "Saving the Case as a datafile ..." );
												CaseFileSave("Output_Batch/" + OutputFolderName + "/" + FindReplaceNthString(ifsb,"data_Batch\\","",1) - ".xlsx"  + ".data", AllIdentifiers);
											endif;
										endif;
									endfor;
					
									! Delete GMP and SolverSessions to free-up RAM
									GMP::Instance::DeleteSolverSession(BatchSolve_SolSes(SV)) ;
									GMP::Instance::Delete(BatchSolve_GMP(SV));
									! Remove the scenario variant from the list
									ScenarioVariants -= SV;
									!Play the interim alarm
									AIMMSWav(Beep);
								endif; 
								ActiveParallelWorkers -= 1 ;
							endif;
						endfor;
						if (card(AllSolverSessions) = 0 and card(ScenarioVariants) = 0) then BREAK "main loop" ; endif;
					endrepeat ;
					
					!Play the final alarm
					AIMMSWav(Finalized);
					
					StatusMessage("Buffered GMPs = " + (ActiveBufferGMP) + 
						" | Active Workers = " + (ActiveParallelWorkers) + "/" + MaxParallelWorkers + 
						" | Progress : " + round(100*(1-card(ScenarioVariants)/card(InputFilesSelectionBatch)),1) + "%");
				}
			}
			Procedure ParallelBatchSolve_WarmStart_Inprogress {
				Body: {
					!Assign the periods to solve
					periods_solve := periods_selection;
					
					!First remove all the solversessions that currently might be active
					DeleteAllGMPs;
					
					!======================================= Batch Solve with Warm Start ========================
					! Set the options
					option linear_presolve := 'Off';
					option Remove_Doubletons := 'Always';
					option scale_model := 'Off';
					option accept_basis := 1 ;
					option always_store_marginals := 1 ;
					option display_infeasibility_analysis := 1 ;
					option infeasibility_finder := on ;
					option listing_number_precision := 20 ;
					option remove_doubletons := 'always' ;
					option rounding_compatibility := 'Aimms_3_7' ;
					option solver_listing_messages := 4 ;
					option Enhanced_Long_Run_Responsiveness := 1 ;
					
					!Options for 8h runs
					
					option "GUROBI 12.0".Thread_limit := min(8, Floor(0.9 * NumCPU));
					option "GUROBI 12.0".Method := 2 ;
					option "GUROBI 12.0".Numeric_focus := 1 ;
					option "GUROBI 12.0".Scale := 0 ;
					option "GUROBI 12.0".Barrier_crossover := 1; 
					option "GUROBI 12.0".Log_to_console := 1 ;
					option "GUROBI 12.0".Output_file := 1 ;
					option "GUROBI 12.0".Presolve := 1 ; 
					option "GUROBI 12.0".Presolve_aggregation := 2 ;
					option "GUROBI 12.0".Presolve_aggregation_fill := 5 ;
					option "GUROBI 12.0".Presolve_dual := 0 ;
					option "GUROBI 12.0".Presolve_passes := 3 ;
					option "GUROBI 12.0".Presolve_row_reduction := 0 ;
					option "GUROBI 12.0".warm_start := 'Original problem' ;
					
					! Asking the user on how many parallel workers to be used? this can be incorporated in the UI later. 
					DialogGetNumber(formatString("Maximum %n  is allowed!" , min(NumCPU,32)), MaxParallelWorkers, 0, "How many parallel workers?") ;
					
					! Initialization
					Empty_parameters ;
					RetreiveExistingInputFiles ;
					DataReading(Element(InputFilesSetBatch,1)) ;
					runDataReadingBatch ;
					
					GMP_planning := GMP::Instance::Generate(LeastCostPlanning,"Main");
					GMP::Instance::Solve(GMP_planning) ;
					!!===============================================================
					
					if CPUCores = 0 then 
						option 'GUROBI 12.0'.Thread_limit := Floor(NumCPU/MaxParallelWorkers) ;
					else
						option 'GUROBI 12.0'.Thread_limit := Floor(CPUCores/MaxParallelWorkers) ;
					endif;
					option "GUROBI 12.0".Method := 'Dual Simplex' ;
					
					ScenarioVariants := InputFilesSelectionBatch ;
					ActiveParallelWorkers := 0 ;
					Repeat "main loop"
						for (SV in ScenarioVariants) do
							if ActiveParallelWorkers < MaxParallelWorkers then
								if not BatchSolve_SolSes(SV) then
					!				StatusMessage("Reading scenario variant: " + SV);
									DataReadingBatch(SV);
									runDataReadingBatch;
					
					!				StatusMessage("Generating scenario variant: " + SV);
									BatchSolve_GMP(SV) := GMP::Instance::Generate(LeastCostPlanning, "GMP_" + SV);
									GMP::Solution::RetrieveFromModel(BatchSolve_GMP(SV),1);
									BatchSolve_SolSes(SV) := GMP::Instance::CreateSolverSession(BatchSolve_GMP(SV), "SS_" + SV);
									GMP::Solution::SendToSolverSession(BatchSolve_SolSes(SV),1);
					
									ProgressWindow :=  GMP::SolverSession::CreateProgressCategory(BatchSolve_SolSes(SV)) ;
									GMP::ProgressWindow::DisplayLine(7, "Instance", SV + " variation, " , ProgressWindow) ;
									GMP::ProgressWindow::FreezeLine(7,1, ProgressWindow) ;
					
									StatusMessage("Solving scenario variant: " + SV);
									GMP::SolverSession::AsynchronousExecute(BatchSolve_SolSes(SV));
					
									ActiveParallelWorkers +=  1 ;
								endif;
							endif;
						endfor;
					
						!continue this loop until we manually break out of it with a break statement
						while card(AllSolverSessionCompletionObjects) do
							FinishedSolSes := GMP::SolverSession::WaitForSingleCompletion(AllSolverSessionCompletionObjects);
							for (SV in ScenarioVariants) do
								if StringOccurrences(FinishedSolSes,SV) then 
									StatusMessage("Retreiveing scenario variant: " + SV);
									GMP::Solution::RetrieveFromSolverSession(BatchSolve_SolSes(SV), 1);
									if (GMP::Solution::GetProgramStatus(BatchSolve_GMP(SV),1) <> 'Optimal') then
										StatusMessage("Not optimal scenario variant: " + SV);
										raise warning " ===== Could not find Optimal solution for GMP of " + SV ;
										for ifsb in InputFilesSelectionBatch do
											if (SV = ifsb) then BatchSolve_output(ifsb) := 0; endif;
										endfor;
										! Delete GMP and SolverSession to free-up RAM
					!					StatusMessage("Removing scenario variant: " + SV);
										GMP::Instance::DeleteSolverSession(BatchSolve_SolSes(SV)) ;
										GMP::Instance::Delete(BatchSolve_GMP(SV));
										! Remove the scenario variant from the list
										ScenarioVariants -= SV;
									else
					!					StatusMessage("Send to model scenario variant: " + SV);
										GMP::Solution::SendToModel(BatchSolve_GMP(SV), 1);
										! Extract the results
										for ifsb in InputFilesSelectionBatch do
											if (SV = ifsb) then 
												BatchSolve_output(ifsb) := totalCosts ; 
												BatchSolve_totalCosts(ifsb) := round(totalCosts,2) ;
												BatchSolve_techStock(ifsb,t,pss) := round(techStock(t,pss),4) ;
												BatchSolve_tech_use(ifsb,tb,pss) := round(tech_use(tb,pss),4) ;
												BatchSolve_CO2_price(ifsb,n,pss) := round( -1 * balance_activities_EmissionTarget(n,pss).ShadowPrice / social_discount_factor(pss), 2) ;
												BatchSolve_yearly_prices(ifsb,as,pss) := round( -1 * balance_activities(as,pss).ShadowPrice / social_discount_factor(pss), 2) ;
											endif;
										endfor;
										! Delete GMP and SolverSession to free-up RAM
					!					StatusMessage("Removing scenario variant: " + SV);
										GMP::Instance::DeleteSolverSession(BatchSolve_SolSes(SV)) ;
										GMP::Instance::Delete(BatchSolve_GMP(SV));
										! Remove the scenario variant from the list
										ScenarioVariants -= SV;
									endif; 
								endif;
							endfor;
							ActiveParallelWorkers -= 1 ;
						endwhile;
						if (card(AllSolverSessions) = 0 and card(ScenarioVariants) = 0) then BREAK "main loop"; endif;
					endrepeat ;
				}
			}
		}
	}
	Section Post_Processing {
		Section Violations {
			DeclarationSection ViolationParms {
				Set AllViolations {
					SubsetOf: AllVariablesConstraints;
				}
				Parameter techStock_violation {
					IndexDomain: (t,p);
					Definition: {
						techStock(t,p).Violation ;
					}
				}
				Parameter tech_use_violation {
					IndexDomain: (t,p);
					Definition: {
						tech_use(t,p).Violation ;
					}
				}
				Parameter tech_useDaily_violation {
					IndexDomain: (d,td,p);
					Definition: {
						tech_useDaily(d,td,p).Violation ;
					}
				}
				Parameter tech_useHourly_violation {
					IndexDomain: (h,thh,p);
					Definition: {
						tech_useHourly(h,thh,p).Violation ;
					}
				}
			}
			Procedure ViolationFinder {
				Body: {
					for ( IndexVariablesConstraints | card(IndexVariablesConstraints, 'Violation') ) do
					
						AllViolations += StringToElement(AllViolations,IndexVariablesConstraints,1) ; 
					
					endfor;
				}
			}
		}
		DeclarationSection Kira_output {
			Parameter test_KW;
			Parameter Primary {
				IndexDomain: (nn,el,ps);
				Definition: {
					sum[n, (namePer_node(n)=nn)*primaryEnergy(n,el,ps)*IEM_node(n)]*(el<>'Oil')
					-sum[n, (namePer_node(n)=nn)*exportsEnergy(n,el,ps)*IEM_node(n)]*(el<>'Oil')
					+sum[n, (namePer_node(n)=nn)*primaryEnergy(n,'Oil',ps)*IEM_node(n)]*(el='Oil Products')
					-sum[n, (namePer_node(n)=nn)*exportsEnergy(n,'Oil',ps)*IEM_node(n)]*(el='Oil Products')
				}
			}
			Parameter FinalInclB_sec {
				IndexDomain: (n,z,el,ps);
				Definition: {
					sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Final')*(tech_sector(tb)=z)*(tech_subsector(tb)<>'Bunker')*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
					energyUse_tech(n,tb,ae,ps)*(labelPer_act(ae)=el)] !Final enery use (non Bunker)
					
					+ sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Final')*(tech_sector(tb)='Transport')*(tech_subsector(tb)=z)*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
					energyUse_tech(n,tb,ae,ps)*(labelPer_act(ae)=el)] !Final enery use (Bunker)
					
					 !below added by Kira to correct for "conversion" material processes and CCUS
					
					 !Final enery use for industrial material conversion processes
					 + sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Conversion')*(tech_sector(tb)='Industry')*(activityType_act(activityPer_tech(tb))='Material conversion')*(tech_sector(tb)=z))<>0,
					 energyUse_tech(n,tb,ae,ps)*(labelPer_act(ae)=el)]
					
					!CCUS
					   + sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Emission')*(tech_sector(tb)='Industry')*(tech_sector(tb)=z))<>0,
					 (energyUse_tech(n,tb,ae,ps)*(labelPer_act(ae)=el))]
				}
			}
			Parameter FinalInclB {
				IndexDomain: (n,el,ps);
				Definition: {
					sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Final')*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
					energyUse_tech(n,tb,ae,ps)*(labelPer_act(ae)=el)] !Final enery use
					
					
					 !below added by Kira to correct for "conversion" material processes and CCUS
					
					 !Final enery use for industrial material conversion processes
					 + sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Conversion')*(tech_sector(tb)='Industry')*(activityType_act(activityPer_tech(tb))='Material conversion'))<>0,
					 energyUse_tech(n,tb,ae,ps)*(labelPer_act(ae)=el)]
					
					!CCUS
					   + sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Emission')*(tech_sector(tb)='Industry'))<>0,
					 (energyUse_tech(n,tb,ae,ps)*(labelPer_act(ae)=el))]
				}
			}
			Parameter FinalExclB_sec {
				IndexDomain: (n,z,el,ps);
				Definition: {
					sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Final')*(tech_sector(tb)=z)*(tech_subsector(tb)<>'Bunker')*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
					energyUse_tech(n,tb,ae,ps)*(labelPer_act(ae)=el)] !Final enery use (non Bunker)
					
					 !below added by Kira to correct for "conversion" material processes and CCUS
					
					 !Final enery use for industrial material conversion processes
					 + sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Conversion')*(tech_sector(tb)='Industry')*(activityType_act(activityPer_tech(tb))='Material conversion')*(tech_sector(tb)=z))<>0,
					 energyUse_tech(n,tb,ae,ps)*(labelPer_act(ae)=el)]
					
					!CCUS
					   + sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Emission')*(tech_sector(tb)='Industry')*(tech_sector(tb)=z))<>0,
					 (energyUse_tech(n,tb,ae,ps)*(labelPer_act(ae)=el))]
				}
			}
			Parameter FinalExclB {
				IndexDomain: (n,el,ps);
				Definition: {
					sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Final')*(tech_subsector(tb)<>'Bunker')*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
					energyUse_tech(n,tb,ae,ps)*(labelPer_act(ae)=el)] !Final enery use (non Bunker)
					
					 !below added by Kira to correct for "conversion" material processes and CCUS
					
					 !Final enery use for industrial material conversion processes
					 + sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Conversion')*(tech_sector(tb)='Industry')*(activityType_act(activityPer_tech(tb))='Material conversion'))<>0,
					 energyUse_tech(n,tb,ae,ps)*(labelPer_act(ae)=el)]
					
					!CCUS
					   + sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Emission')*(tech_sector(tb)='Industry'))<>0,
					 (energyUse_tech(n,tb,ae,ps)*(labelPer_act(ae)=el))]
				}
			}
			Parameter TSC {
				IndexDomain: (n,tots,toc,ps);
				Definition: {
					if (tots='Balancing') then
						sum[tb, SystemCosts_techBal(n,toc,tb,ps)] 
					elseif (tots='Infrastructure') then
						sum[ti, SystemCosts_techInfra(n,toc,ti,ps)]
					endif
				}
			}
			Parameter Copy_supplyAct_tech {
				IndexDomain: (n,as,tb,tn,ps);
				Definition: {
					(nodePer_techBal(tb)=n)*(tech_name(tb)=tn)*
					((activity_balances(tb,as,ps)*(1-2*(as in activities_emission)))>0)
					*(Ptech_useNet(tb,ps)*activity_balances(tb,as,ps)+  !Reference activity balance
					sum[h, PdeltaQ_DW(h,tb,ps)]*dQ_hourly(tb,as)+ !Impact of flexibility in hourly activities
					!sum[tg, sum[d, (deltaB_DW(d,tg,p)-deltaB_UP(d,tg,p))]*activity_balances(tg,as,p)]+ !Impact of gas buffers energy consumption
					sum[h, PdeltaP_CHP(h,tb,ps)]*dP_electricity(tb,as)+ !Impact in power of power output ratio deviation of CHPs
					sum[h, -CHP_eta(tb)*PdeltaP_CHP(h,tb,ps)/CHP_eps(tb,ps)]*dP_heat(tb,as) !Impact in heat of power output ratio deviation of CHPs
					)
				}
			}
			Parameter Copy_demandAct_tech {
				IndexDomain: (n,as,tb,tn,ps);
				Definition: {
					(nodePer_techBal(tb)=n)*(tech_name(tb)=tn)*
					((activity_balances(tb,as,ps)*(1-2*(as in activities_emission)))<0)
					*(Ptech_useNet(tb,ps)*activity_balances(tb,as,ps)+  !Reference activity balance
					sum[h, PdeltaQ_DW(h,tb,ps)]*dQ_hourly(tb,as)+ !Impact of flexibility in hourly activities
					!sum[tg, sum[d, (deltaB_DW(d,tg,p)-deltaB_UP(d,tg,p))]*activity_balances(tg,as,p)]+ !Impact of gas buffers energy consumption
					sum[h, PdeltaP_CHP(h,tb,ps)]*dP_electricity(tb,as)+ !Impact in power of power output ratio deviation of CHPs
					sum[h, -CHP_eta(tb)*PdeltaP_CHP(h,tb,ps)/CHP_eps(tb,ps)]*dP_heat(tb,as) !Impact in heat of power output ratio deviation of CHPs
					)
				}
			}
			Parameter Copy_energyUse_act {
				IndexDomain: (nn,z,as,ae,ps);
				Definition: sum[(n,tb), (namePer_node(n)=nn)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)*energyUse_tech(n,tb,ae,ps)];
			}
			Parameter Final_energy_2030_test {
				IndexDomain: ps | ps='2030';
				Definition: {
					sum[(tb,ae) | ((nodePer_techBal(tb)='NL')*(tech_category(tb)='Final')*(activityPer_tech(tb)<>'Bunker Navigation')*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
						(-1)
						*
						(tech_use(tb,ps)+sum[h, deltaU_CHP(h,tb,ps)]+sum[h, deltaS_shed(h,tb,ps)])
						*(activity_balances(tb,ae,ps) - feedstockUse_tech(tb,ae))				! final energy minus feedstock
						+sum[h, (PdeltaQ_UP(h,tb,ps)+PdeltaQ_DW(h,tb,ps))]*dQ_hourly(tb,ae)			!Impact of flexibility in hourly activities
						+sum[h, PdeltaP_CHP(h,tb,ps)]*dP_electricity(tb,ae)					!Impact in power of power output ratio deviation of CHp
						+sum[h, -CHP_eta(tb)*PdeltaP_CHP(h,tb,ps)/CHP_eps(tb,ps)]*dP_heat(tb,ae)		!Impact in heat of power output ratio deviation of CHp
					] 
					
					!Final enery use for industrial material conversion processes
					+ sum[(tb,ae) | ((nodePer_techBal(tb)='NL')*(tech_category(tb)='Conversion')*(tech_sector(tb)='Industry')*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
						(-1)
						*
						(tech_use(tb,ps)+sum[h, deltaU_CHP(h,tb,ps)]+sum[h, deltaS_shed(h,tb,ps)])
						*(activity_balances(tb,ae,ps) - feedstockUse_tech(tb,ae))				! final energy minus feedstock
						+sum[h, (PdeltaQ_UP(h,tb,ps)+PdeltaQ_DW(h,tb,ps))]*dQ_hourly(tb,ae)			!Impact of flexibility in hourly activities
						+sum[h, PdeltaP_CHP(h,tb,ps)]*dP_electricity(tb,ae)					!Impact in power of power output ratio deviation of CHp
						+sum[h, -CHP_eta(tb)*PdeltaP_CHP(h,tb,ps)/CHP_eps(tb,ps)]*dP_heat(tb,ae)		!Impact in heat of power output ratio deviation of CHp
					]
					
					!CCS (DACs)
					+ sum[(tb,ae) | ((nodePer_techBal(tb)='NL')*(tech_category(tb)='Conversion')*(tech_sector(tb)='Industry')*(activityType_act(activityPer_tech(tb))='material conversion'))<>0,
						(-1)
						*
						(tech_use(tb,ps)+sum[h, deltaU_CHP(h,tb,ps)]+sum[h, deltaS_shed(h,tb,ps)])
						*(activity_balances(tb,ae,ps) - feedstockUse_tech(tb,ae))				! final energy minus feedstock
						+sum[h, (PdeltaQ_UP(h,tb,ps)+PdeltaQ_DW(h,tb,ps))]*dQ_hourly(tb,ae)			!Impact of flexibility in hourly activities
						+sum[h, PdeltaP_CHP(h,tb,ps)]*dP_electricity(tb,ae)					!Impact in power of power output ratio deviation of CHp
						+sum[h, -CHP_eta(tb)*PdeltaP_CHP(h,tb,ps)/CHP_eps(tb,ps)]*dP_heat(tb,ae)		!Impact in heat of power output ratio deviation of CHp
					]
				}
			}
		}
		DeclarationSection Variables_stored {
			Parameter Ptech_use {
				IndexDomain: (t,p);
			}
			Parameter Ptech_useNet {
				IndexDomain: (t,p);
				Definition: Ptech_use(t,p)+sum[h, PdeltaU_CHP(h,t,p)]+sum[h, PdeltaS_shed(h,t,p)];
			}
			Parameter Ptech_useHourly {
				IndexDomain: (h,t,p);
				InitialData: 0;
			}
			Parameter Ptech_useHourlyNet {
				IndexDomain: (h,t,p);
				Definition: {
					Ptech_useHourly(h,t,p)
					+Ptech_useDaily(dayPer_hour(h),t,p)/hoursPer_day
					+Ptech_use(t,p)*hourly_profiles(h,profileType_tech(t))*(((t in tech_hourlyDispatch)+(t in tech_dailyDispatch))=0)
					+PdeltaU_CHP(h,t,p)
					+PdeltaS_shed(h,t,p)
				}
			}
			Parameter Ptech_useDaily {
				IndexDomain: (d,t,p);
			}
			Parameter Ptech_useDailyNet {
				IndexDomain: (d,t,p);
				Definition: {
					sum[ih | dayPer_hour(ih)=d, Ptech_useHourly(ih,t,p)]
					+Ptech_useDaily(d,t,p)
					+sum[ih | dayPer_hour(ih)=d, Ptech_use(t,p)*hourly_profiles(ih,profileType_tech(t))]*(((t in tech_hourlyDispatch)+(t in tech_dailyDispatch))=0)
					+sum[ih | dayPer_hour(ih)=d, PdeltaU_CHP(ih,t,p)]
					+sum[ih | dayPer_hour(ih)=d, PdeltaS_shed(ih,t,p)]
				}
			}
			Parameter PdeltaQ_UP {
				IndexDomain: (h,t,p);
			}
			Parameter PdeltaQ_DW {
				IndexDomain: (h,t,p);
			}
			Parameter PdeltaQ_S {
				IndexDomain: (h,t,p);
			}
			Parameter PdeltaQd_UP {
				IndexDomain: (d,t,p);
			}
			Parameter PdeltaQd_DW {
				IndexDomain: (d,t,p);
			}
			Parameter PdeltaB_UP {
				IndexDomain: (d,t,p);
			}
			Parameter PdeltaB_DW {
				IndexDomain: (d,t,p);
			}
			Parameter PdeltaB_S {
				IndexDomain: (d,t,p);
			}
			Parameter PdeltaU_CHP {
				IndexDomain: (h,t,p);
			}
			Parameter PdeltaP_CHP {
				IndexDomain: (h,t,p);
			}
			Parameter PdeltaS_shed {
				IndexDomain: (h,t,p);
			}
			Parameter Pcap_investments {
				IndexDomain: (t,p);
				InitialData: 0;
			}
			Parameter Pretrofitting {
				IndexDomain: (it,jt,p);
				InitialData: 0;
			}
			Parameter Peco_decommisioning {
				IndexDomain: (t,p);
				InitialData: 0;
			}
			Parameter PdecomStock {
				IndexDomain: (t,p);
				InitialData: 0;
			}
			Parameter PtechStock {
				IndexDomain: (t,p);
				InitialData: 0;
			}
			Parameter StechStock {
				IndexDomain: (t,p);
				InitialData: 0;
			}
			Parameter Ptotal_costs;
			Parameter Pyearly_prices {
				IndexDomain: (as,p);
				InitialData: 0;
			}
			Parameter PCO2_prices {
				IndexDomain: (aer,p);
				InitialData: 0;
			}
		}
		DeclarationSection Variables_stored_batch {
			Parameter BatchSolve_output {
				IndexDomain: ifsb;
			}
			Parameter BatchSolve_totalCosts {
				IndexDomain: ifsb;
			}
			Parameter BatchSolve_tech_use {
				IndexDomain: (ifsb,tb,p);
			}
			Parameter BatchSolve_techStock {
				IndexDomain: (ifsb,t,p);
			}
			Parameter BatchSolve_yearly_prices {
				IndexDomain: (ifsb,as,p);
			}
			Parameter BatchSolve_CO2_price {
				IndexDomain: (ifsb,n,p);
			}
			Parameter BatchSolve_tech_use_h {
				IndexDomain: (ifsb,h,th,p);
			}
			Parameter BatchSolve_tech_use_d {
				IndexDomain: (ifsb,d,td,p);
			}
			ElementParameter BatchSolve_State {
				IndexDomain: ifsb;
				Range: AllExecutionStatuses;
			}
			ElementParameter BatchSolve_ProgramState {
				IndexDomain: ifsb;
				Range: AllSolutionStates;
			}
			ElementParameter BatchSolve_SolverState {
				IndexDomain: ifsb;
				Range: AllSolutionStates;
			}
		}
		DeclarationSection Shadow_Prices {
			Set activitiesHour_heat {
				SubsetOf: activities_hour;
				Index: ahh;
				Definition: {
					{ah | StringOccurrences(ah,"Heat")>0}
				}
			}
			Set activitiesHour_electricity {
				SubsetOf: activities_hour;
				Index: ahe, iahe;
				Definition: {
					{ah | StringOccurrences(ah,"Electricity")>0}
				}
			}
			Parameter hourly_prices {
				IndexDomain: (h,ah,p);
				InitialData: 0;
			}
			Parameter daily_prices {
				IndexDomain: (d,ad,p);
				InitialData: 0;
			}
			Parameter yearly_prices {
				IndexDomain: (as,p);
				InitialData: 0;
			}
			Parameter CO2_prices {
				IndexDomain: (acf,p);
				InitialData: 0;
			}
			Parameter CO2_price_single {
				IndexDomain: (n,p);
				InitialData: 0;
			}
			Parameter shadow_energyPrices {
				IndexDomain: (nn,ae,p);
				Definition: {
					if (ae in activities_year) then
						sum[n, (namePer_node(nodePer_act(ae))=nn)*yearly_prices(ae,p)]
					elseif (ae in activities_day) then
						sum[n, (namePer_node(nodePer_act(ae))=nn)*sum[d, daily_prices(d,ae,p)]/card(days)]
					elseif (ae in activities_hour) then
						sum[n, (namePer_node(nodePer_act(ae))=nn)*sum[h, hourly_prices(h,ae,p)]/card(hours)]
					endif
				}
			}
			Parameter shadow_CO2Prices {
				IndexDomain: (nn,acf,p);
				Definition: sum[n, (namePer_node(nodePer_act(acf))=nn)*CO2_prices(acf,p)];
			}
		}
		DeclarationSection Energy_Costs {
			Set typesOf_LCOEelements {
				Index: tol, itol, jtol;
				Definition: {
					{'CAPEX','FOM','VOC','Fuels','Emissions'}
				}
			}
			Set typesOf_LCOEmethod {
				Index: tolm, itolm, jtolm;
				Definition: {
					{'Theoretical','Real'}
				}
			}
			Set activities_secondary {
				SubsetOf: activities_solve;
				Index: ass, iass, jass;
				Definition: {
					{as | sum[(tb,pnz), (activityPer_tech(tb)=as)*Ptech_useNet(tb,pnz)]=0} 
					+ {as | as='Mixed Plastic Waste'} !Mixed plastic waste added by Kira - this is because one sorting process is given on an input basis
				}
			}
			Parameter TechExclussiveness {
				IndexDomain: (tb,p);
				Definition: {
					sum[as, activity_balances(tb,as,p)*(activityPer_tech(tb)=as)*(as in activities_emission=0)]
					/sum[as, activity_balances(tb,as,p)*(activity_balances(tb,as,p)*(as in activities_emission=0)>0)+1e-9]
				}
			}
			Parameter EnergyCosts_yearly {
				IndexDomain: (as,p);
				InitialData: 0;
			}
			Parameter EnergyCosts_daily {
				IndexDomain: (d,ad,p);
				InitialData: 0;
			}
			Parameter EnergyCosts_hourly {
				IndexDomain: (h,ah,p);
				InitialData: 0;
			}
			Parameter EnergyCosts {
				IndexDomain: (h,as,p);
				InitialData: 0;
			}
			Parameter FuelCosts {
				IndexDomain: (h,tb,p);
				Definition: -sum[ae, Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ae,p)*EnergyCosts(h,ae,p)*(activity_balances(tb,ae,p)<0)]*TechExclussiveness(tb,p);
			}
			Parameter EnergyCosts_mean {
				IndexDomain: (ae,p);
				Definition: sum[h, EnergyCosts(h,ae,p)]/card(hours);
			}
			Parameter EnergyCosts_mean_secondary {
				IndexDomain: (ass,p);
				Definition: sum[h, EnergyCosts_yearly(ass,p)]/card(hours);
			}
			Parameter EnergyCostsVariability {
				IndexDomain: (h,ae,p);
				Definition: {
					if (h=1) then
						EnergyCosts(h,ae,p)-EnergyCosts(card(hours),ae,p) !(HARDCODED)
					else
					EnergyCosts(h,ae,p)-EnergyCosts(h-1,ae,p)
					endif
				}
			}
			Parameter EmissionCosts {
				IndexDomain: (ac,p);
				Definition: sum[tb, (activityPer_tech(tb)=ac)*vom_cost(tb,p)];
			}
			Parameter techCosts_voc {
				IndexDomain: (h,tb,p);
				InitialData: 0;
			}
			Parameter IterCounter;
			Parameter LCOE_tech {
				IndexDomain: (nn,as,tb,tol,p);
				Definition: {
					if (tol='CAPEX') then
						(activityPer_tech(tb)=as)*(
						IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(Ptech_useNet(tb,p)>=0.01)
						*PtechStock(tb,p)*inv_cost(tb,p)*CRF(tb)/(Ptech_useNet(tb,p)+1e-10)
						+IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(Ptech_useNet(tb,p)<0.01)
						*inv_cost(tb,p)*CRF(tb)/cap2act(tb)
						)
					elseif (tol='FOM') then
						(activityPer_tech(tb)=as)*(
						IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(Ptech_useNet(tb,p)>=0.01)
						*PtechStock(tb,p)*fom_cost(tb,p)/(Ptech_useNet(tb,p)+1e-10)
						+IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(Ptech_useNet(tb,p)<0.01)
						*fom_cost(tb,p)/cap2act(tb)
						)
					elseif (tol='VOC') then
						(activityPer_tech(tb)=as)*(
						IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)
						*vom_cost(tb,p)
						)
					elseif (tol='Fuels') then
						(activityPer_tech(tb)=as)*(
						IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(Ptech_useNet(tb,p)>=0.01)
						*sum[h,FuelCosts(h,tb,p)]/(Ptech_useNet(tb,p)+1e-10)
						-IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(Ptech_useNet(tb,p)<0.01)
						*sum[(ae), activity_balances(tb,ae,p)*EnergyCosts_mean(ae,p)*(activity_balances(tb,ae,p)<0)]
						)
					elseif (tol='Emissions') then
						(activityPer_tech(tb)=as)*(
						-IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)
						*sum[(ac), activity_balances(tb,ac,p)*EmissionCosts(ac,p)]
						)
					endif
				}
			}
			Parameter LCOE_theo {
				IndexDomain: (nn,as,tb,tol,p);
				Definition: {
					if (tol='CAPEX') then
						(activityPer_tech(tb)=as)*(
						IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*inv_cost(tb,p)*CRF(tb)/cap2act(tb)
						)
					elseif (tol='FOM') then
						(activityPer_tech(tb)=as)*(
						IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*fom_cost(tb,p)/cap2act(tb)
						)
					elseif (tol='VOC') then
						(activityPer_tech(tb)=as)*(
						IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*vom_cost(tb,p)
						)
					elseif (tol='Fuels') then
						(activityPer_tech(tb)=as)*(
						-IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)
						*sum[(ae), activity_balances(tb,ae,p)*EnergyCosts_mean(ae,p)*(activity_balances(tb,ae,p)<0)]
						)
					elseif (tol='Emissions') then
						(activityPer_tech(tb)=as)*(
						-IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)
						*sum[(ac), activity_balances(tb,ac,p)*EmissionCosts(ac,p)]
						)
					endif
				}
			}
			Parameter LCOE_real {
				IndexDomain: (nn,as,tb,tol,p);
				Definition: {
					if (tol='CAPEX') then
						(activityPer_tech(tb)=as)*(
						IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(Ptech_useNet(tb,p)>=0.01)
						*PtechStock(tb,p)*inv_cost(tb,p)*CRF(tb)/(Ptech_useNet(tb,p)+1e-10)
						)
					elseif (tol='FOM') then
						(activityPer_tech(tb)=as)*(
						IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(Ptech_useNet(tb,p)>=0.01)
						*PtechStock(tb,p)*fom_cost(tb,p)/(Ptech_useNet(tb,p)+1e-10)
						)
					elseif (tol='VOC') then
						(activityPer_tech(tb)=as)*(
						IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(Ptech_useNet(tb,p)>=0.01)
						*vom_cost(tb,p)
						)
					elseif (tol='Fuels') then
						(activityPer_tech(tb)=as)*(
						IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(Ptech_useNet(tb,p)>=0.01)
						*sum[h,FuelCosts(h,tb,p)]/(Ptech_useNet(tb,p)+1e-10)
						)
					elseif (tol='Emissions') then
						(activityPer_tech(tb)=as)*(
						-IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(Ptech_useNet(tb,p)>=0.01)
						*sum[(ac), activity_balances(tb,ac,p)*EmissionCosts(ac,p)]
						)
					endif
				}
			}
			Parameter LCOE {
				IndexDomain: (nn,as,tb,tolm,tol,p);
				Definition: {
					if (tolm='Theoretical') then
						LCOE_theo(nn,as,tb,tol,p)
					elseif(tolm='Real') then
						LCOE_real(nn,as,tb,tol,p)
					endif
				}
			}
			Parameter EnergyCosts_node {
				IndexDomain: (nn,ae,p);
				Definition: (namePer_node(nodePer_act(ae))=nn)*EnergyCosts_mean(ae,p);
			}
			Parameter EnergyCosts_node_secondary {
				IndexDomain: (nn,ass,p);
				Definition: (namePer_node(nodePer_act(ass))=nn)*EnergyCosts_mean_secondary(ass,p);
			}
			Parameter EnergyCosts_nodeH {
				IndexDomain: (nn,h,ah,p);
				Definition: (namePer_node(nodePer_act(ah))=nn)*EnergyCosts_hourly(h,ah,p);
			}
			Parameter EnergyCosts_nodeD {
				IndexDomain: (nn,d,ad,p);
				Definition: (namePer_node(nodePer_act(ad))=nn)*EnergyCosts_daily(d,ad,p);
			}
		}
		DeclarationSection System_Costs {
			Set typesOf_costs {
				Index: toc, itoc;
				Definition: {
					{'Capital Cost','Fixed Operational Cost','Variable Operational Cost','Fuel Costs','Emission Costs','Trading Costs','National Primary Energy Cost','Import Cost','Export Revenues','Total Cost'}
				}
			}
			Set typesOf_payments {
				Index: top, itop;
				Definition: {
					{'Investment', 'Decommisioning', 'Retrofitting','Operational', 'Variable'}
				}
			}
			Set typesOf_techSources {
				Index: tots, itots;
				Definition: {
					{'Balancing','Infrastructure'}
				}
			}
			Parameter objFun_decomposition {
				IndexDomain: (toc,p,ps);
				Definition: {
					if (toc='Capital Cost') then
						+sum[(t,jp), InvMat_lifeTime(t,jp,ps)*						!lifetime matrix
						(cap_investments(t,jp)*inv_cost(t,jp)*CRF(t)				!New invetments
						+sum[(it,jt), retrofitting(it,jt,ps)*CRF(jt)*(retro_cost(it,jt)+p_epsilon)] !Retrofitting costs (based on Excel database input)
						!-eco_decommisioning(t,jp)*(1-salvage_value(t))*inv_cost(t,jp)*annuity_fac(t)	!Salvage value (temporarily removed, should be applied for post-2050 lifetimes only)
						)] 	
					elseif (toc='Fixed Operational Cost') then
						sum[(t), techStock(t,p)*fom_cost(t,p)] !Fix costs
					elseif (toc='Variable Operational Cost') then
						sum[t, tech_use(t,p)*(vom_cost(t,p)+1e-6)] !Variable costs (including fuel costs)
						+sum[(h,thin), tech_useHourly(h,thin,p)*(vom_interconnected_hourly(h,thin,p)+1e-6)]!Electricity costs of interconnected nodes
						+sum[(h,t), (deltaU_CHP(h,t,p)+deltaS_shed(h,t,p))*vom_cost(t,p)] !Deviations in tech use due to flexibility
					elseif (toc='Total Cost') then
						+sum[(t,jp), InvMat_lifeTime(t,jp,ps)*						!lifetime matrix
						(cap_investments(t,jp)*inv_cost(t,jp)*CRF(t)				!New invetments
						+sum[(it,jt), retrofitting(it,jt,ps)*CRF(jt)*(retro_cost(it,jt)+p_epsilon)] !Retrofitting costs (based on Excel database input)
						!-eco_decommisioning(t,jp)*(1-salvage_value(t))*inv_cost(t,jp)*annuity_fac(t)	!Salvage value (temporarily removed, should be applied for post-2050 lifetimes only)
						)] 
						+sum[(t), techStock(t,p)*fom_cost(t,p)] !Fix costs
						+sum[t, tech_use(t,p)*(vom_cost(t,p)+1e-6)] !Variable costs (including fuel costs)
						+sum[(h,thin), tech_useHourly(h,thin,p)*(vom_interconnected_hourly(h,thin,p)+1e-6)]!Electricity costs of interconnected nodes
						+sum[(h,t), (deltaU_CHP(h,t,p)+deltaS_shed(h,t,p))*vom_cost(t,p)] !Deviations in tech use due to flexibility
					endif
				}
			}
			Parameter InvMat_lifeTime {
				IndexDomain: (t,jp,p);
				Definition: (p<=jp+ec_lifetime(t))*(p>=jp);
			}
			Parameter capitalCosts_techBal {
				IndexDomain: (n,tb,p);
				Definition: {
					!sum[(pa,ip) | ip<=p, Pcap_investments(tn,ip)*InvMat_lifeTime(tn,pa,ip)*inv_cost(tn,pa)*annuity_fac(tn)]
					(nodePer_techBal(tb)=n)*(
					(techStock_exist(tb)-sum[jp | jp<=p, decom_planned(tb,jp)])*inv_cost(tb,base_year)*CRF(tb)	!Existing stock
					+sum[(jp), InvMat_lifeTime(tb,jp,p)*						!lifetime matrix
							(Pcap_investments(tb,jp)*inv_cost(tb,jp)*CRF(tb)				!New invetments
							+sum[(it), Pretrofitting(it,tb,jp)*CRF(tb)*(retro_cost(it,tb)+p_epsilon)] !Retrofitting costs (based on Excel database input)
							!-Peco_decommisioning(tb,jp)*(1-salvage_value(tb))*inv_cost(tb,jp)*annuity_fac(tb)	!Salvage value (temporarily removed, should be applied for post-2050 lifetimes only)
							)] 
							)
				}
			}
			Parameter capitalCosts_techInfra {
				IndexDomain: (n,ti,p);
				Definition: {
					!sum[(pa,ip) | ip<=p, Pcap_investments(tn,ip)*InvMat_lifeTime(tn,pa,ip)*inv_cost(tn,pa)*annuity_fac(tn)]
					(nodePer_techInfra(ti)=n)*(
					(techStock_exist(ti)-sum[jp | jp<=p, decom_planned(ti,jp)])*inv_cost(ti,base_year)*CRF(ti)	!Existing stock
					+sum[(jp), InvMat_lifeTime(ti,jp,p)*						!lifetime matrix
							(Pcap_investments(ti,jp)*inv_cost(ti,jp)*CRF(ti)				!New invetments
							+sum[(it), Pretrofitting(it,ti,jp)*CRF(ti)*(retro_cost(it,ti)+p_epsilon)] !Retrofitting costs (based on Excel database input)
							!-Peco_decommisioning(ti,jp)*(1-salvage_value(ti))*inv_cost(ti,jp)*CRF(ti)	!Salvage value (temporarily removed, should be applied for post-2050 lifetimes only)
							)])
				}
			}
			Parameter fuelCosts_tech {
				IndexDomain: (n,tb,p);
				Definition: {
					(nodePer_techBal(tb)=n)*
					sum[(h,ae), -Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ae,p)*EnergyCosts(h,ae,p)*(activity_balances(tb,ae,p)<0)]
				}
			}
			Parameter nationalPrimary_energyCost {
				IndexDomain: (n,tb,p);
				Definition: Ptech_useNet(tb,p)*vom_cost(tb,p)*(nodePer_techBal(tb)=n)*(tech_category(tb)="Primary")*(1-(tb in tech_imports));
			}
			Parameter emissionCosts_tech {
				IndexDomain: (n,tb,p);
				Definition: {
					(nodePer_techBal(tb)=n)*
					sum[(h,ac), -Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ac,p)*EmissionCosts(ac,p)]
				}
			}
			Parameter exportCosts_act {
				IndexDomain: (n,ae,p);
				Definition: {
					!Yearly activities
					(dispatchType_act(ae)='yearly')*final_activities(n,ae,p)*EnergyCosts_yearly(ae,p)
					
					!Daily activities
					-sum[(d,tb), (dispatchType_act(ae)='daily')*(nodePer_techBal(tb)<>n)*(nodePer_act(ae)=n)*(activity_balances(tb,ae,p)<0) !Technologies that are taking energy from other nodes
					*Ptech_useDailyNet(d,tb,p)*activity_balances(tb,ae,p)*EnergyCosts_daily(d,ae,p)]
					
					!Hourly activities
					-sum[(h,tb), (dispatchType_act(ae)='hourly')*(nodePer_techBal(tb)<>n)*(nodePer_act(ae)=n)*(activity_balances(tb,ae,p)<0) !Technologies that are taking energy from other nodes
					*Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ae,p)*EnergyCosts_hourly(h,ae,p)]
				}
			}
			Parameter exportCosts_tech {
				IndexDomain: (n,tb,p);
				Definition: {
					!Yearly activities
					sum[ae, (dispatchType_act(ae)='yearly')*final_activities(n,ae,p)*EnergyCosts_yearly(ae,p)*EnergyShare_tech(n,ae,tb,p)]
					
					!Daily activities
					-sum[(d,ae), (dispatchType_act(ae)='daily')*(nodePer_techBal(tb)<>n)*(nodePer_act(ae)=n)*(activity_balances(tb,ae,p)<0) !Technologies that are taking energy from other nodes
					*Ptech_useDailyNet(d,tb,p)*activity_balances(tb,ae,p)*EnergyCosts_daily(d,ae,p)]
					
					!Hourly activities
					-sum[(h,ae), (dispatchType_act(ae)='hourly')*(nodePer_techBal(tb)<>n)*(nodePer_act(ae)=n)*(activity_balances(tb,ae,p)<0) !Technologies that are taking energy from other nodes
					*Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ae,p)*EnergyCosts_hourly(h,ae,p)]
				}
			}
			Parameter importCosts_act {
				IndexDomain: (n,ae,p);
				Definition: {
					!Yearly activities
					sum[tb, (activityPer_tech(tb)=ae)*Ptech_useNet(tb,p)*vom_cost(tb,p)*(nodePer_techBal(tb)=n)*(tb in tech_imports)]
					
					!Daily activities
					-sum[(d,tb), (dispatchType_act(ae)='daily')*(nodePer_techBal(tb)=n)*(nodePer_act(ae)<>n)*(activity_balances(tb,ae,p)<0) !Technologies that are taking energy from other nodes
					*Ptech_useDailyNet(d,tb,p)*activity_balances(tb,ae,p)*EnergyCosts_daily(d,ae,p)]
					
					!Hourly activities
					-sum[(h,tb), (dispatchType_act(ae)='hourly')*(nodePer_techBal(tb)=n)*(nodePer_act(ae)<>n)*(activity_balances(tb,ae,p)<0) !Technologies that are taking energy from other nodes
					*Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ae,p)*EnergyCosts_hourly(h,ae,p)]
				}
			}
			Parameter importCosts_tech {
				IndexDomain: (n,tb,p);
				Definition: {
					!Yearly activities
					Ptech_useNet(tb,p)*vom_cost(tb,p)*(nodePer_techBal(tb)=n)*(tb in tech_imports)
					
					!Daily activities
					-sum[(d,ae), (dispatchType_act(ae)='daily')*(nodePer_techBal(tb)=n)*(nodePer_act(ae)<>n)*(activity_balances(tb,ae,p)<0) !Technologies that are taking energy from other nodes
					*Ptech_useDailyNet(d,tb,p)*activity_balances(tb,ae,p)*EnergyCosts_daily(d,ae,p)]
					
					!Hourly activities
					-sum[(h,ae), (dispatchType_act(ae)='hourly')*(nodePer_techBal(tb)=n)*(nodePer_act(ae)<>n)*(activity_balances(tb,ae,p)<0) !Technologies that are taking energy from other nodes
					*Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ae,p)*EnergyCosts_hourly(h,ae,p)]
				}
			}
			Parameter SystemCosts_techBal {
				IndexDomain: (n,toc,tb,p);
				Definition: {
					if (toc='Capital Cost') then
						capitalCosts_techBal(n,tb,p)*(nodePer_techBal(tb)=n)
					elseif (toc='Fixed Operational Cost') then
						PtechStock(tb,p)*fom_cost(tb,p)*(nodePer_techBal(tb)=n)
					elseif (toc='Variable Operational Cost') then
						Ptech_useNet(tb,p)*vom_cost(tb,p)*(tech_category(tb)<>"Primary")*(1-(tb in tech_imports))*(nodePer_techBal(tb)=n)
					elseif (toc='National Primary Energy Cost') then
						nationalPrimary_energyCost(n,tb,p)	
					elseif (toc='Import Cost') then
						importCosts_tech(n,tb,p)
					elseif (toc='Export Revenues') then !'National Primary Energy Cost','Import Cost','Export Revenues'
						-exportCosts_tech(n,tb,p)
					elseif (toc='Total Cost') then
						capitalCosts_techBal(n,tb,p)*(nodePer_techBal(tb)=n)
						+PtechStock(tb,p)*fom_cost(tb,p)*(nodePer_techBal(tb)=n)
						+Ptech_useNet(tb,p)*vom_cost(tb,p)*(tech_category(tb)<>"Primary")*(1-(tb in tech_imports))*(nodePer_techBal(tb)=n)
						+nationalPrimary_energyCost(n,tb,p)
						+importCosts_tech(n,tb,p) 
						-exportCosts_tech(n,tb,p)
					endif
				}
			}
			Parameter SystemCosts_techInfra {
				IndexDomain: (n,toc,ti,p);
				Definition: {
					if (toc='Capital Cost') then
						capitalCosts_techInfra(n,ti,p)*(nodePer_techInfra(ti)=n)
					elseif (toc='Fixed Operational Cost') then
						PtechStock(ti,p)*fom_cost(ti,p)*(nodePer_techInfra(ti)=n)
					elseif (toc='Total Cost') then
						capitalCosts_techInfra(n,ti,p)*(nodePer_techInfra(ti)=n)
						+PtechStock(ti,p)*fom_cost(ti,p)*(nodePer_techInfra(ti)=n)
					endif
				}
			}
			Parameter SystemCosts {
				IndexDomain: (n,tots,toc,p);
				Definition: {
					if (tots='Balancing') then
						sum[tb, SystemCosts_techBal(n,toc,tb,p)] 
					elseif (tots='Infrastructure') then
						sum[ti, SystemCosts_techInfra(n,toc,ti,p)]
					endif
				}
			}
			Parameter SystemCosts_sec {
				IndexDomain: (n,z,tots,toc,p);
				Definition: {
					if (tots='Balancing') then
						if (toc<>'Fuel Costs' and toc<>'Emission Costs' and toc<>'Total Cost') then
							sum[tb, SystemCosts_techBal(n,toc,tb,p)*(tech_sector(tb)=z)]
						elseif (toc='Fuel Costs') then
							sum[tb,fuelCosts_tech(n,tb,p)*(tech_subsector(tb)<>"XC Trade")*(tech_sector(tb)=z)]
						elseif (toc='Emission Costs') then
							sum[tb,emissionCosts_tech(n,tb,p)*(tech_sector(tb)=z)]
						elseif (toc='Total Cost') then
							sum[tb, SystemCosts_techBal(n,'Capital Cost',tb,p)*(tech_sector(tb)=z)]
							+sum[tb, SystemCosts_techBal(n,'Fixed Operational Cost',tb,p)*(tech_sector(tb)=z)]
							+sum[tb, SystemCosts_techBal(n,'Variable Operational Cost',tb,p)*(tech_sector(tb)=z)]
							+sum[tb, SystemCosts_techBal(n,'Trading Costs',tb,p)*(tech_sector(tb)=z)]
							+sum[tb,(fuelCosts_tech(n,tb,p)-importCosts_tech(n,tb,p))*(tech_sector(tb)=z)]
							+sum[tb,emissionCosts_tech(n,tb,p)*(tech_sector(tb)=z)]
						endif
					elseif (tots='Infrastructure') then
						sum[ti, SystemCosts_techInfra(n,toc,ti,p)*(tech_sector(ti)=z)]
					endif
				}
			}
			Parameter SystemCosts_act {
				IndexDomain: (n,z,as,tots,toc,p);
				Definition: {
					if (tots='Balancing') then
						if (toc<>'Fuel Costs' and toc<>'Emission Costs' and toc<>'Total Cost') then
							sum[tb, SystemCosts_techBal(n,toc,tb,p)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)]
						elseif (toc='Fuel Costs') then
							sum[tb,(fuelCosts_tech(n,tb,p)-importCosts_tech(n,tb,p))*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)]
						elseif (toc='Emission Costs') then
							sum[tb,emissionCosts_tech(n,tb,p)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)]
						elseif (toc='Total Cost') then
							sum[tb, SystemCosts_techBal(n,'Capital Cost',tb,p)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)]
							+sum[tb, SystemCosts_techBal(n,'Fixed Operational Cost',tb,p)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)]
							+sum[tb, SystemCosts_techBal(n,'Variable Operational Cost',tb,p)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)]
							+sum[tb, SystemCosts_techBal(n,'Trading Costs',tb,p)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)]
							+sum[tb,(fuelCosts_tech(n,tb,p)-importCosts_tech(n,tb,p))*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)]
							+sum[tb,emissionCosts_tech(n,tb,p)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)]
						endif
					elseif (tots='Infrastructure') then
						sum[ti, SystemCosts_techInfra(n,toc,ti,p)*(tech_sector(ti)=z)*(infra_activity(ti)=as)]
					endif
				}
			}
			Parameter decPayments_techBal {
				IndexDomain: (n,top,tb,p);
				Definition: {
					if (top='Investment') then
						Pcap_investments(tb,p)*inv_cost(tb,p)*(nodePer_techBal(tb)=n)
					elseif (top='Decommisioning') then
						0
						!Peco_decommisioning(tb,p)*inv_cost(tb,p)*salvage_value(tb)*(nodePer_techBal(tb)=n)		!Salvage value (temporarily removed, should be applied for post-2050 lifetimes only)
					elseif (top='Retrofitting') then
						sum[it, Pretrofitting(it,tb,p)*(retro_cost(it,tb))]*(nodePer_techBal(tb)=n)	!Retrofitting costs (based on Excel database input) 
					elseif (top='Operational') then
						PtechStock(tb,p)*fom_cost(tb,p)*(nodePer_techBal(tb)=n)
					elseif (top='Variable') then
						Ptech_use(tb,p)*vom_cost(tb,p)*(nodePer_techBal(tb)=n) !Variable costs (including fuel costs)
						+sum[h, PdeltaU_CHP(h,tb,p)+PdeltaS_shed(h,tb,p)]*vom_cost(tb,p)*(nodePer_techBal(tb)=n) !Deviations in tech use due to flexibility
					endif
				}
			}
			Parameter decPayments_techInfra {
				IndexDomain: (n,top,ti,p);
				Definition: {
					if (top='Investment') then
						Pcap_investments(ti,p)*inv_cost(ti,p)*(nodePer_techInfra(ti)=n)
					elseif (top='Decommisioning') then
						0
						!Peco_decommisioning(tb,p)*inv_cost(tb,p)*salvage_value(tb)*(nodePer_techBal(tb)=n)		!Salvage value (temporarily removed, should be applied for post-2050 lifetimes only)
					elseif (top='Retrofitting') then
						sum[it, Pretrofitting(it,ti,p)*(retro_cost(it,ti))]*(nodePer_techInfra(ti)=n)	!Retrofitting costs (based on Excel database input)
					elseif (top='Operational') then
						PtechStock(ti,p)*fom_cost(ti,p)*(nodePer_techInfra(ti)=n)
					endif
				}
			}
			Parameter decPayments {
				IndexDomain: (n,tots,top,p);
				Definition: {
					if (tots='Balancing') then
						sum[tb, decPayments_techBal(n,top,tb,p)] 
					elseif (tots='Infrastructure') then
						sum[ti, decPayments_techInfra(n,top,ti,p)]
					endif
				}
			}
			Parameter SystemCosts_n {
				IndexDomain: (nn,toc,ps);
				Definition: sum[(tots,n), SystemCosts(n,tots,toc,ps)*(namePer_node(n)=nn)*IEM_node(n)];
			}
			Parameter SystemCosts_sec_n {
				IndexDomain: (nn,z,tots,toc,p);
				Definition: sum[n, SystemCosts_sec(n,z,tots,toc,p)*(namePer_node(n)=nn)*IEM_node(n)]*(toc<>'Total Cost');
			}
			Parameter LCOP_secE {
				IndexDomain: (nn,z,tots,toc,p);
				Definition: {
					((z='Power NL')+(z='Refineries')+(z='Heat Network')+(z='Final Gas')+(z='Hydrogen')+(z='Ammonia'))*(toc<>'Trading Costs')*
					SystemCosts_sec_n(nn,z,tots,toc,p)/(sum[as, output_actMain(nn,z,as,p)]+1e-20)
				}
			}
			Parameter SystemCosts_act_n {
				IndexDomain: (nn,z,as,tots,toc,p);
				Definition: sum[n, SystemCosts_act(n,z,as,tots,toc,p)*(namePer_node(n)=nn)*IEM_node(n)]*(toc<>'Total Cost');
			}
			Parameter LCOP_act {
				IndexDomain: (nn,z,as,tots,toc,p);
				Definition: (toc<>'Trading Costs')*SystemCosts_act_n(nn,z,as,tots,toc,p)/(output_actMain(nn,z,as,p)+1e-20);
			}
			Parameter SystemCosts_sec_tot {
				IndexDomain: (nn,z,p);
				Definition: sum[(tots,toc), SystemCosts_sec_n(nn,z,tots,toc,p)*IEM_sector(z)];
			}
			Parameter SectoralCosts_cascade {
				IndexDomain: (nn,z,toc,pnz);
				Definition: {
					if (pnz=element(periods_nonzeros,1)) then
						sum[tots, SystemCosts_sec_n(nn,z,tots,toc,pnz)]
					else
						sum[tots, SystemCosts_sec_n(nn,z,tots,toc,pnz)]-sum[tots, SystemCosts_sec_n(nn,z,tots,toc,element(periods_nonzeros,1))]
					endif
				}
			}
			Parameter Revenue_tech {
				IndexDomain: (n,tb,tn,ps);
				Definition: {
					
					!Hourly activities
						(nodePer_techBal(tb)=n)*(tech_name(tb)=tn)*(
						!Revenue
							sum[(h,ae) | (activity_balances(tb,ae,ps)>0)*(activityPer_tech(tb)<>'Electricity NL - HVNS'), Ptech_useHourlyNet(h,tb,ps)*EnergyCosts_hourly(h,ae,ps)]
							+sum[(h,ae) | (activity_balances(tb,ae,ps)>0)*(activityPer_tech(tb)='Electricity NL - HVNS'), Ptech_useHourlyNet(h,tb,ps)*EnergyCosts_hourly(h,'Electricity NL - HV',ps)]
						!Costs
					
							-capitalCosts_techBal(n,tb,ps)													!CAPEX
							-PtechStock(tb,ps)*fom_cost(tb,ps)												!FOM
							-sum[(h,ae) | (activity_balances(tb,ae,ps)<0), Ptech_useHourlyNet(h,tb,ps)*vom_cost(tb,ps)]					!VOM
							-fuelCosts_tech(n,tb,ps)													!Fuel costs
						)																
					
					
					
					!
					!!Yearly activities
					!sum[ae, (dispatchType_act(ae)='yearly')*final_activities(n,ae,p)*EnergyCosts_yearly(ae,p)*EnergyShare_tech(n,ae,tb,p)]
					!
					!!Daily activities
					!-sum[(d,ae), (dispatchType_act(ae)='daily')*(nodePer_techBal(tb)<>n)*(nodePer_act(ae)=n)*(activity_balances(tb,ae,p)<0) !Technologies that are taking energy from other nodes
					!*Ptech_useDailyNet(d,tb,p)*activity_balances(tb,ae,p)*EnergyCosts_daily(d,ae,p)]
				}
			}
		}
		DeclarationSection Configuration {
			Set typesOf_planningDecisions {
				Index: topd, itopd, jtopd;
				Definition: {
					{'Investment','Retrofitting additions','Retrofitting substractions','Economic decommissioning'}
				}
			}
			Parameter SectoralConfiguration_stock {
				IndexDomain: (nn,z,as,tots,t,p);
				Definition: {
					if (tots='Balancing') then
						PtechStock(t,p)
						*(tech_sector(t)=z)
						*(activityPer_tech(t)=as)
						*IEM_node(nodePer_techBal(t))
						*(t in tech_balancers)
						*(namePer_node(nodePer_techBal(t))=nn)
					elseif(tots='Infrastructure') then
						PtechStock(t,p)
						*(tech_sector(t)=z)
						*(infra_activity(t)=as)
						*IEM_node(nodePer_techInfra(t))
						*(t in tech_infra)
						*(namePer_node(nodePer_techInfra(t))=nn)
					endif
				}
			}
			Parameter SectoralConfiguration_use {
				IndexDomain: (nn,z,as,tots,t,p);
				Definition: {
					if (tots='Balancing') then
						Ptech_useNet(t,p)
						*(tech_sector(t)=z)
						*(activityPer_tech(t)=as)
						!*IEM_node(nodePer_techBal(t))
						*(t in tech_balancers)
						*(namePer_node(nodePer_techBal(t))=nn)
					elseif(tots='Infrastructure') then
						Ptech_useNet(t,p)
						*(tech_sector(t)=z)
						*(infra_activity(t)=as)
						!*IEM_node(nodePer_techInfra(t))
						*(t in tech_infra)
						*(namePer_node(nodePer_techInfra(t))=nn)
					endif
				}
			}
			Parameter EnergyShare_tech {
				IndexDomain: (n,ae,tb,p);
				Definition: {
					(nodePer_techBal(tb)=n)*(activity_balances(tb,ae,p)>0)*Ptech_useNet(tb,p)*activity_balances(tb,ae,p)
					/sum[(itb), (nodePer_techBal(tb)=n)*(activity_balances(itb,ae,p)>0)*Ptech_useNet(itb,p)*activity_balances(itb,ae,p)+1e-9]
				}
			}
			Parameter PlanningDecisions_tech {
				IndexDomain: (nn,t,topd,p);
				Definition: {
					if (topd='Investment') then
						((t in tech_balancers)*IEM_node(nodePer_techBal(t))*(namePer_node(nodePer_techBal(t))=nn)
						+(t in tech_infra)*IEM_node(nodePer_techInfra(t))*(namePer_node(nodePer_techInfra(t))=nn))
						*Pcap_investments(t,p)
					elseif (topd='Retrofitting additions') then
						((t in tech_balancers)*IEM_node(nodePer_techBal(t))*(namePer_node(nodePer_techBal(t))=nn)
						+(t in tech_infra)*IEM_node(nodePer_techInfra(t))*(namePer_node(nodePer_techInfra(t))=nn))
						*sum[it, Pretrofitting(it,t,p)]
					elseif (topd='Retrofitting substractions') then
						-((t in tech_balancers)*IEM_node(nodePer_techBal(t))*(namePer_node(nodePer_techBal(t))=nn)
						+(t in tech_infra)*IEM_node(nodePer_techInfra(t))*(namePer_node(nodePer_techInfra(t))=nn))
						*sum[jt, Pretrofitting(t,jt,p)]
					elseif (topd='Economic decommissioning') then
						-((t in tech_balancers)*IEM_node(nodePer_techBal(t))*(namePer_node(nodePer_techBal(t))=nn)
						+(t in tech_infra)*IEM_node(nodePer_techInfra(t))*(namePer_node(nodePer_techInfra(t))=nn))
						*Peco_decommisioning(t,p)
					endif
				}
			}
		}
		DeclarationSection Power_sector {
			Set electricity_activities {
				SubsetOf: activities_hour;
				Index: ahee, iahee, jahee;
				Definition: {
					{ah | labelPer_act(ah)='Electricity'}
				}
			}
			Set typeOf_PowerInfo {
				Index: topi, itopi, jtopi;
				Definition: {
					{'Stock','Use'}
				}
			}
			ElementParameter sourcePer_line {
				IndexDomain: th;
				Range: activities_solve;
				Definition: {
					actSolvePer_actOrig(first({ao | activity_balancesRef(th,ao)*(tech_subsector(th)="XC Trade")<0})) !(Hardcode)
				}
			}
			Parameter Power_dispatch {
				IndexDomain: (nn,h,tb,p);
				InitialData: 0;
			}
			Parameter Power_stock {
				IndexDomain: (nn,tb,p);
				Definition: {
					PtechStock(tb,p)
					*(tech_subsector(tb)="Generation") !(Hardcode)
					*(namePer_node(nodePer_techBal(tb))=nn)
					*IEM_node(nodePer_techBal(tb))
				}
			}
			Parameter Power_gen {
				IndexDomain: (nn,tb,p);
				Definition: {
					Ptech_use(tb,p)
					*(tech_subsector(tb)="Generation") !(Hardcode)
					*(namePer_node(nodePer_techBal(tb))=nn)
					*IEM_node(nodePer_techBal(tb))
				}
			}
			Parameter XC_stock {
				IndexDomain: (inn,nn,tb,p);
				Definition: {
					PtechStock(tb,p)
					*(tech_subsector(tb)="XC Trade") !(Hardcode)
					*(namePer_node(nodePer_techBal(tb))=nn)
					*(namePer_node(nodePer_act(sourcePer_line(tb)))=inn)
				}
			}
			Parameter XC_use {
				IndexDomain: (inn,nn,tb,p);
				Definition: {
					Ptech_use(tb,p)
					*(tech_subsector(tb)="XC Trade") !(Hardcode)
					*(namePer_node(nodePer_techBal(tb))=nn)
					*(namePer_node(nodePer_act(sourcePer_line(tb)))=inn)
				}
			}
			Parameter PowerInfo_act {
				IndexDomain: (ahee,topi,tb,p);
				Definition: {
					!(HARDCODED)
					if (topi='Stock') then
						PtechStock(tb,p)*(activityPer_tech(tb)=ahee)*(tech_subsector(tb)="Generation")
						+PtechStock(tb,p)*(activityPer_tech(tb)=ahee)*(tech_subsector(tb)="Storage")
					elseif (topi='Use') then
						Ptech_useNet(tb,p)*(activityPer_tech(tb)=ahee)*(tech_subsector(tb)="Generation")
						+sum[h, PdeltaQ_DW(h,tb,p)]*(activityPer_tech(tb)=ahee)*(tech_subsector(tb)="Storage")
					endif
				}
			}
			Parameter XCinfo_act {
				IndexDomain: (iahee,ahee,topi,tb,p);
				Definition: {
					!(HARDCODED)
					if (topi='Stock') then
						PtechStock(tb,p)
						*(tech_subsector(tb)="XC Trade") !(Hardcode)
						*(activityPer_tech(tb)=ahee)
						*(sourcePer_line(tb)=iahee)
					elseif (topi='Use') then
						Ptech_useNet(tb,p)
						*(tech_subsector(tb)="XC Trade") !(Hardcode)
						*(activityPer_tech(tb)=ahee)
						*(sourcePer_line(tb)=iahee)
					endif
				}
			}
			Parameter CHP_output {
				IndexDomain: (tk,ae,p);
				Definition: {
					!(activity_balances(tk,ae,p)>0)*
					Ptech_useNet(tk,p)*activity_balances(tk,ae,p)
				}
			}
			Parameter CHP_input {
				IndexDomain: (tk,ae,p);
				Definition: {
					(activity_balances(tk,ae,p)>0)*
					Ptech_useNet(tk,p)*activity_balances(tk,ae,p)
				}
			}
		}
		DeclarationSection Emissions {
			Parameter emissions_all {
				IndexDomain: (nn,t_c,p);
				Definition: (namePer_node(nodePer_techBal(t_c))=nn)*Ptech_useNet(t_c,p)*IEM_node(nodePer_techBal(t_c));
			}
			Parameter emissions_sec {
				IndexDomain: (nn,z,aer,p);
				Definition: {
					sum[tb, (namePer_node(nodePer_techBal(tb))=nn)*(tech_sector(tb)=z)*Ptech_useNet(tb,p)*activity_balances(tb,aer,p)*IEM_node(nodePer_techBal(tb))]   ! Sectoral emissions
				}
			}
			Parameter emissions_sec_kev {
				IndexDomain: (nn,zk,aer,p);
				Definition: {
					sum[tb, (namePer_node(nodePer_techBal(tb))=nn)*(tech_sector_kev(tb)=zk)*Ptech_useNet(tb,p)*activity_balances(tb,aer,p)*IEM_node(nodePer_techBal(tb))]   ! Sectoral emissions
				}
			}
			Parameter emissions_act {
				IndexDomain: (nn,z,as,aer,p);
				Definition: {
					sum[tb, (namePer_node(nodePer_techBal(tb))=nn)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)*Ptech_useNet(tb,p)*activity_balances(tb,aer,p)]
					!sum[tb, (namePer_node(nodePer_techBal(tb))=nn)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)*Ptech_useNet(tb,p)*activity_balances(tb,aer,p)*IEM_node(nodePer_techBal(tb))]
				}
			}
			Parameter emissions_tech {
				IndexDomain: (nn,z,as,tb,tn,aer,p);
				Definition: (namePer_node(nodePer_techBal(tb))=nn)*(tech_sector(tb)=z)*(tech_name(tb)=tn)*(activityPer_tech(tb)=as)*Ptech_useNet(tb,p)*activity_balances(tb,aer,p)*IEM_node(nodePer_techBal(tb));
			}
			Parameter emissions_tech_kev {
				IndexDomain: (nn,zk,as,tb,tn,aer,p);
				Definition: (namePer_node(nodePer_techBal(tb))=nn)*(tech_sector_kev(tb)=zk)*(tech_name(tb)=tn)*(activityPer_tech(tb)=as)*Ptech_useNet(tb,p)*activity_balances(tb,aer,p)*IEM_node(nodePer_techBal(tb));
			}
			Parameter emissions_scope1_cum {
				IndexDomain: ni;
				Definition: {
					!The sum of the use of all the emissions released to air in each node
					sum[(tb,act,ps), Ptech_use(tb,ps)*(nodePer_act(activityPer_tech(tb))=ni)*activity_balances(tb,act,ps)*period_weight(ps)*transition_interval]
					!sum[(tb,ps), Ptech_use(tb,ps)*(nodePer_act(activityPer_tech(tb))=ni)*(activityPer_tech(tb) in activities_target)*period_weightUSE(ps)*transition_interval]
				}
			}
			Parameter emissions_inclFeedStocks_cum {
				IndexDomain: ni;
				Definition: {
					!The sum of the use of all the emissions released to air in each node
					sum[(tb,atf,ps), Ptech_use(tb,ps)*(nodePer_act(activityPer_tech(tb))=ni)*activity_balances(tb,atf,ps)*period_weight(ps)*transition_interval]
					+sum[(tb,act,ps), Ptech_use(tb,ps)*(nodePer_act(activityPer_tech(tb))=ni)*activity_balances(tb,act,ps)*period_weight(ps)*transition_interval]
					!sum[(tb,ps), Ptech_use(tb,ps)*(nodePer_act(activityPer_tech(tb))=ni)*(activityPer_tech(tb) in activities_target)*period_weightUSE(ps)*transition_interval]
				}
			}
			Parameter CO2_stored_cumulative {
				IndexDomain: ni;
				Definition: sum[(tb,ps), Ptech_use(tb,ps)*(tech_subsector(tb)="CCUS Storage")*period_weight(ps)*transition_interval];
			}
			Parameter emissions_cum {
				IndexDomain: n;
				Definition: {
					!The sum of the use of all the emissions released to air in each node
					sum[(tb,ps), Ptech_use(tb,ps)*(nodePer_act(activityPer_tech(tb))=n)*(activityPer_tech(tb) in activities_target)*period_weight(ps)*transition_interval]
				}
			}
		}
		DeclarationSection Balances {
			Set typesOf_balances {
				Index: tob, itob, jtob;
				Definition: {
					{'supply','demand'}
				}
			}
			Set typesOf_decomposition {
				Index: tod, itod, jtod;
				Definition: {
					{'Net Primary','Net energy transformations','Total final incl. bunkers','Int. Transport',
					'Total final excl. bunkers','Feedstock','Final energy use','Final Losses','Electricity final','Electricity total'}
				}
			}
			Set typesOf_final {
				Index: tof, itof, jtof;
				Definition: {
					{'Energy Use','Feedstock'}
				}
			}
			Set typesOf_primaryEnergy {
				Index: tope, itope, jtope;
				Definition: {
					{'Total','Exports','Net'}
				}
			}
			Set typesOf_sankeyElements {
				SubsetOf: set_of_everything;
				Index: tos, itos, jtos;
			}
			Set typesOf_use {
				Index: tou, itou, jtou;
				Definition: {
					{'Primary','Conversion','Final','Exports','Losses'}
				}
			}
			Set international_transport {
				SubsetOf: activities_solve;
				Definition: {
					if (ord('CO2 Air Int. Transport',activities_solve)<>0) then
						{as | sum[(tb,p) | (activityPer_tech(tb)=as), activity_balances(tb,'CO2 Air Int. Transport',p)]>0}
					endif
				}
			}
			Parameter final_activities {
				IndexDomain: (n,as,p);
				Definition: {
					(nodePer_act(as)=n)*(
					sum[t, (nodePer_techBal(t)=n)*Ptech_use(t,p)*activity_balances(t,as,p)]+  !Reference activity balance
					sum[tf, sum[h, (nodePer_techBal(tf)=n)*(PdeltaQ_UP(h,tf,p)+PdeltaQ_DW(h,tf,p))]*dQ_hourly(tf,as)]+ !Impact of flexibility in hourly activities
					sum[tk, sum[h, (nodePer_techBal(tk)=n)*PdeltaU_CHP(h,tk,p)]*activity_balances(tk,as,p)]+ !Impact of use deviation of CHPs
					sum[tk, sum[h, (nodePer_techBal(tk)=n)*PdeltaP_CHP(h,tk,p)]*dP_electricity(tk,as)]+ !Impact in power of power output ratio deviation of CHPs
					sum[tk, sum[h, -(nodePer_techBal(tk)=n)*CHP_eta(tk)*PdeltaP_CHP(h,tk,p)/CHP_eps(tk,p)]*dP_heat(tk,as)]+ !Impact in heat of power output ratio deviation of CHPs
					sum[ts, sum[h, (nodePer_techBal(ts)=n)*PdeltaS_shed(h,ts,p)]*activity_balances(ts,as,p)] !Impact of shedding load
					)
				}
			}
			Parameter feedstockUse_techOrig {
				IndexDomain: (t,ao);
			}
			Parameter feedstockUse_tech {
				IndexDomain: (t,as);
				Definition: feedstockUse_techOrig(t,as)+sum[iao | groupOf_activities(as,iao)=1, feedstockUse_techOrig(t,iao)];
			}
			Parameter feedstockUse_sec {
				IndexDomain: (n,z,el,p);
				Definition: sum[(tb,ae), (nodePer_techBal(tb)=n)*(tech_sector(tb)=z)*Ptech_useNet(tb,p)*feedstockUse_tech(tb,ae)*(labelPer_act(ae)=el)];
			}
			Parameter feedstockUse_sec_kev {
				IndexDomain: (n,zk,el,p);
				Definition: sum[(tb,ae), (nodePer_techBal(tb)=n)*(tech_sector_kev(tb)=zk)*Ptech_useNet(tb,p)*feedstockUse_tech(tb,ae)*(labelPer_act(ae)=el)];
			}
			Parameter feedstockUse_secAct_kev {
				IndexDomain: (n,zk,as,el,p);
				Definition: sum[(tb,ae), (nodePer_techBal(tb)=n)*(tech_sector_kev(tb)=zk)*Ptech_useNet(tb,p)*feedstockUse_tech(tb,ae)*(labelPer_act(ae)=el)*(activityPer_tech(tb)=as)];
			}
			Parameter feedstockUse_act {
				IndexDomain: (n,z,as,el,p);
				Definition: sum[(tb,ae), (nodePer_techBal(tb)=n)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)*Ptech_useNet(tb,p)*feedstockUse_tech(tb,ae)*(labelPer_act(ae)=el)];
			}
			Parameter supplyAct_tech {
				IndexDomain: (n,as,tb,tn,p);
				Definition: {
					(nodePer_techBal(tb)=n)*(tech_name(tb)=tn)*
					((activity_balances(tb,as,p)*(1-2*(as in activities_emission)))>0)
					*(Ptech_useNet(tb,p)*activity_balances(tb,as,p)+  !Reference activity balance
					sum[h, PdeltaQ_DW(h,tb,p)]*dQ_hourly(tb,as)+ !Impact of flexibility in hourly activities
					!sum[tg, sum[d, (deltaB_DW(d,tg,p)-deltaB_UP(d,tg,p))]*activity_balances(tg,as,p)]+ !Impact of gas buffers energy consumption
					sum[h, PdeltaP_CHP(h,tb,p)]*dP_electricity(tb,as)+ !Impact in power of power output ratio deviation of CHPs
					sum[h, -CHP_eta(tb)*PdeltaP_CHP(h,tb,p)/CHP_eps(tb,p)]*dP_heat(tb,as) !Impact in heat of power output ratio deviation of CHPs
					)
				}
			}
			Parameter demandAct_tech {
				IndexDomain: (n,as,tb,tn,p);
				Definition: {
					(nodePer_techBal(tb)=n)*(tech_name(tb)=tn)*
					((activity_balances(tb,as,p)*(1-2*(as in activities_emission)))<0)
					*(Ptech_useNet(tb,p)*activity_balances(tb,as,p)+  !Reference activity balance
					sum[h, PdeltaQ_DW(h,tb,p)]*dQ_hourly(tb,as)+ !Impact of flexibility in hourly activities
					!sum[tg, sum[d, (deltaB_DW(d,tg,p)-deltaB_UP(d,tg,p))]*activity_balances(tg,as,p)]+ !Impact of gas buffers energy consumption
					sum[h, PdeltaP_CHP(h,tb,p)]*dP_electricity(tb,as)+ !Impact in power of power output ratio deviation of CHPs
					sum[h, -CHP_eta(tb)*PdeltaP_CHP(h,tb,p)/CHP_eps(tb,p)]*dP_heat(tb,as) !Impact in heat of power output ratio deviation of CHPs
					)
				}
			}
			Parameter supdemAct_tech {
				IndexDomain: (nn,as,tob,tb,tn,p);
				Definition: {
					if(tob='supply') then
						sum[n, (namePer_node(n)=nn)*supplyAct_tech(n,as,tb,tn,p)]
						!sum[n, (namePer_node(n)=nn)*supplyAct_tech(n,as,tb,tn,p)*IEM_node(n)]
					elseif(tob='demand') then
						sum[n, (namePer_node(n)=nn)*demandAct_tech(n,as,tb,tn,p)]
						!sum[n, (namePer_node(n)=nn)*demandAct_tech(n,as,tb,tn,p)*IEM_node(n)]
					endif
				}
			}
			Parameter supdemAct_tech_name {
				IndexDomain: (nn,as,tob,tb,tn,p);
				Definition: {
					if(tob='supply') then
						sum[n, (namePer_node(n)=nn)*(tech_name(tb)=tn)*supplyAct_tech(n,as,tb,tn,p)]
						!sum[n, (namePer_node(n)=nn)*(tech_name(tb)=tn)*supplyAct_tech(n,as,tb,tn,p)*IEM_node(n)]
					elseif(tob='demand') then
						sum[n, (namePer_node(n)=nn)*(tech_name(tb)=tn)*demandAct_tech(n,as,tb,tn,p)]
						!sum[n, (namePer_node(n)=nn)*(tech_name(tb)=tn)*demandAct_tech(n,as,tb,tn,p)*IEM_node(n)]
					endif
				}
			}
			Parameter energyUse_tech {
				IndexDomain: (n,tb,ae,p);
				Definition: {
					(nodePer_techBal(tb)=n)*
					(Ptech_useNet(tb,p)*activity_balances(tb,ae,p)  !Reference activity balance
					+sum[h, (PdeltaQ_UP(h,tb,p)+PdeltaQ_DW(h,tb,p))]*dQ_hourly(tb,ae) !Impact of flexibility in hourly activities
					+sum[h, PdeltaP_CHP(h,tb,p)]*dP_electricity(tb,ae) !Impact in power of power output ratio deviation of CHp
					+sum[h, -CHP_eta(tb)*PdeltaP_CHP(h,tb,p)/CHP_eps(tb,p)]*dP_heat(tb,ae) !Impact in heat of power output ratio deviation of CHp
					)
				}
			}
			Parameter energyUse_sec {
				IndexDomain: (n,z,el,p);
				Definition: {
					sum[(tb,ae),(nodePer_techBal(tb)=n)*(tech_sector(tb)=z)*(labelPer_act(ae)=el)*
					(Ptech_useNet(tb,p)*activity_balances(tb,ae,p)  !Reference activity balance
					+sum[h, (PdeltaQ_UP(h,tb,p)+PdeltaQ_DW(h,tb,p))]*dQ_hourly(tb,ae) !Impact of flexibility in hourly activities
					+sum[h, PdeltaP_CHP(h,tb,p)]*dP_electricity(tb,ae) !Impact in power of power output ratio deviation of CHp
					+sum[h, -CHP_eta(tb)*PdeltaP_CHP(h,tb,p)/CHP_eps(tb,p)]*dP_heat(tb,ae) !Impact in heat of power output ratio deviation of CHp
					)]
				}
			}
			Parameter energyUse_sec_kev {
				IndexDomain: (n,zk,el,p);
				Definition: {
					sum[(tb,ae),(nodePer_techBal(tb)=n)*(tech_sector_kev(tb)=zk)*(labelPer_act(ae)=el)*
					(Ptech_useNet(tb,p)*activity_balances(tb,ae,p)  !Reference activity balance
					+sum[h, (PdeltaQ_UP(h,tb,p)+PdeltaQ_DW(h,tb,p))]*dQ_hourly(tb,ae) !Impact of flexibility in hourly activities
					+sum[h, PdeltaP_CHP(h,tb,p)]*dP_electricity(tb,ae) !Impact in power of power output ratio deviation of CHp
					+sum[h, -CHP_eta(tb)*PdeltaP_CHP(h,tb,p)/CHP_eps(tb,p)]*dP_heat(tb,ae) !Impact in heat of power output ratio deviation of CHp
					)]
				}
			}
			Parameter energyUse_tech_mat {
				IndexDomain: (n,tb,amc,p);
				Definition: {
					(nodePer_techBal(tb)=n)*
					(Ptech_useNet(tb,p)*activity_balances(tb,amc,p)  !Reference activity balance
					+sum[h, (PdeltaQ_UP(h,tb,p)+PdeltaQ_DW(h,tb,p))]*dQ_hourly(tb,amc) !Impact of flexibility in hourly activities
					+sum[h, PdeltaP_CHP(h,tb,p)]*dP_electricity(tb,amc) !Impact in power of power output ratio deviation of CHp
					+sum[h, -CHP_eta(tb)*PdeltaP_CHP(h,tb,p)/CHP_eps(tb,p)]*dP_heat(tb,amc) !Impact in heat of power output ratio deviation of CHp
					)
				}
			}
			Parameter energyUse_act {
				IndexDomain: (nn,z,as,ae,p);
				Definition: sum[(n,tb), (namePer_node(n)=nn)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)*energyUse_tech(n,tb,ae,p)];
			}
			Parameter output_actAll {
				IndexDomain: (nn,z,as,ias,p);
				Definition: {
					sum[(n,tb), (namePer_node(n)=nn)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)*(nodePer_techBal(tb)=n)*
							(activity_balances(tb,ias,p)>0)*Ptech_useNet(tb,p)*activity_balances(tb,ias,p)]
				}
			}
			Parameter output_actMain {
				IndexDomain: (nn,z,as,p);
				Definition: {
					sum[(n,tb), (namePer_node(n)=nn)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)*(nodePer_techBal(tb)=n)*
							Ptech_useNet(tb,p)*activity_balances(tb,as,p)]
				}
			}
			Parameter finalEnergy_sec {
				IndexDomain: (n,z,el,p);
				Definition: {
					sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Final')*(tech_sector(tb)=z)*(tech_subsector(tb)<>'Bunker')*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
					energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=el)] !Final enery use (non Bunker)
					
					+ sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Final')*(tech_sector(tb)='Transport')*(tech_subsector(tb)=z)*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
					energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=el)] !Final enery use (Bunker)
					
					 !below added by Kira to correct for "conversion" material processes and CCUS
					
					 !Final energy use for industrial material conversion processes
					 + sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Conversion')*(tech_sector(tb)='Industry')*(activityType_act(activityPer_tech(tb))='Material conversion')*(tech_sector(tb)=z))<>0,
					 energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=el)]
					
					!CCUS
					   + sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Emission')*(tech_sector(tb)='Industry')*(tech_sector(tb)=z))<>0,
					 (energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=el))]
				}
			}
			Parameter finalEnergy_sec_kev {
				IndexDomain: (n,zk,el,p);
				Definition: {
					sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Final')*(tech_sector_kev(tb)=zk)*(activityType_act(activityPer_tech(tb))='Driver')*(labelPer_act(ae)=el))<>0,
					energyUse_tech(n,tb,ae,p)] !Final enery use
					
					!below added by Kira to correct for "conversion" material processes and CCUS
					
					!Final enery use for industrial material conversion processes
					 + sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Conversion')*(tech_sector(tb)='Industry')*(activityType_act(activityPer_tech(tb))='Material conversion')*(tech_sector_kev(tb)=zk)*(labelPer_act(ae)=el))<>0,
					 energyUse_tech(n,tb,ae,p)]
					
					!CCUS
					 + sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Emission')*(tech_sector(tb)='Industry')*(tech_sector_kev(tb)=zk)*(labelPer_act(ae)=el))<>0,
					 energyUse_tech(n,tb,ae,p)]
				}
			}
			Parameter finalEnergy_secAct_kev {
				IndexDomain: (n,zk,as,el,p);
				Definition: {
					sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Final')*(tech_sector_kev(tb)=zk)
					*(activityType_act(activityPer_tech(tb))='Driver')*(labelPer_act(ae)=el)*(activityPer_tech(tb)=as))<>0,
					energyUse_tech(n,tb,ae,p)] !Final enery use
					
					!below added by Kira to correct for "conversion" material processes and CCUS
					
					!Final enery use for industrial material conversion processes
					 + sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Conversion')*(tech_sector(tb)='Industry')
					 *(activityType_act(activityPer_tech(tb))='Material conversion')*(tech_sector_kev(tb)=zk)*(labelPer_act(ae)=el)*(activityPer_tech(tb)=as))<>0,
					 energyUse_tech(n,tb,ae,p)]
					
					!CCUS
					 + sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Emission')*(tech_sector(tb)='Industry')
					 *(tech_sector_kev(tb)=zk)*(labelPer_act(ae)=el)*(activityPer_tech(tb)=as))<>0,
					 energyUse_tech(n,tb,ae,p)]
				}
			}
			Parameter finalEnergy_actEL {
				IndexDomain: (n,z,as,el,p);
				Definition: {
					sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Final')*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
					((activityPer_tech(tb) in international_transport)=0)* !Not in international transport
					 energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=el)] !Final enery use
					  !added by Kira to correct for "conversion" material processes and CCUS
					  + sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Conversion')*(tech_sector(tb)='Industry')*(activityPer_tech(tb)=as))*(activityType_act(activityPer_tech(tb))='Material conversion')<>0,
					 energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=el)] !Final enery use for industrial material conversion processes
					   + sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Emission')*(tech_sector(tb)='Industry')*(activityPer_tech(tb)=as))<>0,
					 energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=el)] !Final enery use for CCUS
				}
			}
			Parameter finalEnergy_actEL_kev {
				IndexDomain: (n,zk,as,el,p);
				Definition: {
					sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Final')*(tech_sector_kev(tb)=zk)*(activityPer_tech(tb)=as)
						*(activityType_act(activityPer_tech(tb))='Driver')*(labelPer_act(ae)=el))<>0,
					 	energyUse_tech(n,tb,ae,p)] !Final enery use
					
					!added by Kira to correct for "conversion" material processes and CCUS
					+ sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Conversion')*(tech_sector_kev(tb)=zk)*(tech_sector(tb)='Industry')
						*(activityPer_tech(tb)=as)*(activityType_act(activityPer_tech(tb))='Material conversion')*(labelPer_act(ae)=el))<>0,
					  	energyUse_tech(n,tb,ae,p)] !Final enery use for industrial material conversion processes
					
					+ sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Emission')*(tech_sector_kev(tb)=zk)*(tech_sector(tb)='Industry')
					   	*(activityPer_tech(tb)=as)*(labelPer_act(ae)=el))<>0,
					 	energyUse_tech(n,tb,ae,p)] !Final enery use for CCUS
				}
			}
			Parameter finalEnergy_matrix {
				IndexDomain: (nn,z,tof,el,p);
				Definition: {
					if (tof='Energy Use') then
						sum[n, (namePer_node(n)=nn)*feedstockUse_sec(n,z,el,p)]*(z<>'Waste')*(el<>'Material') !(HARDCODED)
						-sum[n, (namePer_node(n)=nn)*finalEnergy_sec(n,z,el,p)]*(z<>'Waste')*(el<>'Material') !(HARDCODED)
					elseif(tof='Feedstock') then
						-sum[n, (namePer_node(n)=nn)*feedstockUse_sec(n,z,el,p)]*(z<>'Waste')*(el<>'Material') !(HARDCODED)
					endif
					!edited by Kira to correct for material flows
				}
			}
			Parameter finalEnergy_matrix_kev {
				IndexDomain: (nn,zk,tof,el,p);
				Definition: {
					if (tof='Energy Use') then
						sum[n, (namePer_node(n)=nn)*feedstockUse_sec_kev(n,zk,el,p)] 
						-sum[n, (namePer_node(n)=nn)*finalEnergy_sec_kev(n,zk,el,p)] 
					elseif(tof='Feedstock') then
						-sum[n, (namePer_node(n)=nn)*feedstockUse_sec_kev(n,zk,el,p)] 
					endif
				}
				Comment: "Amir: el=\"Material\" is rmeoved, since all corrections have already been made in finalEnergy_sec_kev.";
			}
			Parameter finalEnergy_matrixAct_kev {
				IndexDomain: (nn,zk,as,tof,el,p);
				Definition: {
					if (tof='Energy Use') then
						sum[n, (namePer_node(n)=nn)*feedstockUse_secAct_kev(n,zk,as,el,p)] 
						-sum[n, (namePer_node(n)=nn)*finalEnergy_secAct_kev(n,zk,as,el,p)] 
					elseif(tof='Feedstock') then
						-sum[n, (namePer_node(n)=nn)*feedstockUse_secAct_kev(n,zk,as,el,p)] 
					endif
				}
				Comment: "Amir: el=\"Material\" is rmeoved, since all corrections have already been made in finalEnergy_sec_kev.";
			}
			Parameter finalEnergy_matrixAct {
				IndexDomain: (nn,z,as,tof,el,p);
				Definition: {
					if (tof='Energy Use') then
						sum[n, (namePer_node(n)=nn)*feedstockUse_act(n,z,as,el,p)]*(z<>'Waste')*(el<>'Material')*(activityType_act(as)='Driver') !(HARDCODED)
						-sum[n, (namePer_node(n)=nn)*finalEnergy_actEL(n,z,as,el,p)]*(z<>'Waste')*(el<>'Material')*(activityType_act(as)='Driver') !(HARDCODED)
						+ sum[n, (namePer_node(n)=nn)*feedstockUse_act(n,z,as,el,p)]*(z='Industry')*(el<>'Material')*(activityType_act(as)='Material conversion') !(HARDCODED)
						-sum[n, (namePer_node(n)=nn)*finalEnergy_actEL(n,z,as,el,p)]*(z='Industry')*(el<>'Material')*(activityType_act(as)='Material conversion') !(HARDCODED)
						+ sum[n, (namePer_node(n)=nn)*feedstockUse_act(n,z,as,el,p)]*(z='Industry')*(el<>'Material')*(activityType_act(as)='Emission') !(HARDCODED)
						-sum[n, (namePer_node(n)=nn)*finalEnergy_actEL(n,z,as,el,p)]*(z='Industry')*(el<>'Material')*(activityType_act(as)='Emission') !(HARDCODED)
					elseif(tof='Feedstock') then
						-sum[n, (namePer_node(n)=nn)*feedstockUse_act(n,z,as,el,p)]*(el<>'Material')*(z<>'Waste') !(HARDCODED)
					endif
					!edited by Kira to correct for material flows
					!added by Kira to correct for material conversion activities
					!corrected to remove international transport
				}
			}
			Parameter finalEnergy_act {
				IndexDomain: (nn,z,as,p);
				Definition: {
					sum[(tb,ae,n) | ((tech_category(tb)='Final')*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)*energyUse_tech(n,tb,ae,p)*(activityType_act(activityPer_tech(tb))='Driver'))<0,
					 energyUse_tech(n,tb,ae,p)*(nodePer_techBal(tb)=n)*(namePer_node(n)=nn)] !(HARDCODED)
					+sum[(tb,ae,n) | ((tech_category(tb)='Emission')*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)*energyUse_tech(n,tb,ae,p)*(activityType_act(activityPer_tech(tb))='Emission'))<0,
					 energyUse_tech(n,tb,ae,p)*(nodePer_techBal(tb)=n)*(namePer_node(n)=nn)] !(HARDCODED)
					 +sum[(tb,ae,n) | ((tech_category(tb)='Conversion')*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)*energyUse_tech(n,tb,ae,p)*(labelPer_act(activityPer_tech(tb))='Material'))<0,
					 energyUse_tech(n,tb,ae,p)*(nodePer_techBal(tb)=n)*(namePer_node(n)=nn)] !(HARDCODED)
					 !final element added by Kira to account for material conversion processes that belong to the "final" end use sectors
				}
			}
			Parameter finalEnergy_act_kev {
				IndexDomain: (nn,zk,as,p);
				Definition: {
					sum[(n,tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Final')*(tech_sector_kev(tb)=zk)*(activityPer_tech(tb)=as)
						*(activityType_act(activityPer_tech(tb))='Driver')*(namePer_node(n)=nn))<>0,
					 	energyUse_tech(n,tb,ae,p)] !Final enery use
					
					!added by Kira to correct for "conversion" material processes and CCUS
					+ sum[(n,tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Conversion')*(tech_sector_kev(tb)=zk)*(tech_sector(tb)='Industry')
						*(activityPer_tech(tb)=as)*(activityType_act(activityPer_tech(tb))='Material conversion')*(namePer_node(n)=nn))<>0,
					  	energyUse_tech(n,tb,ae,p)] !Final enery use for industrial material conversion processes
					
					+ sum[(n,tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Emission')*(tech_sector_kev(tb)=zk)*(tech_sector(tb)='Industry')
					   	*(activityPer_tech(tb)=as)*(namePer_node(n)=nn))<>0,
					 	energyUse_tech(n,tb,ae,p)] !Final enery use for CCUS
				}
			}
			Parameter primaryEnergy {
				IndexDomain: (n,el,p);
				Definition: {
					sum[(tb,ae), (nodePer_techBal(tb)=n)*(tech_category(tb)="Primary")*(activityPer_tech(tb)=ae)*(labelPer_act(ae)=el)*(labelPer_act(ae)<>'Material')*Ptech_useNet(tb,p)*activity_balances(tb,ae,p)]
					!edited by Kira to account for material flows
				}
			}
			Parameter exportsEnergy {
				IndexDomain: (n,el,p);
				Definition: {
					!-sum[(tb,ae), (nodePer_techBal(tb)<>n)*(nodePer_act(ae)=n)*(activity_balances(tb,ae,p)<0)*(labelPer_act(ae)=el)
					!*Ptech_useNet(tb,p)*activity_balances(tb,ae,p)] !Technologies that are connected to other networks
					
					+sum[ae, final_activities(n,ae,p)*(labelPer_act(ae)=el)*(labelPer_act(ae)<>'Material')]!sum[ae, (nodePer_act(ae)=n)*(labelPer_act(ae)=el)] !Activities that are over-produced
					!edited by Kira to account for exported materials
				}
			}
			Parameter primaryBalance {
				IndexDomain: (nn,tope,el,p);
				Definition: {
					!Hardcoded
					if (tope='Total') then
						sum[n, (namePer_node(n)=nn)*primaryEnergy(n,el,p)*IEM_node(n)]*(el<>'Oil')
						+sum[n, (namePer_node(n)=nn)*primaryEnergy(n,'Oil',p)*IEM_node(n)]*(el='Oil Products')
					elseif(tope='Exports') then
						sum[n, (namePer_node(n)=nn)*exportsEnergy(n,el,p)*IEM_node(n)]*(el<>'Oil')
						+sum[n, (namePer_node(n)=nn)*exportsEnergy(n,'Oil',p)*IEM_node(n)]*(el='Oil Products')
					elseif(tope='Net') then
						sum[n, (namePer_node(n)=nn)*primaryEnergy(n,el,p)*IEM_node(n)]*(el<>'Oil')
						-sum[n, (namePer_node(n)=nn)*exportsEnergy(n,el,p)*IEM_node(n)]*(el<>'Oil')
						+sum[n, (namePer_node(n)=nn)*primaryEnergy(n,'Oil',p)*IEM_node(n)]*(el='Oil Products')
						-sum[n, (namePer_node(n)=nn)*exportsEnergy(n,'Oil',p)*IEM_node(n)]*(el='Oil Products')
					endif
				}
			}
			Parameter EnergyExclussiveness {
				IndexDomain: (n,tb,ae,p);
				Definition: {
					(energyUse_tech(n,tb,ae,p)>0)*energyUse_tech(n,tb,ae,p)/
					(sum[iae,(energyUse_tech(n,tb,iae,p)>0)*energyUse_tech(n,tb,iae,p)]+1e-12)
				}
			}
			Parameter sankey_flows {
				IndexDomain: (nn,tou,itos,jtos,p);
				Definition: {
					!(HARDCODED)
					!edited by Kira to account for material flows and allocation of material conversion to final industry sector
					if (tou = 'Final') then
						-sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(energyUse_tech(n,tb,ae,p)<0)*energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=itos)*(tech_sector(tb)=jtos)*(tech_category(tb)="Final")*(labelPer_act(ae)<>'Material')]
						-sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(energyUse_tech(n,tb,ae,p)<0)*energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=itos)*(tech_sector(tb)=jtos)*(tech_category(tb)="Emission")*(labelPer_act(ae)<>'Material')]
						!-sum[(n,tb,ae), (energyUse_tech(n,tb,ae,p)<0)*energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=itos)*(tech_sector(tb)='Industry')*(tech_category(tb)="Conversion")*(labelPer_act(ae)='Material')]
						!-sum[(n,tb,amc), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(energyUse_tech_mat(n,tb,amc,p)<0)*energyUse_tech_mat(n,tb,amc,p)*(labelPer_act(amc)=itos)*(tech_sector(tb)='Industry')*(labelPer_act(amc)='Material')]
					 	- sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(energyUse_tech(n,tb,ae,p)<0)*energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=itos)*(tech_sector(tb)=jtos)*(tech_sector(tb)='Industry')*(tech_category(tb)='Conversion')*(activityType_act(activityPer_tech(tb))='Material conversion')]
					
					
					elseif (tou = 'Conversion') then
						-sum[(n,tb,ae,iae)| (labelPer_act(ae)<>'Material'), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(tech_sector(tb)='Waste Disposal')
						*energyUse_tech(n,tb,ae,p)*EnergyExclussiveness(n,tb,iae,p)
						*(energyUse_tech(n,tb,ae,p)<0)*(tech_sector(tb)=itos)*(energyUse_tech(n,tb,iae,p)>0)*(labelPer_act(iae)=jtos)*(itos<>jtos)]
						-sum[(n,tb,ae,iae)| (labelPer_act(ae)<>'Material'), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(tech_category(tb)="Conversion")
						*energyUse_tech(n,tb,ae,p)*EnergyExclussiveness(n,tb,iae,p)
						*(energyUse_tech(n,tb,ae,p)<0)*(labelPer_act(ae)=itos)*(energyUse_tech(n,tb,iae,p)>0)*(labelPer_act(iae)=jtos)*(itos<>jtos)]
						!+sum[(n,tb,ae,iae)| (labelPer_act(ae)<>'Material'), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(tech_category(tb)="Conversion")
						!*energyUse_tech(n,tb,ae,p)*EnergyExclussiveness(n,tb,iae,p)
						!*(energyUse_tech(n,tb,ae,p)<0)*(labelPer_act(ae)=itos)*(energyUse_tech(n,tb,iae,p)>0)*(labelPer_act(iae)=jtos)*(itos<>jtos)*(labelPer_act(iae)<>'Material')*(tech_sector(tb)='Industry')]
					
					elseif (tou = 'Exports') then
						sum[n, IEM_node(n)*(namePer_node(n)=nn)*exportsEnergy(n,itos,p)*(jtos='Exports')]
					
					elseif (tou = 'Losses') then
						-sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*energyUse_tech(n,tb,ae,p)*(labelPer_act(activityPer_tech(tb))=itos)*(labelPer_act(activityPer_tech(tb))<>'Material')*(jtos='Losses')*(tech_category(tb)="Conversion")]
					
					elseif (tou = 'Primary') then
						(itos='Primary')*(
						-sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=jtos)*(tech_category(tb)="Final")*(labelPer_act(ae)<>'Material')]
						-sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=jtos)*(tech_category(tb)="Emission")*(labelPer_act(ae)<>'Material')]
						+sum[n, IEM_node(n)*(namePer_node(n)=nn)*exportsEnergy(n,jtos,p)]
						-sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*energyUse_tech(n,tb,ae,p)*(labelPer_act(activityPer_tech(tb))=jtos)*(tech_category(tb)="Conversion")*(labelPer_act(ae)<>'Material')]
						-sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=jtos)*(tech_category(tb)="Conversion")*(labelPer_act(ae)<>'Material')]
						-sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=jtos)*(tech_category(tb)="Primary")*(labelPer_act(ae)<>'Material')]
						+sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*energyUse_tech(n,tb,ae,p)*(labelPer_act(activityPer_tech(tb))=jtos)*(tech_category(tb)="Conversion")*(labelPer_act(ae)<>'Material')]
						+sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*energyUse_tech(n,tb,ae,p)*(labelPer_act(activityPer_tech(tb))=jtos)*(tech_category(tb)="Primary")*(labelPer_act(ae)<>'Material')]
						)
					
					endif
				}
			}
			Parameter final_decomposition {
				IndexDomain: (nn,tod,p);
				Definition: {
					!(HARDCODE)
					if (tod='Net Primary') then 
						sum[el, primaryBalance(nn,'Net',el,p)]
					elseif (tod='Net energy transformations') then
						-sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(tech_category(tb)='Conversion')*energyUse_tech(n,tb,ae,p)] !National drivers
					elseif (tod='Total Final incl. bunkers') then
						-sum[(z,as), (z<>'Waste')*finalEnergy_act(nn,z,as,p)]
					elseif (tod='Int. Transport') then
						-sum[(z,as), (as in international_transport)*finalEnergy_act(nn,z,as,p)]
					elseif (tod='Total Final excl. bunkers') then
						-sum[(z,as), (z<>'Waste')*((as in international_transport)=0)*finalEnergy_act(nn,z,as,p)]
					elseif (tod='Feedstock') then
						-sum[(n,z,el), IEM_node(n)*(namePer_node(n)=nn)*feedstockUse_sec(n,z,el,p)]
					elseif (tod='Final energy use') then
						-sum[(z,as), (z<>'Waste')*((as in international_transport)=0)*finalEnergy_act(nn,z,as,p)]
						+sum[(n,z,el), IEM_node(n)*(namePer_node(n)=nn)*feedstockUse_sec(n,z,el,p)]
					elseif (tod='Final losses') then
						-sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(tech_subsector(tb)='Heat')*(tech_category(tb)='Conversion')*energyUse_tech(n,tb,ae,p)]
					elseif (tod='Electricity final') then
						sum[(tof,z), finalEnergy_matrix(nn,z,tof,'Electricity',p)]
					elseif (tod='Electricity total') then
						electricity_parameters(nn,'net',p)
					endif
				}
			}
			Parameter primary_renewable {
				IndexDomain: (nn,el,p);
				Definition: (el in renewables)*primaryBalance(nn,'Net',el,p);
			}
		}
		DeclarationSection Profiles {
			Set typesOf_3Dactivity {
				SubsetOf: activities_solve;
				Index: t3a, it3a, jt3a;
				Definition: activities_hour + {as | (labelPer_act(as)='Solar' or labelPer_act(as)='Wind')};
			}
			Set typesOf_profiles {
				Index: topp, itopp, jtopp;
				Definition: {
					{'reference','final'}
				}
			}
			Set typesOf_RLparameters {
				Index: torl, itorl, jtorl;
				Definition: {
					{'Load (no flex)','Wind','Solar','Run of River','Baseload Generation','Residual Load','Imports','Exports','Shedding','CHPs UP','CHPs DW','Smart Charging UP',
					'Smart Charging DW','V-to-G UP','V-to-G DW','Load Shifting UP','Load Shifting DW','Storage UP','Storage DW','Curtailment','Remaining'}
				}
			}
			Set typesOf_RLdirections {
				Index: torld, itorld, jtorld;
				Definition: {
					{'Deficit','Surplus'}
				}
			}
			Set typesOf_RLflexibility {
				Index: torlf, itorlf, jtorlf;
				Definition: {
					{'Imports','Exports','Curtailment','Storage','Flex Generation','Demand Response','Other'}
				}
			}
			Parameter loadProfiles_H {
				IndexDomain: (nn,h,ah,p);
				InitialData: 0;
			}
			Parameter refProfiles_H {
				IndexDomain: (nn,h,tb,p);
				InitialData: 0;
			}
			Parameter finProfiles_H {
				IndexDomain: (nn,h,tb,p);
				InitialData: 0;
			}
			Parameter loadProfiles_D {
				IndexDomain: (nn,d,ad,p);
				InitialData: 0;
			}
			Parameter refProfiles_D {
				IndexDomain: (nn,d,tg,p);
				InitialData: 0;
			}
			Parameter finProfiles_D {
				IndexDomain: (nn,d,tg,p);
				InitialData: 0;
			}
			Parameter flexProfiles_H {
				IndexDomain: (nn,topp,h,tb,p);
			}
			Parameter profiles3D {
				IndexDomain: (nn,w,h_d,t3a,p);
				InitialData: 0;
			}
			Parameter residual_load {
				IndexDomain: (nn,h,torl,p);
				InitialData: 0;
			}
			Parameter diferential_resLoad {
				IndexDomain: (nn,h,p);
				InitialData: 0;
			}
			Parameter decomposition_resLoad {
				IndexDomain: (nn,h,torlf,p);
				InitialData: 0;
			}
			Parameter decomposition_resLoadY {
				IndexDomain: (nn,torlf,p);
				Definition: sum[h, decomposition_resLoad(nn,h,torlf,p)];
			}
		}
		DeclarationSection Other_results {
			Set typesOf_electricityParameters {
				Index: toep, itoep, jtoep;
				Definition: {
					{'load','import','export','net','cost','variability','unserved'}
				}
			}
			Set typesOf_flexibility {
				Index: tox, itox, jtox;
				Definition: {
					{'flexible_CHPs','shedding','demand_response','storage','passive_storage','smart_charging','vehicle-to-grid','imports','exports','curtailment'}
				}
			}
			Set typesOf_keyIndicators {
				Index: tok, itok, jtok;
				Definition: {
					{'CO2 Target','CO2 Price','Hydrogen Use','Ammonia Use','RES share in primary','RES share in final electricity',
					'Final electrification','Final Energy Cost','Primary Energy Cost','CO2 Storage Potential','Net Emissions',
					'UP flex demand','DW flex demand','Oil Products Exports','Synfuels Exports','Biofuels Exports'}
				}
			}
			Set typesOf_intTransResults {
				Index: toitr, itoitr, jtoitr;
				Definition: {
					{'Emissions','Shadow Price'}
				}
			}
			Parameter RESelec_share {
				IndexDomain: (tb,p);
				Definition: {
					sum[(ae,iae), (labelPer_act(ae)='Electricity')*(activity_balances(tb,ae,p)>0)
					*(activity_balances(tb,iae,p)<0)*(labelPer_act(iae) in renewables)*activity_balances(tb,iae,p)]/
					sum[(ae,iae), (labelPer_act(ae)='Electricity')*(activity_balances(tb,ae,p)>0)*(activity_balances(tb,iae,p)<0)*activity_balances(tb,iae,p)+1e-9]
				}
			}
			Parameter key_indicators {
				IndexDomain: (nn,tok,p);
				Definition: {
					!(HARDCODED)
					if (tok='CO2 Target') then
						(sum[n, (namePer_node(n)=nn)*IEM_node(n)]-sum[n, (namePer_node(n)=nn)*IEM_node(n)*emissionTarget(n,p)/(emissionTarget(n,base_year)+0.00001)])*100
					elseif (tok='CO2 Price') then
						-sum[n, (namePer_node(n)=nn)*IEM_node(n)*CO2_price_single(n,p)]
					elseif (tok='Hydrogen Use') then
						sum[jtos, sankey_flows(nn,'Final','Hydrogen',jtos,p)+sankey_flows(nn,'Conversion','Hydrogen',jtos,p)]
					elseif (tok='Ammonia Use') then
						sum[jtos, sankey_flows(nn,'Final','Ammonia',jtos,p)+sankey_flows(nn,'Conversion','Ammonia',jtos,p)]
					elseif (tok='RES share in primary') then
						100*
						sum[el, (el in renewables)*primaryBalance(nn,'Net',el,p)]/sum[el, primaryBalance(nn,'Net',el,p)+1e-6 $ primaryBalance(nn,'Net',el,p)>=0]
					elseif (tok='RES share in final electricity') then
						100*
						sum[(n,tb,as), (namePer_node(n)=nn)*IEM_node(n)*(nodePer_techBal(tb)=n)*(labelPer_act(as)='Electricity')
						*(activity_balances(tb,as,p)>0)*Ptech_useNet(tb,p)*activity_balances(tb,as,p)*(tech_subsector(tb)<>'XC Trade')*RESelec_share(tb,p)]
						/sum[(n,as,tb), (namePer_node(n)=nn)*IEM_node(n)*(nodePer_techBal(tb)=n)*(labelPer_act(as)='Electricity')
						*(activity_balances(tb,as,p)>0)*Ptech_useNet(tb,p)*activity_balances(tb,as,p)*(tech_subsector(tb)<>'XC Trade')+1e-9]
					elseif (tok='Final electrification') then
						100*
						final_decomposition(nn,'Electricity final',p)/(final_decomposition(nn,'Final energy use',p)+1e-9)
					elseif (tok='Final Energy Cost') then
						sum[(n,tb,ae) | ((namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(tech_category(tb)='Final')*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
						(tech_sector(tb)<>'Waste')*!Not to account waste sector
						((activityPer_tech(tb) in international_transport)=0)* !Not in international transport
						energyUse_tech(n,tb,ae,p)*EnergyCosts_mean(ae,p)]/ !Final enery use times its mean cost
						(sum[(n,tb,ae) | ((namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(tech_category(tb)='Final')*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
						(tech_sector(tb)<>'Waste')*!Not to account waste sector
						((activityPer_tech(tb) in international_transport)=0)* !Not in international transport
						energyUse_tech(n,tb,ae,p)]+1e-20)
					elseif (tok='Primary Energy Cost') then
						sum[(n,tb,ae), (namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(tech_category(tb)="Primary")*(activityPer_tech(tb)=ae)*
						Ptech_useNet(tb,p)*activity_balances(tb,ae,p)*EnergyCosts_mean(ae,p)]/
						(sum[(n,tb,ae), (namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(tech_category(tb)="Primary")*(activityPer_tech(tb)=ae)*
						Ptech_useNet(tb,p)*activity_balances(tb,ae,p)]+1e-20)
					elseif (tok='CO2 Storage Potential') then
						sum[(n,tb), (namePer_node(n)=nn)*IEM_node(n)*(tech_name(tb)="CO2 Storage")*Ptech_useNet(tb,p)]
					elseif (tok='Net Emissions') then
						sum[(n,t_c), (namePer_node(n)=nn)*IEM_node(n)*(tech_sector(t_c)='Emission')*emissions_all(nn,t_c,p)]
					elseif(tok='UP flex demand')*(HourlyReportValue = 'yes') then
						sum[h, (residual_load(nn,h,'Residual Load',p)>0)*residual_load(nn,h,'Residual Load',p)]
					elseif(tok='DW flex demand')*(HourlyReportValue = 'yes') then
						sum[h, (residual_load(nn,h,'Residual Load',p)<0)*residual_load(nn,h,'Residual Load',p)]
					elseif(tok='Oil Products Exports')then
						sum[n, (namePer_node(n)=nn)*exportsEnergy(n,'Oil Products',p)]
					elseif(tok='Synfuels Exports')then
						sum[n, (namePer_node(n)=nn)*exportsEnergy(n,'Synfuels',p)]
					elseif(tok='Biofuels Exports')then
						sum[n, (namePer_node(n)=nn)*exportsEnergy(n,'Bio-fuels',p)]
					endif
				}
			}
			Parameter curtailmentRES {
				IndexDomain: (nn,th,p);
				Definition: {
					if sum[ae, (labelPer_act(ae)='Wind' or labelPer_act(ae)='Solar')*activity_balances(th,ae,p)]<0 then
						+(namePer_node(nodePer_techBal(th))=nn)*(PtechStock(th,p)*cap2act(th)-Ptech_use(th,p))
					elseif (StringOccurrences(profileType_tech(th),"Hydro RoR")>0) then
						+(namePer_node(nodePer_techBal(th))=nn)*(PtechStock(th,p)*cap2act(th)-Ptech_use(th,p))
					endif
				}
			}
			Parameter electricity_parameters {
				IndexDomain: (nn,toep,p);
				Definition: {
					if (toep='load') then
						sum[(n,tb,ahe) | sum[iahe,activity_balances(tb,iahe,p)]>0, IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(nodePer_act(ahe)=n)
						*(activity_balances(tb,ahe,p)>0)*Ptech_useNet(tb,p)*activity_balances(tb,ahe,p)]	
					elseif (toep='import') then
						-sum[(n,tb,ahe), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(nodePer_act(ahe)<>n)
						*Ptech_useNet(tb,p)*activity_balances(tb,ahe,p)]
					elseif (toep='export') then
						-sum[(n,tb,ahe), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_act(ahe)=n)*(nodePer_techBal(tb)<>n)
						*(activity_balances(tb,ahe,p)<0)*Ptech_useNet(tb,p)*activity_balances(tb,ahe,p)]
					elseif (toep='net') then
						sum[(n,tb,ahe) | sum[iahe,activity_balances(tb,iahe,p)]>0, IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(nodePer_act(ahe)=n)
						*(activity_balances(tb,ahe,p)>0)*Ptech_useNet(tb,p)*activity_balances(tb,ahe,p)]
						+sum[(n,tb,ahe), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_act(ahe)=n)*(nodePer_techBal(tb)<>n)
						*(activity_balances(tb,ahe,p)<0)*Ptech_useNet(tb,p)*activity_balances(tb,ahe,p)]
						-sum[(n,tb,ahe), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(nodePer_act(ahe)<>n)
						*Ptech_useNet(tb,p)*activity_balances(tb,ahe,p)]
					elseif (toep='cost') then
						sum[(h,ahe), (namePer_node(nodePer_act(ahe))=nn)*EnergyCosts(h,ahe,p)]/sum[ahe, (namePer_node(nodePer_act(ahe))=nn)*card(hours)+0.00001]
					elseif (toep='variability') then
						sum[(h,ahe), (namePer_node(nodePer_act(ahe))=nn)*abs(EnergyCostsVariability(h,ahe,p))]/sum[ahe, (namePer_node(nodePer_act(ahe))=nn)*card(hours)+0.00001]
					elseif (toep='unserved') then
						-sum[(n,tb,ahe), -(namePer_node(n)=nn)*(nodePer_act(ahe)=n)*(nodePer_techBal(tb)=n)
						*(tech_subsector(tb)="Undispatched")*Ptech_useNet(tb,p)]
					endif
				}
			}
			Parameter flexibility_volumes {
				IndexDomain: (nn,tox,p);
				Definition: {
					if (tox='flexible_CHPs') then
						sum[(h,tk,ah), (namePer_node(nodePer_techBal(tk))=nn)*abs(PdeltaU_CHP(h,tk,p)*activity_balances(tk,ah,p)+PdeltaP_CHP(h,tk,p)*dP_electricity(tk,ah)*(ah in activitiesHour_electricity))]/2
					elseif (tox='shedding') then
						sum[(h,ts,ah), (namePer_node(nodePer_techBal(ts))=nn)*PdeltaS_shed(h,ts,p)*activity_balances(ts,ah,p)*(ah in activitiesHour_electricity)]
					elseif (tox='demand_response') then
						-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='DR shifting')*(ah in activitiesHour_electricity)]
					elseif (tox='storage') then
						-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='Storage')*(ah in activitiesHour_electricity)]
					elseif (tox='passive_storage') then
						-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='BE shifting')*(ah in activitiesHour_electricity)]
					elseif (tox='smart_charging') then
						-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='EV smart charge')*(ah in activitiesHour_electricity)]
					elseif (tox='vehicle-to-grid') then
						-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='EV P-to-Grid')*(ah in activitiesHour_electricity)]
					elseif (tox='imports') then
						sum[(h,tb,ahe), (namePer_node(nodePer_techBal(tb))=nn)*(nodePer_act(ahe)<>nodePer_techBal(tb))*(activity_balances(tb,ahe,p)<0)*Ptech_useHourlyNet(h,tb,p)]
					elseif (tox='exports') then
						-sum[(h,tb,ahe), (namePer_node(nodePer_act(ahe))=nn)*(nodePer_techBal(tb)<>nodePer_act(ahe))*(activity_balances(tb,ahe,p)<0)*Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ahe,p)]
					elseif (tox='curtailment') then
						-sum[(h,th,ae), (namePer_node(nodePer_techBal(th))=nn)*((labelPer_act(ae)='Wind')+(labelPer_act(ae)='Solar'))*(activity_balances(th,ae,p)<0)*
						(Ptech_useHourly(h,th,p)-PtechStock(th,p)*cap2act(th)*hourly_profiles(h,profileType_tech(th)))]
						-sum[(h,th), (namePer_node(nodePer_techBal(th))=nn)*(StringOccurrences(profileType_tech(th),"Hydro RoR")>0)*
						(Ptech_useHourly(h,th,p)-PtechStock(th,p)*cap2act(th)*hourly_profiles(h,profileType_tech(th)))]
					endif
				}
			}
			Parameter flexibility_volumesAct {
				IndexDomain: (nn,z,as,tox,p);
				Definition: {
					if (tox='flexible_CHPs') then
						sum[(h,tk,ah), (namePer_node(nodePer_techBal(tk))=nn)*(tech_sector(tk)=z)*(activityPer_tech(tk)=as)*
						abs(PdeltaU_CHP(h,tk,p)*activity_balances(tk,ah,p)+PdeltaP_CHP(h,tk,p)*dP_electricity(tk,ah)*(ah in activitiesHour_electricity))]/2
					elseif (tox='shedding') then
						sum[(h,ts,ah), (namePer_node(nodePer_techBal(ts))=nn)*(tech_sector(ts)=z)*(activityPer_tech(ts)=as)*
						PdeltaS_shed(h,ts,p)*activity_balances(ts,ah,p)*(ah in activitiesHour_electricity)]
					elseif (tox='demand_response') then
						-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*(tech_sector(tf)=z)*(activityPer_tech(tf)=as)*
						PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='DR shifting')*(ah in activitiesHour_electricity)]
					elseif (tox='storage') then
						-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*(tech_sector(tf)=z)*(activityPer_tech(tf)=as)*
						PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='Storage')*(ah in activitiesHour_electricity)]
					elseif (tox='passive_storage') then
						-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*(tech_sector(tf)=z)*(activityPer_tech(tf)=as)*
						PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='BE shifting')*(ah in activitiesHour_electricity)]
					elseif (tox='smart_charging') then
						-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*(tech_sector(tf)=z)*(activityPer_tech(tf)=as)*
						PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='EV smart charge')*(ah in activitiesHour_electricity)]
					elseif (tox='vehicle-to-grid') then
						-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*(tech_sector(tf)=z)*(activityPer_tech(tf)=as)*
						PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='EV P-to-Grid')*(ah in activitiesHour_electricity)]
					elseif (tox='imports') then
						sum[(h,tb,ahe), (namePer_node(nodePer_techBal(tb))=nn)*(nodePer_act(ahe)<>nodePer_techBal(tb))*(tech_sector(tb)=z)*
						(activityPer_tech(tb)=as)*(activity_balances(tb,ahe,p)<0)*Ptech_useHourlyNet(h,tb,p)]
					elseif (tox='exports') then
						-sum[(h,tb,ahe), (namePer_node(nodePer_act(ahe))=nn)*(nodePer_techBal(tb)<>nodePer_act(ahe))*(tech_sector(tb)=z)*
						(activityPer_tech(tb)=as)*(activity_balances(tb,ahe,p)<0)*Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ahe,p)]
					elseif (tox='curtailment') then
						-sum[(h,th,ae), (namePer_node(nodePer_techBal(th))=nn)*((labelPer_act(ae)='Wind')+(labelPer_act(ae)='Solar'))*(activity_balances(th,ae,p)<0)*
						(tech_sector(th)=z)*(activityPer_tech(th)=as)*(Ptech_useHourly(h,th,p)-PtechStock(th,p)*cap2act(th)*hourly_profiles(h,profileType_tech(th)))]
						-sum[(h,th), (namePer_node(nodePer_techBal(th))=nn)*(StringOccurrences(profileType_tech(th),"Hydro RoR")>0)*
						(tech_sector(th)=z)*(activityPer_tech(th)=as)*(Ptech_useHourly(h,th,p)-PtechStock(th,p)*cap2act(th)*hourly_profiles(h,profileType_tech(th)))]
					endif
					
					!if (tox='flexible_CHPs') then
					!	sum[(h,tk,ah), (namePer_node(nodePer_techBal(tk))=nn)*(tech_sector(tk)=z)*(activityPer_tech(tk)=as)*(tk=itb)*
					!	abs(PdeltaU_CHP(h,tk,p)*activity_balances(tk,ah,p)+PdeltaP_CHP(h,tk,p)*dP_electricity(tk,ah)*(ah in activitiesHour_electricity))]/2
					!elseif (tox='shedding') then
					!	sum[(h,ts,ah), (namePer_node(nodePer_techBal(ts))=nn)*(tech_sector(ts)=z)*(activityPer_tech(ts)=as)*(ts=itb)*
					!	PdeltaS_shed(h,ts,p)*activity_balances(ts,ah,p)*(ah in activitiesHour_electricity)]
					!elseif (tox='demand_response') then
					!	-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*(tech_sector(tf)=z)*(activityPer_tech(tf)=as)*(tf=itb)*
					!	PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='DR shifting')*(ah in activitiesHour_electricity)]
					!elseif (tox='storage') then
					!	-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*(tech_sector(tf)=z)*(activityPer_tech(tf)=as)*(tf=itb)*
					!	PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='Storage')*(ah in activitiesHour_electricity)]
					!elseif (tox='passive_storage') then
					!	-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*(tech_sector(tf)=z)*(activityPer_tech(tf)=as)*(tf=itb)*
					!	PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='BE shifting')*(ah in activitiesHour_electricity)]
					!elseif (tox='smart_charging') then
					!	-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*(tech_sector(tf)=z)*(activityPer_tech(tf)=as)*(tf=itb)*
					!	PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='EV smart charge')*(ah in activitiesHour_electricity)]
					!elseif (tox='vehicle-to-grid') then
					!	-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*(tech_sector(tf)=z)*(activityPer_tech(tf)=as)*(tf=itb)*
					!	PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='EV P-to-Grid')*(ah in activitiesHour_electricity)]
					!elseif (tox='imports') then
					!	sum[(h,tb,ahe), (namePer_node(nodePer_techBal(tb))=nn)*(nodePer_act(ahe)<>nodePer_techBal(tb))*(tech_sector(tb)=z)*
					!	(activityPer_tech(tb)=as)*(tb=itb)*(activity_balances(tb,ahe,p)<0)*Ptech_useHourlyNet(h,tb,p)]
					!elseif (tox='exports') then
					!	sum[(h,tb,ahe), (namePer_node(nodePer_act(ahe))=nn)*(nodePer_techBal(tb)<>nodePer_act(ahe))*(tech_sector(tb)=z)*
					!	(activityPer_tech(tb)=as)*(tb=itb)*(activity_balances(tb,ahe,p)<0)*Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ahe,p)]
					!elseif (tox='curtailment') then
					!	sum[(h,th,ae), (namePer_node(nodePer_techBal(th))=nn)*((labelPer_act(ae)='Wind')+(labelPer_act(ae)='Solar'))*(activity_balances(th,ae,p)<0)*
					!	(tech_sector(th)=z)*(activityPer_tech(th)=as)*(th=itb)*(Ptech_useHourly(h,th,p)-PtechStock(th,p)*cap2act(th)*hourly_profiles(h,profileType_tech(th)))]
					!	+sum[(h,th), (namePer_node(nodePer_techBal(th))=nn)*(StringOccurrences(profileType_tech(th),"Hydro RoR")>0)*
					!	(tech_sector(th)=z)*(activityPer_tech(th)=as)*(th=itb)*(Ptech_useHourly(h,th,p)-PtechStock(th,p)*cap2act(th)*hourly_profiles(h,profileType_tech(th)))]
					!endif
				}
			}
			Parameter flexibility_volumesTech {
				IndexDomain: (nn,tb,tox,p);
				Definition: {
					if (tox='flexible_CHPs') then
						sum[(h,ah), (namePer_node(nodePer_techBal(tb))=nn)*
						abs(PdeltaU_CHP(h,tb,p)*activity_balances(tb,ah,p)+PdeltaP_CHP(h,tb,p)*dP_electricity(tb,ah)*(ah in activitiesHour_electricity))]/2
					elseif (tox='shedding') then
						sum[(h,ah), (namePer_node(nodePer_techBal(tb))=nn)*
						PdeltaS_shed(h,tb,p)*activity_balances(tb,ah,p)*(ah in activitiesHour_electricity)]
					elseif (tox='demand_response') then
						-sum[(h,ah), (namePer_node(nodePer_techBal(tb))=nn)*
						PdeltaQ_UP(h,tb,p)*dQ_hourly(tb,ah)*(flexibilityType_tech(tb)='DR shifting')*(ah in activitiesHour_electricity)]
					elseif (tox='storage') then
						-sum[(h,ah), (namePer_node(nodePer_techBal(tb))=nn)*
						PdeltaQ_UP(h,tb,p)*dQ_hourly(tb,ah)*(flexibilityType_tech(tb)='Storage')*(ah in activitiesHour_electricity)]
					elseif (tox='passive_storage') then
						-sum[(h,ah), (namePer_node(nodePer_techBal(tb))=nn)*
						PdeltaQ_UP(h,tb,p)*dQ_hourly(tb,ah)*((tb)='BE shifting')*(ah in activitiesHour_electricity)]
					elseif (tox='smart_charging') then
						-sum[(h,ah), (namePer_node(nodePer_techBal(tb))=nn)*
						PdeltaQ_UP(h,tb,p)*dQ_hourly(tb,ah)*(flexibilityType_tech(tb)='EV smart charge')*(ah in activitiesHour_electricity)]
					elseif (tox='vehicle-to-grid') then
						-sum[(h,ah), (namePer_node(nodePer_techBal(tb))=nn)*
						PdeltaQ_UP(h,tb,p)*dQ_hourly(tb,ah)*(flexibilityType_tech(tb)='EV P-to-Grid')*(ah in activitiesHour_electricity)]
					elseif (tox='imports') then
						sum[(h,ahe), (namePer_node(nodePer_techBal(tb))=nn)*(nodePer_act(ahe)<>nodePer_techBal(tb))*
						(activity_balances(tb,ahe,p)<0)*Ptech_useHourlyNet(h,tb,p)]
					elseif (tox='exports') then
						-sum[(h,ahe), (namePer_node(nodePer_act(ahe))=nn)*(nodePer_techBal(tb)<>nodePer_act(ahe))*
						(activity_balances(tb,ahe,p)<0)*Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ahe,p)]
					elseif (tox='curtailment') then
						-sum[(h,ae), (namePer_node(nodePer_techBal(tb))=nn)*((labelPer_act(ae)='Wind')+(labelPer_act(ae)='Solar'))*
						(activity_balances(tb,ae,p)<0)*(Ptech_useHourlyNet(h,tb,p)-PtechStock(tb,p)*cap2act(tb)*hourly_profiles(h,profileType_tech(tb)))]
						-sum[h, (namePer_node(nodePer_techBal(tb))=nn)*(StringOccurrences(profileType_tech(tb),"Hydro RoR")>0)*
						(Ptech_useHourlyNet(h,tb,p)-PtechStock(tb,p)*cap2act(tb)*hourly_profiles(h,profileType_tech(tb)))]
					endif
				}
			}
			Parameter intTransport_indicators {
				IndexDomain: (toitr,p);
				Definition: {
					if (toitr = 'Emissions') then
						sum[t_c, (nodePer_techBal(t_c)='XX')*Ptech_useNet(t_c,p)]
					elseif (toitr = 'Shadow Price') then
						sum[ac, (nodePer_act(ac)='XX')*CO2_prices(ac,p)]
					endif
				}
			}
		}
		DeclarationSection Rounded_parameters {
			Parameter RSystemCosts_n {
				IndexDomain: (nn,toc,pnz);
				InitialData: 0;
			}
			Parameter RSystemCosts_sec_n {
				IndexDomain: (nn,z,tots,toc,pnz);
				InitialData: 0;
			}
			Parameter RSectoralConfiguration_stock {
				IndexDomain: (nn,z,as,tots,t,pnz);
				InitialData: 0;
			}
			Parameter RSectoralConfiguration_use {
				IndexDomain: (nn,z,as,tots,t,pnz);
				InitialData: 0;
			}
			Parameter RPower_stock {
				IndexDomain: (nn,tb,pnz);
				InitialData: 0;
			}
			Parameter RPower_gen {
				IndexDomain: (nn,tb,pnz);
				InitialData: 0;
			}
			Parameter RXC_stock {
				IndexDomain: (inn,nn,tb,pnz);
				InitialData: 0;
			}
			Parameter RXC_use {
				IndexDomain: (inn,nn,tb,pnz);
				InitialData: 0;
			}
			Parameter RPower_dispatch {
				IndexDomain: (nn,h,th,pnz);
				InitialData: 0;
			}
			Parameter Remissions_all {
				IndexDomain: (nn,t_c,pnz);
				InitialData: 0;
			}
			Parameter Remissions_sec {
				IndexDomain: (nn,z,aer,pnz);
				InitialData: 0;
			}
			Parameter RsupdemAct_tech {
				IndexDomain: (nn,as,tob,tb,tn,pnz);
				InitialData: 0;
			}
			Parameter RfinalEnergy_matrix {
				IndexDomain: (nn,z,tof,el,pnz);
				InitialData: 0;
			}
			Parameter RfinalEnergy_act {
				IndexDomain: (nn,z,as,pnz);
			}
			Parameter RprimaryBalance {
				IndexDomain: (nn,tope,el,pnz);
				InitialData: 0;
			}
			Parameter Rsankey_flows {
				IndexDomain: (nn,tou,itos,jtos,pnz);
				InitialData: 0;
			}
			Parameter RloadProfiles_H {
				IndexDomain: (nn,h,ah,pnz);
				InitialData: 0;
			}
			Parameter RflexProfiles_H {
				IndexDomain: (nn,topp,h,tb,pnz);
				InitialData: 0;
			}
			Parameter RloadProfiles_D {
				IndexDomain: (nn,d,ad,pnz);
				InitialData: 0;
			}
			Parameter RfinProfiles_D {
				IndexDomain: (nn,d,tg,pnz);
				InitialData: 0;
			}
			Parameter Rprofiles3D {
				IndexDomain: (nn,w,h_d,t3a,pnz);
				InitialData: 0;
			}
			Parameter Rfinal_decomposition {
				IndexDomain: (nn,tod,pnz);
				InitialData: 0;
			}
			Parameter RcurtailmentRES {
				IndexDomain: (nn,th,pnz);
				InitialData: 0;
			}
			Parameter Relectricity_parameters {
				IndexDomain: (nn,toep,pnz);
				InitialData: 0;
			}
			Parameter Rflexibility_volumes {
				IndexDomain: (nn,tox,pnz);
				InitialData: 0;
			}
			Parameter Rkey_indicators {
				IndexDomain: (nn,tok,pnz);
				InitialData: 0;
			}
			Parameter RLCOE {
				IndexDomain: (nn,as,tb,tolm,tol,pnz);
				InitialData: 0;
			}
			Parameter RSectoralCosts_cascade {
				IndexDomain: (nn,z,toc,pnz);
				InitialData: 0;
			}
			Parameter Rprimary_renewable {
				IndexDomain: (nn,el,pnz);
				InitialData: 0;
			}
			Parameter RSystemCosts_sec_tot {
				IndexDomain: (nn,z,pnz);
				InitialData: 0;
			}
			Parameter REnergyCosts_hourly {
				IndexDomain: (h,ah,pnz);
				InitialData: 0;
			}
			Parameter REnergyCosts_nodeD {
				IndexDomain: (nn,d,ad,pnz);
				InitialData: 0;
			}
			Parameter RPlanningDecissions_tech {
				IndexDomain: (nn,t,topd,pnz);
				InitialData: 0;
			}
			Parameter RPowerInfo_act {
				IndexDomain: (ahee,topi,tb,pnz);
				InitialData: 0;
			}
			Parameter RXCinfo_act {
				IndexDomain: (iahee,ahee,topi,tb,pnz);
				InitialData: 0;
			}
			Parameter RintTransport_indicators {
				IndexDomain: (toitr,pnz);
				InitialData: 0;
			}
			Parameter REnergyCosts_node {
				IndexDomain: (nn,ae,pnz);
				InitialData: 0;
			}
			Parameter REnergyCosts_node_secondary {
				IndexDomain: (nn,ass,pnz);
				InitialData: 0;
			}
			Parameter Rresidual_load {
				IndexDomain: (nn,h,torl,pnz);
				InitialData: 0;
			}
			Parameter RSystemCosts_act_n {
				IndexDomain: (nn,z,as,tots,toc,pnz);
				InitialData: 0;
			}
			Parameter Remissions_act {
				IndexDomain: (nn,z,as,aer,pnz);
				InitialData: 0;
			}
			Parameter Rflexibility_volumesAct {
				IndexDomain: (nn,z,as,tox,pnz);
				InitialData: 0;
			}
			Parameter RfinalEnergy_matrixAct {
				IndexDomain: (nn,z,as,tof,el,pnz);
				InitialData: 0;
			}
			Parameter Rdecomposition_resLoad {
				IndexDomain: (nn,h,torlf,pnz);
				InitialData: 0;
			}
			Parameter Rdecomposition_resLoadY {
				IndexDomain: (nn,torlf,pnz);
				InitialData: 0;
			}
			Parameter Rflexibility_volumesTech {
				IndexDomain: (nn,tb,tox,pnz);
				InitialData: 0;
			}
			Parameter RenergyUse_act {
				IndexDomain: (nn,z,as,ae,pnz);
				InitialData: 0;
			}
			Parameter Remissions_tech {
				IndexDomain: (nn,z,as,tb,tn,aer,pnz);
				InitialData: 0;
			}
			Parameter RLCOP_secE {
				IndexDomain: (nn,z,tots,toc,pnz);
				InitialData: 0;
			}
			Parameter RLCOP_act {
				IndexDomain: (nn,z,as,tots,toc,pnz);
				InitialData: 0;
			}
			Parameter Rshadow_energyPrices {
				IndexDomain: (nn,ae,pnz);
				InitialData: 0;
			}
			Parameter Rshadow_CO2Prices {
				IndexDomain: (nn,acf,pnz);
				InitialData: 0;
			}
			Parameter Rshadow_CO2Prices_single {
				IndexDomain: (n,p);
				InitialData: 0;
			}
		}
		DeclarationSection Others {
			Parameter objFun_capCosts {
				IndexDomain: ps;
				Definition: {
					sum[(t,jp), InvMat_lifeTime(t,jp,ps)*
								(cap_investments(t,jp)*inv_cost(t,jp)*CRF(t)				!New invetments
								+sum[it, retrofitting(it,t,jp)*inv_cost(t,jp)*CRF(t)]			!Retroffiting aditions
								-sum[it, retrofitting(t,it,jp)*inv_cost(t,jp)*CRF(t)]			!Retrofitting substractions (yes, for the whole lifetime, as only the difference in cost is assumed to be paid)
								-eco_decommisioning(t,jp)*(1-Salvage_value(t))*inv_cost(t,jp)*CRF(t)) 	!Recovered costs of decommisioning forwarded to the substitute investment
								]
				}
			}
			Parameter average_interconnectedPrice {
				IndexDomain: (ain,p);
				Definition: sum[h, interconnectedHourly_prices(h,ain,p)]/card(h);
			}
			Parameter objFun_operation {
				IndexDomain: ps;
				Definition: {
					sum[t, tech_use(t,ps)*(vom_cost(t,ps)+1e-6)] !Variable costs (including fuel costs)
					+sum[(h,thin), tech_useHourly(h,thin,ps)*(vom_interconnected_hourly(h,thin,ps)+1e-16)]!Electricity costs of interconnected nodes
					+sum[(h,t), (deltaU_CHP(h,t,ps)+deltaS_shed(h,t,ps))*(vom_cost(t,ps)+1e-10)] !Deviations in tech use due to flexibility
					+sum[(t), techStock(t,ps)*fom_cost(t,ps)] !Fix costs
					+1e-6*sum[(h,tf), deltaQ_DW(h,tf,ps)-deltaQ_UP(h,tf,ps)] !To avoid multiple solutions
					+1e-6*sum[(h,ts), deltaS_shed(h,ts,ps)] !To avoid multiple solutions
				}
			}
		}
		Procedure EnergyCosts_calculator {
			Body: {
				!Routine to get the fuel costs of energy production
				StatusMessage("Obtaining energy costs. . . " );
				
				!Delete the current values of energy_costs
				empty EnergyCosts,EnergyCosts_yearly,EnergyCosts_daily,EnergyCosts_hourly,techCosts_voc,IterCounter;
				
				
				
				
				!Merge the costs
				if (EnergyPricesChoice = 'Marginal Costs') then 
					!Energy costs based on (marginal) cost of generation technologies' SRMC
					while(IterCounter<5) do
						!Initialize by assigning primary costs
						techCosts_voc(h,tb,pnz) := vom_cost(tb,pnz)+vom_interconnected_hourly(h,tb,pnz)
							+sum[ay, -activity_balances(tb,ay,pnz)*EnergyCosts_yearly(ay,pnz)*(activity_balances(tb,ay,pnz)<0)*TechExclussiveness(tb,pnz)] !For yearly activities
							+sum[ad, -activity_balances(tb,ad,pnz)*EnergyCosts_daily(dayPer_hour(h),ad,pnz)*(activity_balances(tb,ad,pnz)<0)*TechExclussiveness(tb,pnz)] !For daily activities
							+sum[ah, -activity_balances(tb,ah,pnz)*EnergyCosts_hourly(h,ah,pnz)*(activity_balances(tb,ah,pnz)<0)*TechExclussiveness(tb,pnz)] !For daily activities
							+sum[aer, -activity_balances(tb,aer,pnz)*EmissionCosts(aer,pnz)*(activityPer_tech(tb)<>aer)*TechExclussiveness(tb,pnz)]; !For emission costs
				
						!Obtain yearly energy costs for yearly energy activities
						EnergyCosts_yearly(ay,pnz):= max(h,sum[tb, Ptech_useNet(tb,pnz)*(Ptech_useNet(tb,pnz)>1e-2)*(activityPer_tech(tb)=ay)*techCosts_voc(h,tb,pnz)]
						/(sum[tb,(activityPer_tech(tb)=ay)*Ptech_useNet(tb,pnz)]+1e-10));
				
						!original calculation - yearly average, replaced by max annual cost, similar to hourly calculation
						!EnergyCosts_yearly(ay,pnz) := (sum[tb, (activityPer_tech(tb)=ay)*Ptech_useNet(tb,pnz)]>1e-2)*sum[(tb,h), 
						!	(activityPer_tech(tb)=ay)*Ptech_useNet(tb,pnz)*techCosts_voc(h,tb,pnz)]/(sum[tb, (activityPer_tech(tb)=ay)*Ptech_useNet(tb,pnz)+1e-10]*card(hours));
				
						!Obtain daily energy costs for daily energy activities
						EnergyCosts_daily(d,ad,pnz):=max(h,(dayPer_hour(h)=d)*sum[tb,Ptech_useDailyNet(d,tb,pnz)*(Ptech_useDailyNet(d,tb,pnz)>1e-7)*(activityPer_tech(tb)=ad)*techCosts_voc(h,tb,pnz)]
						/(sum[tb,(activityPer_tech(tb)=ad)*Ptech_useDailyNet(d,tb,pnz)]+1e-10));
				
						!original calculation - daily average, replaced by max daily cost, similar to hourly calculation
						!EnergyCosts_daily(d,ad,pnz) := sum[(tb,h), Ptech_useDailyNet(d,tb,pnz)*(Ptech_useDailyNet(d,tb,pnz)>1e-7)*(activityPer_tech(tb)=ad)*(dayPer_hour(h)=d)/hoursPer_day*techCosts_voc(h,tb,pnz)]
						!/sum[tb, Ptech_useDailyNet(d,tb,pnz)*(activityPer_tech(tb)=ad)+1e-20];		
				
						!Obtain hourly energy costs for hourly energy activities
						EnergyCosts_hourly(h,ah,pnz) := max(tb,(Ptech_useHourlyNet(h,tb,pnz)>0.001)*(activityPer_tech(tb)=ah)*techCosts_voc(h,tb,pnz));
				
						!Obtain secondary activities cost assuming there shpuld only be yearly activities without a main technology
						EnergyCosts_yearly(ass,pnz) := (sum[tb,(activity_balances(tb,ass,pnz)>0)*Ptech_useNet(tb,pnz)]>1e-2)*sum[(tb,h), 
							(activity_balances(tb,ass,pnz)>0)*Ptech_useNet(tb,pnz)*techCosts_voc(h,tb,pnz)]/(sum[tb, (activity_balances(tb,ass,pnz)>0)*Ptech_useNet(tb,pnz)+1e-10]*card(hours));
				
				
						IterCounter := IterCounter + 1;
					endwhile;
				!	EnergyCosts(h,as,pnz) := EnergyCosts_yearly(ae,pnz) + EnergyCosts_daily(dayPer_hour(h),ae,pnz) + EnergyCosts_hourly(h,ae,pnz) + EnergyCosts_yearly(ass,pnz);
					EnergyCosts(h,ae,pnz) := EnergyCosts_yearly(ae,pnz) + EnergyCosts_daily(dayPer_hour(h),ae,pnz) + EnergyCosts_hourly(h,ae,pnz);
				elseif (EnergyPricesChoice = 'Shadow Prices') then
					EnergyCosts(h,ae,pnz) := yearly_prices(ae,pnz) + daily_prices(dayPer_hour(h),ae,pnz) + hourly_prices(h,ae,pnz);
					EnergyCosts_yearly(ae,pnz) := yearly_prices(ae,pnz);
					EnergyCosts_daily(d,ae,pnz)  := daily_prices(d,ae,pnz);
					EnergyCosts_hourly(h,ae,pnz) := hourly_prices(h,ae,pnz);
				endif;
				
				!Fix the zeros due to non-usage of primaries
				EnergyCosts(h,ae,pnz) := EnergyCosts(h,ae,pnz) + yearly_prices(ae,pnz)		
					*(EnergyCosts_yearly(ae,pnz)=0)*(((ae in activities_hour)+(ae in activities_day))=0);
				
				!!Fix the zeros due to non-usage of primaries
				!EnergyCosts(h,ae,pnz) := EnergyCosts(h,ae,pnz)
				!	+ sum[tb, (activityPer_tech(tb)=ae)*(tech_category(tb)='Primary')*(Ptech_useNet(tb,pnz)<1e-2)*vom_cost(tb,pnz)]
				!	*(EnergyCosts_yearly(ae,pnz)=0)*(((ae in activities_hour)+(ae in activities_day))=0);
				
				
				!Empty houry tech costs parameter to save memory
				empty techCosts_voc;
				
				StatusMessage("Energy costs were succesfully obtained. " );
			}
		}
		Procedure ObtainResidualLoad {
			Body: {
				!Routine to get all the elements of the residual load report
				StatusMessage("Obtaining the residual load elements. . . " );
				
				!Delete the current values of residual load
				empty residual_load;
				
				!{'Load (no flex)','Wind','Solar','Run of River','Residual Load','Imports','Exports','Shedding','CHPs UP','CHPs DW','Smart Charging UP',
				!'Smart Charging DW','V-to-G UP','V-to-G DW','Load Shifting UP','Load Shifting DW','Storage UP','Storage DW','Curtailment','Remaining'}
				
				residual_load(nn,h,torl,p) := (
				if (torl='Load (no flex)') then
					-sum[(ah,itb), IEM_node(nodePer_techBal(itb))*(namePer_node(nodePer_act(ah))=nn)*(namePer_node(nodePer_techBal(itb))=nn)*
						(activity_balances(itb,ah,p)<0)*(labelPer_act(ah)='Electricity')*(tech_subsector(itb)<>"XC Trade")*
						((itb in tech_shedding)=shedding_inLoad)* !This is to dissable shedding technologies from the accounting of res load, if we want to consider them we just need to comment the line
						activity_balances(itb,ah,p)*(
						Ptech_useHourly(h,itb,p) !Hourly dispatch units including transformers
						+Ptech_useDaily(dayPer_hour(h),itb,p)/hoursPer_day !Daily dispatch units (asssuming flat daily consumption of electricity)
						+(PdeltaB_DW(dayPer_hour(h),itb,p)-PdeltaB_UP(dayPer_hour(h),itb,p))/hoursPer_day !Gas buffers consumption (asssuming flat hourly consumption of electricity)
						+Ptech_use(itb,p)*hourly_profiles(h,profileType_tech(itb))  !Operation of all technologies
					)]
					-sum[(ah,itb), IEM_node(nodePer_techBal(itb))*(namePer_node(nodePer_act(ah))=nn)*(namePer_node(nodePer_techBal(itb))=nn)*
						(labelPer_act(ah)='Electricity')*(tech_subsector(itb)="XC Trade")*(tech_category(itb)<>"Primary")*
						activity_balances(itb,ah,p)*Ptech_useHourly(h,itb,p) !Operation of all technologies
					]	
				elseif (torl='Wind') then
					-sum[(ae,tb), (labelPer_act(ae)='Wind')*(activity_balances(tb,ae,p)<0)*(namePer_node(nodePer_techBal(tb))=nn)*IEM_node(nodePer_techBal(tb))*
						PtechStock(tb,p)*cap2act(tb)*hourly_profiles(h,profileType_tech(tb))]
				elseif (torl='Solar') then
					-sum[(ae,tb), (ae='Solar Energy')*(activity_balances(tb,ae,p)<0)*(namePer_node(nodePer_techBal(tb))=nn)*IEM_node(nodePer_techBal(tb))*
						PtechStock(tb,p)*cap2act(tb)*hourly_profiles(h,profileType_tech(tb))]
				elseif (torl='Run of River') then
					-sum[(ae,th), (StringOccurrences(profileType_tech(th),"Hydro RoR")>0)*(namePer_node(nodePer_techBal(th))=nn)*IEM_node(nodePer_techBal(th))*
						PtechStock(th,p)*cap2act(th)*hourly_profiles(h,profileType_tech(th))]
				elseif (torl='Baseload Generation') then
					-sum[(ae,th), (labelPer_act(ae)='Electricity')*(namePer_node(nodePer_techBal(th))=nn)*IEM_node(nodePer_techBal(th))*
						(ramping(th)<>0)*(ramping(th)<baseload_treshold)*(activity_balances(th,ae,p)>0)*
						Ptech_useHourly(h,th,p)*activity_balances(th,ae,p)]
				endif
				);
				
				!Obtain the residual load
				residual_load(nn,h,'Residual Load',p) := residual_load(nn,h,'Load (no flex)',p)+residual_load(nn,h,'Wind',p)+residual_load(nn,h,'Solar',p)
					+residual_load(nn,h,'Run of River',p)+residual_load(nn,h,'Baseload Generation',p);
				
				!Obtain differential residual load
				diferential_resLoad(nn,h,p) := (
				if (h<>1) then
					residual_load(nn,h,'Residual Load',p)-residual_load(nn,h-1,'Residual Load',p)
				elseif (h=1) then
					residual_load(nn,h,'Residual Load',p)-residual_load(nn,card(h),'Residual Load',p)
				endif
				);
				
				!Obtain decomposition residual load
				decomposition_resLoad(nn,h,torlf,p) := (
				if (torlf='Imports') then
					sum[(n,tb,ahe), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(nodePer_act(ahe)<>n)
					*(activity_balances(tb,ahe,p)<0)*Ptech_useHourlyNet(h,tb,p)]
				elseif (torlf='Exports') then
					sum[(n,tb,ahe), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_act(ahe)=n)*(nodePer_techBal(tb)<>n)
					*(activity_balances(tb,ahe,p)<0)*Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ahe,p)]
				elseif (torlf='Curtailment') then
					sum[(ae,th), (labelPer_act(ae)='Wind')*(activity_balances(th,ae,p)<0)*(namePer_node(nodePer_techBal(th))=nn)*IEM_node(nodePer_techBal(th))*
					(Ptech_useHourly(h,th,p)-PtechStock(th,p)*cap2act(th)*hourly_profiles(h,profileType_tech(th)))]
					+sum[(ae,th), (labelPer_act(ae)='Solar')*(activity_balances(th,ae,p)<0)*(namePer_node(nodePer_techBal(th))=nn)*IEM_node(nodePer_techBal(th))*
					(Ptech_useHourly(h,th,p)-PtechStock(th,p)*cap2act(th)*hourly_profiles(h,profileType_tech(th)))]
					+sum[th, (StringOccurrences(profileType_tech(th),"Hydro RoR")>0)*(namePer_node(nodePer_techBal(th))=nn)*IEM_node(nodePer_techBal(th))*
					(Ptech_useHourly(h,th,p)-PtechStock(th,p)*cap2act(th)*hourly_profiles(h,profileType_tech(th)))]
				elseif (torlf='Storage') then
					sum[(n,tfb),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tfb)=n)*PdeltaQ_DW(h,tfb,p)]
					+sum[(n,tfb),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tfb)=n)*PdeltaQ_UP(h,tfb,p)]
					+sum[(n,tfvg),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tfvg)=n)*PdeltaQ_DW(h,tfvg,p)]
					+sum[(n,tfvg),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tfvg)=n)*PdeltaQ_UP(h,tfvg,p)]
				elseif (torlf='Flex Generation') then
					sum[(n,ae,tb), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(tech_subsector(tb)<>"XC Trade")
					*(labelPer_act(ae)='Electricity')*((ramping(tb)=0)+(ramping(tb)>baseload_treshold))*(activity_balances(tb,ae,p)>0)*
					Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ae,p)]
					+sum[(n,ah,tk), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tk)=n)
					*PdeltaP_CHP(h,tk,p)*dP_electricity(tk,ah)] !Flexibility in Power/Heat range of CHP output
					-sum[(ae,tb), (labelPer_act(ae)='Wind')*(activity_balances(tb,ae,p)<0)*(namePer_node(nodePer_techBal(tb))=nn)*IEM_node(nodePer_techBal(tb))*
					Ptech_useHourlyNet(h,tb,p)]
					-sum[(ae,tb), (ae='Solar Energy')*(activity_balances(tb,ae,p)<0)*(namePer_node(nodePer_techBal(tb))=nn)*IEM_node(nodePer_techBal(tb))*
					Ptech_useHourlyNet(h,tb,p)]
					-sum[(ae,th), (StringOccurrences(profileType_tech(th),"Hydro RoR")>0)*(namePer_node(nodePer_techBal(th))=nn)*IEM_node(nodePer_techBal(th))*
					Ptech_useHourly(h,th,p)]
				elseif (torlf='Demand Response') then
					sum[(n,tfe),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tfe)=n)*PdeltaQ_DW(h,tfe,p)]
					+sum[(n,tfe),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tfe)=n)*PdeltaQ_UP(h,tfe,p)]
					+sum[(n,tfs),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tfs)=n)*PdeltaQ_DW(h,tfs,p)]
					+sum[(n,tfs),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tfs)=n)*PdeltaQ_UP(h,tfs,p)]
					+sum[(n,tfvc),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tfvc)=n)*PdeltaQ_DW(h,tfvc,p)]
					+sum[(n,tfvc),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tfvc)=n)*PdeltaQ_UP(h,tfvc,p)]
					+(shedding_inLoad=0)*sum[(n,ahe,ts),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(ts)=n)*(nodePer_act(ahe)=n)*
					(Ptech_use(ts,p)*hourly_profiles(h,profileType_tech(ts))+PdeltaS_shed(h,ts,p))*activity_balances(ts,ahe,p)] !Shedded use of technologies
					+shedding_inLoad*sum[(n,ahe,ts),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(ts)=n)*(nodePer_act(ahe)=n)*
					PdeltaS_shed(h,ts,p)*activity_balances(ts,ahe,p)] !Shedding of technologies
				endif
				);
				
				!Obtain the missing component
				decomposition_resLoad(nn,h,'Other',p) := residual_load(nn,h,'Residual Load',p) - sum[torlf, decomposition_resLoad(nn,h,torlf,p)];
				
				StatusMessage("Residual load parameters calculated. . . " );
			}
		}
		Procedure PostProcessParameters {
			Body: {
				StatusMessage("Post-processing parameters. . . " );
				!Delete the reporting parameters
				empty RSystemCosts_n, RSystemCosts_sec_n, RSectoralConfiguration_stock, RSectoralConfiguration_use, RPower_stock, RPower_gen, RXC_stock, RXC_use;
				empty Remissions_all,  Remissions_sec, RsupdemAct_tech, RfinalEnergy_matrix, RfinalEnergy_act, RprimaryBalance, Rsankey_flows, REnergyCosts_node, REnergyCosts_node_secondary;
				empty RPower_dispatch, RPowerInfo_act, RXCinfo_act, RloadProfiles_H, RflexProfiles_H, RloadProfiles_D, RfinProfiles_D, Rprofiles3D;
				empty Rfinal_decomposition, RcurtailmentRES, Relectricity_parameters, Rflexibility_volumes, Rkey_indicators, RLCOE, RSectoralCosts_cascade;
				empty RSystemCosts_sec_tot, Rprimary_renewable, REnergyCosts_hourly, REnergyCosts_nodeD, RPlanningDecissions_tech, RintTransport_indicators;
				empty REnergyCosts_node, Rresidual_load, RSystemCosts_act_n, Remissions_act, Rflexibility_volumesAct, RfinalEnergy_matrixAct, Rdecomposition_resLoad;
				empty Rdecomposition_resLoadY, Rflexibility_volumesTech, RenergyUse_act, Remissions_tech, RLCOP_secE, RLCOP_act, Rshadow_energyPrices;
				empty Rshadow_CO2Prices, Rshadow_CO2prices_single;
				
				!Assign post-processed parameters
				RSystemCosts_n(nn,toc,pnz) := SystemCosts_n(nn,toc,pnz);
				RSystemCosts_sec_n(nn,z,tots,toc,pnz) := SystemCosts_sec_n(nn,z,tots,toc,pnz);
				RSectoralConfiguration_stock(nn,z,as,tots,t,pnz) := SectoralConfiguration_stock(nn,z,as,tots,t,pnz);
				RSectoralConfiguration_use(nn,z,as,tots,t,pnz) := SectoralConfiguration_use(nn,z,as,tots,t,pnz);
				RPower_stock(nn,tb,pnz) := Power_stock(nn,tb,pnz);
				RPower_gen(nn,tb,pnz) := Power_gen(nn,tb,pnz);
				RXC_stock(inn,nn,tb,pnz) := XC_stock(inn,nn,tb,pnz);
				RXC_use(inn,nn,tb,pnz) := XC_use(inn,nn,tb,pnz);
				Remissions_all(nn,t_c,pnz) := emissions_all(nn,t_c,pnz);
				Remissions_sec(nn,z,aer,pnz) := emissions_sec(nn,z,aer,pnz);
				RsupdemAct_tech(nn,as,tob,tb,tn,pnz) := supdemAct_tech(nn,as,tob,tb,tn,pnz);
				RfinalEnergy_matrix(nn,z,tof,el,pnz) := finalEnergy_matrix(nn,z,tof,el,pnz);
				RfinalEnergy_act(nn,z,as,pnz) := finalEnergy_act(nn,z,as,pnz);
				RprimaryBalance(nn,tope,el,pnz) := primaryBalance(nn,tope,el,pnz);
				Rsankey_flows(nn,tou,itos,jtos,pnz) := sankey_flows(nn,tou,itos,jtos,pnz);
				Rfinal_decomposition(nn,tod,pnz) := final_decomposition(nn,tod,pnz);
				RcurtailmentRES(nn,th,pnz) := curtailmentRES(nn,th,pnz);
				Relectricity_parameters(nn,toep,pnz) := electricity_parameters(nn,toep,pnz);
				Rflexibility_volumes(nn,tox,pnz) := flexibility_volumes(nn,tox,pnz);
				Rkey_indicators(nn,tok,pnz) := key_indicators(nn,tok,pnz);
				RLCOE(nn,as,tb,tolm,tol,pnz) := LCOE(nn,as,tb,tolm,tol,pnz);
				RSectoralCosts_cascade(nn,z,toc,pnz) := SectoralCosts_cascade(nn,z,toc,pnz);
				RSystemCosts_sec_tot(nn,z,pnz) := SystemCosts_sec_tot(nn,z,pnz);
				Rprimary_renewable(nn,el,pnz) := primary_renewable(nn,el,pnz);
				RPlanningDecissions_tech(nn,t,topd,pnz) := PlanningDecisions_tech(nn,t,topd,pnz);
				RPowerInfo_act(ahee,topi,tb,pnz) := PowerInfo_act(ahee,topi,tb,pnz);
				RXCinfo_act(iahee,ahee,topi,tb,pnz) := XCinfo_act(iahee,ahee,topi,tb,pnz);
				RintTransport_indicators(toitr,pnz) := intTransport_indicators(toitr,pnz);
				REnergyCosts_node(nn,ae,pnz) := EnergyCosts_node(nn,ae,pnz);
				REnergyCosts_node_secondary(nn,ass,pnz) := EnergyCosts_node_secondary(nn,ass,pnz);
				RSystemCosts_act_n(nn,z,as,tots,toc,pnz) := SystemCosts_act_n(nn,z,as,tots,toc,pnz);
				Remissions_act(nn,z,as,aer,pnz) := emissions_act(nn,z,as,aer,pnz);
				Rflexibility_volumesAct(nn,z,as,tox,pnz) := flexibility_volumesAct(nn,z,as,tox,pnz);
				RfinalEnergy_matrixAct(nn,z,as,tof,el,pnz) := finalEnergy_matrixAct(nn,z,as,tof,el,pnz);
				Rflexibility_volumesTech(nn,tb,tox,pnz) := flexibility_volumesTech(nn,tb,tox,pnz);
				RenergyUse_act(nn,z,as,ae,pnz) := energyUse_act(nn,z,as,ae,pnz);
				Remissions_tech(nn,z,as,tb,tn,aer,pnz) := emissions_tech(nn,z,as,tb,tn,aer,pnz);
				RLCOP_secE(nn,z,tots,toc,pnz) := LCOP_secE(nn,z,tots,toc,pnz);
				RLCOP_act(nn,z,as,tots,toc,pnz) := LCOP_act(nn,z,as,tots,toc,pnz);
				Rshadow_energyPrices(nn,ae,pnz) := shadow_energyPrices(nn,ae,pnz);
				Rshadow_CO2Prices(nn,acf,pnz) := shadow_CO2Prices(nn,acf,pnz);
				Rshadow_CO2Prices_single(n,p):=CO2_price_single(n,p);
				
				!If hourly reports are required
				if (HourlyReportValue = 'yes') then
					StatusMessage("Post-processing hourly profiles . . . " );
					!Calculate the parameters
					Power_dispatch(nn,h,tb,p) := (labelPer_act(activityPer_tech(tb))='Electricity')*Ptech_useHourlyNet(h,tb,p)*(namePer_node(nodePer_techBal(tb))=nn)*IEM_node(nodePer_techBal(tb));
					loadProfiles_H(nn,h,ah,p) := (namePer_node(nodePer_act(ah))=nn)*(
						sum[itb | activity_balances(itb,ah,p)<0, activity_balances(itb,ah,p)*(
						Ptech_useHourly(h,itb,p) !Hourly dispatch units
						+Ptech_useDaily(dayPer_hour(h),itb,p)/hoursPer_day !Daily dispatch units (asssuming flat daily consumption of electricity)
						+(PdeltaB_DW(dayPer_hour(h),itb,p)-PdeltaB_UP(dayPer_hour(h),itb,p))/hoursPer_day !Gas buffers consumption (asssuming flat hourly consumption of electricity)
						+Ptech_use(itb,p)*hourly_profiles(h,profileType_tech(itb))  !Operation of all technologies
						+PdeltaS_shed(h,itb,p))] !Shedding
						+sum[tf, (PdeltaQ_UP(h,tf,p)+PdeltaQ_DW(h,tf,p)*(1-(tf in tech_fStorage)))*dQ_hourly(tf,ah)] !Upwards response of flexible technologies
					);
					refProfiles_H(nn,h,tb,p) :=-Ptech_use(tb,p)*hourly_profiles(h,profileType_tech(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(		
						sum[ah | dQ_hourly(tb,ah)=1, activity_balances(tb,ah,p)]*(sum[ih, -PdeltaQ_UP(ih,tb,p)+PdeltaQ_DW(ih,tb,p)]>0) !Felxible technologies
						+sum[ah | dS_hourly(tb,ah)=1, activity_balances(tb,ah,p)]*(sum[ih, -PdeltaS_shed(ih,tb,p)]>0) !Shedding technologies
						-sum[ah | dP_electricity(tb,ah)=1, activity_balances(tb,ah,p)]*(sum[ih, PdeltaU_CHP(ih,tb,p)+PdeltaP_CHP(ih,tb,p)]<>0) !Flexible CHPs
					);
					finProfiles_H(nn,h,tb,p) :=(namePer_node(nodePer_techBal(tb))=nn)*(refProfiles_H(nn,h,tb,p)+
						(-PdeltaQ_UP(h,tb,p)-PdeltaQ_DW(h,tb,p))*(sum[ih, -PdeltaQ_UP(ih,tb,p)+PdeltaQ_DW(ih,tb,p)]>0) !Felxible technologies
						-sum[ah | dS_hourly(tb,ah)=1, PdeltaS_shed(h,tb,p)*activity_balances(tb,ah,p)]*(sum[ih, -PdeltaS_shed(ih,tb,p)]>0)!Shedding technologies
						-sum[ah | dP_electricity(tb,ah)=1, (PdeltaU_CHP(h,tb,p)*activity_balances(tb,ah,p)+PdeltaP_CHP(h,tb,p)*dP_electricity(tb,ah))]*(sum[ih, PdeltaU_CHP(ih,tb,p)+PdeltaP_CHP(ih,tb,p)]<>0) !Flexible CHPs: power output. In the future, it would be nice to report the heat output as well. 
					);
				
					flexProfiles_H(nn,'Reference',h,tb,p) := refProfiles_H(nn,h,tb,p);
					flexProfiles_H(nn,'Final',h,tb,p) := finProfiles_H(nn,h,tb,p);
				
					StatusMessage("Still doing hourly post-processing, be patient . . . " );
				
					loadProfiles_D(nn,d,ad,p) := (namePer_node(nodePer_act(ad))=nn)*(
						sum[itb | activity_balances(itb,ad,p)<0, activity_balances(itb,ad,p)* !Only account for the demand
						(Ptech_useDaily(d,itb,p) !Daily dispatch units
						+sum[ih | dayPer_hour(ih)=d, Ptech_useHourly(ih,itb,p) !Hourly dispatch units
						+deltaB_DW(d,itb,p)-deltaB_UP(d,itb,p) !Gas buffers consumption 
						+hourly_profiles(ih,profileType_tech(itb))*
						(Ptech_use(itb,p) !Operation of non dispatchable technologies
						+PdeltaU_CHP(ih,itb,p) !Operation of flexible CHPs
						+PdeltaS_shed(ih,itb,p))])] !Operation of shedding technologies
						+sum[tg, PdeltaB_UP(d,tg,p)*dB_daily(tg,ad)] !Daily buffer units
					);
					refProfiles_D(nn,d,tg,p) := -Ptech_use(tg,p)*(namePer_node(nodePer_techBal(tg))=nn)*
						sum[ad | dB_daily(tg,ad)=1, activity_balances(tg,ad,p)]*sum[ih | dayPer_hour(ih)=d, hourly_profiles(ih,profileType_tech(tg))];
					finProfiles_D(nn,d,tg,p) := (namePer_node(nodePer_techBal(tg))=nn)*(refProfiles_D(nn,d,tg,p)-PdeltaB_UP(d,tg,p)-PdeltaB_DW(d,tg,p));
					profiles3D(nn,w,h_d,t3a,p) := 
						(t3a in activities_hour)
						*(namePer_node(nodePer_act(t3a))=nn)*sum[ih, loadProfiles_H(nn,ih,t3a,p)*(weekPer_hour(ih)=w)*(hoursindayPer_hour(ih)=h_d)]/7
						+((t3a in activities_hour)=0)	
						*(namePer_node(nodePer_act(t3a))=nn)*sum[(ih,th), Ptech_useHourlyNet(ih,th,p)*activity_balances(th,t3a,p)*(weekPer_hour(ih)=w)*(hoursindayPer_hour(ih)=h_d)]/7;
					StatusMessage("Obtaining residual load, be patient. . . " );
					ObtainResidualLoad;	
				
					!Report the parameters
					RPower_dispatch(nn,h,tb,pnz) := Power_dispatch(nn,h,tb,pnz);
					RloadProfiles_H(nn,h,ah,pnz) := loadProfiles_H(nn,h,ah,pnz);
					RflexProfiles_H(nn,topp,h,tb,pnz) := flexProfiles_H(nn,topp,h,tb,pnz);
					RloadProfiles_D(nn,d,ad,pnz) := loadProfiles_D(nn,d,ad,pnz);
					RfinProfiles_D(nn,d,tg,pnz) := finProfiles_D(nn,d,tg,pnz);
					Rprofiles3D(nn,w,h_d,t3a,pnz) := profiles3D(nn,w,h_d,t3a,pnz);
					REnergyCosts_hourly(h,ah,pnz) := EnergyCosts_hourly(h,ah,pnz);
					REnergyCosts_nodeD(nn,d,ad,pnz) := EnergyCosts_nodeD(nn,d,ad,pnz);
					Rresidual_load(nn,h,torl,pnz) := residual_load(nn,h,torl,pnz);
					Rkey_indicators(nn,tok,pnz) := key_indicators(nn,tok,pnz);
					Rdecomposition_resLoad(nn,h,torlf,pnz) := decomposition_resLoad(nn,h,torlf,pnz); 
					Rdecomposition_resLoadY(nn,torlf,pnz) := decomposition_resLoadY(nn,torlf,pnz); 
				endif;
				
				
				StatusMessage("Parameters were succesfully processed" );
			}
		}
		Procedure RoundParameters {
			Body: {
				StatusMessage("Rounding the results . . . " );
				
				!Rounding parameters to be reported
				RSystemCosts_n(nn,toc,pnz) := round(RSystemCosts_n(nn,toc,pnz),2);
				RSystemCosts_sec_n(nn,z,tots,toc,pnz) := round(RSystemCosts_sec_n(nn,z,tots,toc,pnz),2);
				RSectoralConfiguration_stock(nn,z,as,tots,t,pnz) := round(RSectoralConfiguration_stock(nn,z,as,tots,t,pnz),4);
				RSectoralConfiguration_use(nn,z,as,tots,t,pnz) := round(RSectoralConfiguration_use(nn,z,as,tots,t,pnz),3);
				RPower_stock(nn,tb,pnz) := round(RPower_stock(nn,tb,pnz),2);
				RPower_gen(nn,tb,pnz) := round(RPower_gen(nn,tb,pnz),2);
				RXC_stock(inn,nn,tb,pnz) := round(RXC_stock(inn,nn,tb,pnz),2);
				RXC_use(inn,nn,tb,pnz) := round(RXC_use(inn,nn,tb,pnz),2);
				Remissions_all(nn,t_c,pnz) := round(Remissions_all(nn,t_c,pnz),2);
				Remissions_sec(nn,z,aer,pnz) := round(Remissions_sec(nn,z,aer,pnz),2);
				RsupdemAct_tech(nn,as,tob,tb,tn,pnz) := round(RsupdemAct_tech(nn,as,tob,tb,tn,pnz),2);
				RfinalEnergy_matrix(nn,z,tof,el,pnz) := round(RfinalEnergy_matrix(nn,z,tof,el,pnz),2);
				RfinalEnergy_act(nn,z,as,pnz) := round(RfinalEnergy_act(nn,z,as,pnz),2);
				RprimaryBalance(nn,tope,el,pnz) := round(RprimaryBalance(nn,tope,el,pnz),2);
				Rsankey_flows(nn,tou,itos,jtos,pnz) := round(Rsankey_flows(nn,tou,itos,jtos,pnz),2);
				Rfinal_decomposition(nn,tod,pnz) := round(Rfinal_decomposition(nn,tod,pnz),2);
				RcurtailmentRES(nn,th,pnz) := round(RcurtailmentRES(nn,th,pnz),2);
				Relectricity_parameters(nn,toep,pnz) := round(Relectricity_parameters(nn,toep,pnz),2);
				Rflexibility_volumes(nn,tox,pnz) := round(Rflexibility_volumes(nn,tox,pnz),2);
				Rkey_indicators(nn,tok,pnz) := round(Rkey_indicators(nn,tok,pnz),2);
				RLCOE(nn,as,tb,tolm,tol,pnz) := round(RLCOE(nn,as,tb,tolm,tol,pnz),2);
				RSectoralCosts_cascade(nn,z,toc,pnz) := round(RSectoralCosts_cascade(nn,z,toc,pnz),2);
				RSystemCosts_sec_tot(nn,z,pnz) := round(RSystemCosts_sec_tot(nn,z,pnz),2);
				Rprimary_renewable(nn,el,pnz) := round(Rprimary_renewable(nn,el,pnz),2);
				RPlanningDecissions_tech(nn,t,topd,pnz) := round(RPlanningDecissions_tech(nn,t,topd,pnz),2);
				RPowerInfo_act(ahee,topi,tb,pnz) := round(RPowerInfo_act(ahee,topi,tb,pnz),2);
				RXCinfo_act(iahee,ahee,topi,tb,pnz) := round(RXCinfo_act(iahee,ahee,topi,tb,pnz),2);
				RintTransport_indicators(toitr,pnz) := round(RintTransport_indicators(toitr,pnz),2);
				REnergyCosts_node(nn,ae,pnz) := round(REnergyCosts_node(nn,ae,pnz),2);
				REnergyCosts_node_secondary(nn,ass,pnz) := round(REnergyCosts_node_secondary(nn,ass,pnz),2);
				RSystemCosts_act_n(nn,z,as,tots,toc,pnz) := round(RSystemCosts_act_n(nn,z,as,tots,toc,pnz),2);
				Remissions_act(nn,z,as,aer,pnz) := round(Remissions_act(nn,z,as,aer,pnz),2);
				Rflexibility_volumesAct(nn,z,as,tox,pnz) := round(Rflexibility_volumesAct(nn,z,as,tox,pnz),2);
				RfinalEnergy_matrixAct(nn,z,as,tof,el,pnz) := round(RfinalEnergy_matrixAct(nn,z,as,tof,el,pnz),2);
				Rdecomposition_resLoadY(nn,torlf,pnz) := round(Rdecomposition_resLoadY(nn,torlf,pnz),2);
				Rflexibility_volumesTech(nn,tb,tox,pnz) := round(Rflexibility_volumesTech(nn,tb,tox,pnz),2);
				RenergyUse_act(nn,z,as,ae,pnz) := round(RenergyUse_act(nn,z,as,ae,pnz),2);
				Remissions_tech(nn,z,as,tb,tn,aer,pnz) := round(Remissions_tech(nn,z,as,tb,tn,aer,pnz),2);
				RLCOP_secE(nn,z,tots,toc,pnz) := round(RLCOP_secE(nn,z,tots,toc,pnz),2);
				RLCOP_act(nn,z,as,tots,toc,pnz) := round(RLCOP_act(nn,z,as,tots,toc,pnz),2);
				Rshadow_energyPrices(nn,ae,pnz) := round(Rshadow_energyPrices(nn,ae,pnz),2);
				Rshadow_CO2Prices(nn,acf,pnz) := round(Rshadow_CO2Prices(nn,acf,pnz),2);
				Rshadow_CO2Prices_single(n,p):=round(Rshadow_CO2Prices_single(n,p),2);
				
				!If hourly reports are required
				if (HourlyReportValue = 'yes') then
					RPower_dispatch(nn,h,tb,pnz) := round(RPower_dispatch(nn,h,tb,pnz),8);
					RloadProfiles_H(nn,h,ah,pnz) := round(RloadProfiles_H(nn,h,ah,pnz),8);
					RflexProfiles_H(nn,topp,h,tb,pnz) := round(RflexProfiles_H(nn,topp,h,tb,pnz),8);
					RloadProfiles_D(nn,d,ad,pnz) := round(RloadProfiles_D(nn,d,ad,pnz),8);
					RfinProfiles_D(nn,d,tg,pnz) := round(RfinProfiles_D(nn,d,tg,pnz),8);
					Rprofiles3D(nn,w,h_d,t3a,pnz) := round(Rprofiles3D(nn,w,h_d,t3a,pnz),4);
					REnergyCosts_hourly(h,ah,pnz) := round(REnergyCosts_hourly(h,ah,pnz),2);
					REnergyCosts_nodeD(nn,d,ad,pnz) := round(REnergyCosts_nodeD(nn,d,ad,pnz),2);
					Rresidual_load(nn,h,torl,pnz) := round(Rresidual_load(nn,h,torl,pnz),8);
					Rdecomposition_resLoad(nn,h,torlf,pnz) := round(Rdecomposition_resLoad(nn,h,torlf,pnz),8);
				endif;
				
				StatusMessage("Results were rounded. " );
			}
		}
		Procedure PostProcess_andWrite {
			Body: {
				StatusMessage("Post-process parameters . . . " );
				!Post process parameters
				PostProcessParameters;
				
				StatusMessage("Rounding parameters . . . " );
				!Round parameters
				RoundParameters;
				
				! Creat a directory for Output files
				if (DirectoryExists("Output/"+OutputFolderName) = 0) then DirectoryCreate("Output/"+OutputFolderName); endif;
				
				!Save the case
				StatusMessage("Saving the case as a datafile ..." );
				CaseFileSave("Output/"+OutputFolderName+"/"+OutputFolderName+".data",AllIdentifiers);
				
				StatusMessage("Saving excel files . . . " );
				!Write the output
				runDataWritingTransition;
				
				!Play the alarm
				AIMMSWav(Beep);
				
				StatusMessage("Post-process and write is finished. " );
			}
		}
	}
	Section User_Interface {
		Section Sounds {
			StringParameter AIMMSWavDLL {
				Definition: {
					if AimmsStringConstants('Architecture') = 'x86' then
					        "Aimmswav.dll"
					else
					        "Aimmswav64.dll"
					endif
				}
			}
			ExternalProcedure AIMMSWav {
				Arguments: (AWWavFile,AWAsync);
				DllName: "Alarm\\AimmsWav64.dll";
				ReturnType: integer;
				BodyCall: PlayWavFile( string scalar: AWWavFile, integer scalar: AWAsync );
				Comment: "This procedure will play the specified \'AWWavFile\' asynchronized (\'AWAsync\'=0) or synchronized (\'AWAsync\'=1)";
				StringParameter AWWavFile {
					Property: Input;
				}
				Parameter AWAsync {
					Range: binary;
					Default: 1;
					Property: Optional;
				}
			}
			DeclarationSection Sound_Declarations {
				StringParameter Finalized {
					Default: "Alarm\\finalized.wav";
					Definition: "Alarm\\finalized.wav";
				}
				StringParameter Beep {
					Default: "Alarm\\beep.wav";
					Definition: "Alarm\\beep.wav";
				}
				StringParameter Failed {
					Default: "Alarm\\failed.wav";
					Definition: "Alarm\\failed.wav";
				}
			}
			Procedure AuxProcedure {
				Body: {
					!Procedure to perform calculations or modify values of parameters without reruning the whole program
					
					
					!periods_selection := {2030,2035,2040,2045,2050};
					!techStock(t,pss) := StechStock(t,pss);
					!if (IntrayearValue='min-max') then
					!	!Fix the stocks for the next runs
					!	techStock(tn,pss):=max(techStock(tn,pss)*10000,0)/10000;
					!	techStock_min(tn,pss):=techStock(tn,pss)*(1-techStock_tolerance)*(techStock(tn,pss)>1e-5);
					!	techStock_max(tn,pss):=min(techStock(tn,pss)*(1+techStock_tolerance),techStock_max(tn,pss))*(techStock(tn,pss)>1e-5);
					!elseif (IntrayearValue='Pstock') then
					!	!Fix the stocks for the next runs
					!	TechStock_roundUP;
					!	techStock(t,pss).nonvar:=1;
					!endif;
					
					!!4) Store tech_stock for a test run
					!StechStock(t,p) := techStock(t,p);
					
					!!3) Test the reporting of the flexibility profiles
					!empty RrefProfiles_flex, RfinProfiles_flex;
					!RrefProfiles_flex(h,tb,pnz) := refProfiles_flex(h,tb,pnz);
					!RfinProfiles_flex(h,tb,pnz) := finProfiles_flex(h,tb,pnz);
					
					!!2) Add Imported Natural Gas to the energy types set on 22/Sep/2020 
					!set_of_everything := set_of_everything + StringToElement(set_of_everything,"Imported Natural Gas",1);
					!energy_types := energy_types + StringToElement(energy_types,"Imported Natural Gas",1);
					
					!!1) Give value to Pyearly_prices and PCO2_prices
					!Pyearly_prices(as,p) := yearly_prices(as,p);
					!PCO2_prices(ac,p) := CO2_prices(ac,p);
					
					StatusMessage("Aux procedure finished" );
				}
			}
		}
		DeclarationSection UI_declaration {
			StringParameter project_name {
				InitialData: "update project name";
			}
			Set periods_window {
				SubsetOf: periods_selection;
			}
			Set periods_nonzeros {
				SubsetOf: periods;
				Index: pnz, ipnz;
				Definition: {
					{p | sum[t, Ptech_use(t,p)]>0}
				}
			}
			Set OutputFolderOptions {
				Index: ofo;
				Definition: {
					{'automatic','custom'}
				}
			}
			Set EnergyPricesOptions {
				OrderBy: User;
				Definition: data {'Shadow Prices' ,'Marginal Costs'};
			}
			Set SolveMethods {
				OrderBy: User;
				Definition: data {'Barrier' ,'Concurrent'};
			}
			Set SolveMethodsBatch {
				OrderBy: User;
				Definition: {
					data {'Barrier' 
					!,'Warm start'
					}
				}
			}
			Set RobustOptions {
				Index: oro;
				Definition: {
					{'yes','no'}
				}
			}
			Set DataCasesSet;
			Set InputFilesSet {
				Index: fs, ifs, jfs;
			}
			Set InputFilesSetBatch {
				Index: fsb, ifsb, jfsb;
			}
			Set InputFilesSelection {
				SubsetOf: InputFilesSet;
			}
			Set InputFilesSelectionBatch {
				SubsetOf: InputFilesSetBatch;
			}
			Set ConstraintGroups {
				Definition: data {'Base' ,'ADAPT','TRANSFORM','ADAPT + bunker aviation & navigation policy','Base + DMI' , 'Base + DMI without emissions', 'Base + Bunkers in a single constraint','ADAPT with bunkers in single constraint','Base + RFNBO targets','Linking scenario', 'Linking scenario + Scope 3'};
			}
			ElementParameter OutputFolderValue {
				Range: OutputFolderOptions;
				InitialData: 'automatic';
			}
			ElementParameter PricesValue {
				Range: YesNo;
				InitialData: 'no';
			}
			ElementParameter ScaleValue {
				Range: YesNo;
				InitialData: 'yes';
			}
			ElementParameter LinearPresolveValue {
				Range: YesNo;
				InitialData: 'yes';
			}
			ElementParameter DataCaseLocation {
				Range: DataCasesSet;
			}
			ElementParameter DataReadingLocation {
				Range: InputFilesSet;
			}
			ElementParameter DataReadingLocationBatch {
				Range: InputFilesSetBatch;
			}
			ElementParameter crossover_enabling {
				Range: YesNo;
				InitialData: 'no';
			}
			ElementParameter HourlyReportValue {
				Range: YesNo;
				InitialData: 'no';
			}
			ElementParameter SaveCaseValue {
				Range: YesNo;
				InitialData: 'no';
			}
			StringParameter OutputFolderName;
			StringParameter OutputFolderPrefix;
			ElementParameter EnergyPricesChoice {
				Range: EnergyPricesOptions;
				InitialData: 'Shadow Prices';
			}
			ElementParameter SolveMethodChoice {
				Range: SolveMethods;
				InitialData: 'Barrier';
			}
			ElementParameter SolveMethodChoiceBatch {
				Range: SolveMethodsBatch;
				InitialData: 'Barrier';
			}
			ElementParameter SolverChoice {
				Range: AllSolvers;
				InitialData: 'GUROBI 12.0';
			}
			ElementParameter ShowProgress {
				Range: YesNo;
				InitialData: 'yes';
			}
			ElementParameter ActiveConstraintGroup {
				Range: ConstraintGroups;
				InitialData: 'Base';
			}
			ElementParameter ShowViolations {
				Range: YesNo;
				InitialData: 'No';
			}
			Parameter Violation_Hide {
				Range: binary;
				Definition: {
					if ShowViolations = 'Yes' then 0 else 1 endif;
				}
			}
			Parameter CPUCores {
				Range: {
					{0..NumCPU}
				}
				InitialData: 0;
			}
			Parameter OutputName_Hide {
				Range: binary;
				Definition: OutputFolderValue='automatic';
			}
			Parameter SBS_counter {
				InitialData: 0;
			}
			Parameter SBS_length {
				Definition: card(InputFilesSelection);
			}
			Parameter ReadButton_Hide {
				Range: binary;
				InitialData: 0;
			}
			Parameter RunButton_Hide {
				Range: binary;
				InitialData: 1;
			}
		}
		Procedure RetreiveExistingInputFiles {
			Body: {
				
				StatusMessage("Retreiving existing input files . . . " );
				
				!Clean the input set
				empty InputFilesSet;
				
				!Get current directory
				DirectoryGetCurrent(CurrentDirectory);
				
				!Extract the list of input data files
				DirectoryGetFiles("data\\","*.xlsx",InputScenarios);
				
				!Extract the list of input data files
				for(ifd | ifd<=card(InputScenarios) and ifd>0) do
					InputFiles(ifd) := "data\\" + InputScenarios(ifd);
					InputFilesSet += StringToElement(InputFilesSet,InputFiles(ifd),1);
				endfor;
				
				InputFilesSelection := InputFilesSet ;
				
				StatusMessage("Input files are retreived!" );
			}
			StringParameter CurrentDirectory;
			Set IntegerFolderDirectory {
				SubsetOf: Integers;
				Index: ifd;
			}
			StringParameter InputScenarios {
				IndexDomain: ifd;
			}
			StringParameter InputFiles {
				IndexDomain: ifd;
			}
		}
		Procedure RetreiveExistingInputFilesBatch {
			Body: {
				!Clean the input set
				empty InputFilesSetBatch;
				
				!Get current directory
				DirectoryGetCurrent(CurrentDirectory);
				
				!Extract the list of input data files
				DirectoryGetFiles("data_Batch\\","*.xlsx",InputScenarios);
				
				!Extract the list of input data files
				for(ifd | ifd<=card(InputScenarios) and ifd>0) do
					InputFiles(ifd) := "data_Batch\\" + InputScenarios(ifd);
					InputFilesSetBatch += StringToElement(InputFilesSetBatch,InputFiles(ifd),1);
				endfor;
				
				InputFilesSelectionBatch := InputFilesSetBatch ;
			}
			StringParameter CurrentDirectory;
			Set IntegerFolderDirectory {
				SubsetOf: Integers;
				Index: ifd;
			}
			StringParameter InputScenarios {
				IndexDomain: ifd;
			}
			StringParameter InputFiles {
				IndexDomain: ifd;
			}
		}
		Procedure RetreiveProjectName {
			Body: {
				!Clean the input set
				empty project_name;
				
				!Get current directory
				DirectoryGetCurrent(CurrentDirectory);
				
				!Extract the name of the aimms project file
				DirectoryGetFiles(CurrentDirectory,"*.aimms",project_name_temp);
				project_name := project_name_temp(1) - ".aimms";
				
				StatusMessage("Project name is upated" );
			}
			StringParameter CurrentDirectory;
			Set IntegerFolderDirectory {
				SubsetOf: Integers;
				Index: ifd;
			}
			StringParameter project_name_temp {
				IndexDomain: ifd;
			}
		}
		Procedure RetreiveExistingOutputFolders {
			Body: {
				StatusMessage("Retreiving existing output data cases . . ." );
				
				!Clean the cases set
				empty DataCasesSet;
				!Get current directory
				DirectoryGetCurrent(CurrentDirectory);
				
				!Get all the Output folders in the directory
				DirectoryGetSubdirectories(CurrentDirectory+"\\Output","",FilesInOutput);
				
				!Extract the list of output data cases files
				for(ifd | ifd<=card(FilesInOutput) and ifd>0) do
					DirectoryGetFiles("Output\\"+FilesInOutput(ifd),"*.data",DataCasesFiles);
					OutputCasesFiles(ifd) := "Output\\" + FilesInOutput(ifd) + "\\" + DataCasesFiles(1);
					DataCasesSet := DataCasesSet + StringToElement(DataCasesSet,OutputCasesFiles(ifd),1);
				endfor;
				
				StatusMessage("Ready!" );
			}
			StringParameter CurrentDirectory;
			Set IntegerFolderDirectory {
				SubsetOf: Integers;
				Index: ifd;
			}
			StringParameter FilesInOutput {
				IndexDomain: ifd;
			}
			StringParameter DataCasesFiles {
				IndexDomain: ifd;
			}
			StringParameter OutputCasesFiles {
				IndexDomain: ifd;
			}
		}
		Procedure ApplyProjectName {
			Body: {
				!File to change the project name when opening the model
				RetreiveProjectName;
				option project_title := project_name;
			}
		}
		Procedure DefaultInputLocation {
			Body: {
				DataReadingLocation := Element(InputFilesSet,1) ;
			}
		}
	}
	Section Data_Exchange {
		DeclarationSection Error_handling {
			ElementParameter err {
				Range: errh::PendingErrors;
			}
		}
		Section Data_Reading {
			Procedure DataReading {
				Arguments: (FileLocation);
				Body: {
					!block 
					
							! Open the workbook
							if axll::WorkBookIsOpen(FileLocation) then
							       axll::SelectWorkBook(FileLocation);
							else
							       axll::OpenWorkBook(FileLocation);
							endif;
					
							!Select the workbook sheet
							axll::SelectSheet("IESA-Opt database");
					
							!Read a scalar
							axll::ReadSingleValue(
								ScalarReference 	:  scenario_description,
								Cell           		:  "E21");
					
							!Select the workbook sheet
							axll::SelectSheet("Parameters");
					
					
							!Read a scalar
							axll::ReadSingleValue(
								ScalarReference 	:  XC_TransmissionLoss,
								Cell           		:  "B5");
					
							!Read a scalar
							axll::ReadSingleValue(
								ScalarReference 	:  baseload_treshold,
								Cell           		:  "B6");
					
							!Read a scalar
							axll::ReadSingleValue(
								ScalarReference 	:  shedding_inLoad,
								Cell           		:  "B7");
					
							!Read a scalar
							axll::ReadSingleValue(
								ScalarReference 	:  social_discount_rate,
								Cell           		:  "B12");
					
							!Read a scalar
							axll::ReadSingleValue(
								ScalarReference 	:  base_year,
								Cell           		:  "B13");
					
							!Select the workbook sheet
							axll::SelectSheet("Types");
							!Read the sets
							axll::ReadSet(
								SetReference    			:  dispatch_type,
								SetRange        			:  FormatString("A4:A%i",axll::LastUsedRowNumber),
								ExtendSuperSets 			:  1,
								MergeWithExistingElements		:  0,
								SkipEmptyCells				:  1);
					
							axll::ReadSet(
								SetReference    			:  activity_type,
								SetRange        			:  FormatString("B4:B%i",axll::LastUsedRowNumber), !revised by Kira to include material conversion
								ExtendSuperSets 			:  1,
								MergeWithExistingElements		:  0,
								SkipEmptyCells				:  1);
					
							axll::ReadSet(
								SetReference    			:  process_type,
								SetRange        			:  FormatString("C4:C%i",axll::LastUsedRowNumber),
								ExtendSuperSets 			:  1,
								MergeWithExistingElements		:  0,
								SkipEmptyCells				:  1);
					
							axll::ReadSet(
								SetReference    			:  flexibility_type,
								SetRange        			:  FormatString("D4:D%i",axll::LastUsedRowNumber),
								ExtendSuperSets 			:  1,
								MergeWithExistingElements		:  0,
								SkipEmptyCells				:  1);
					
							axll::ReadSet(
								SetReference    			:  range_type,
								SetRange        			:  FormatString("E4:E%i",axll::LastUsedRowNumber),
								ExtendSuperSets 			:  1,
								MergeWithExistingElements		:  0,
								SkipEmptyCells				:  1);
					
							axll::ReadSet(
								SetReference    			:  sectors,
								SetRange        			:  FormatString("F4:F%i",axll::LastUsedRowNumber),
								ExtendSuperSets 			:  1,
								MergeWithExistingElements		:  0,
								SkipEmptyCells				:  1);
					
							axll::ReadSet(
								SetReference    			:  nodes,
								SetRange        			:  FormatString("H4:H%i",axll::LastUsedRowNumber),
								ExtendSuperSets 			:  1,
								MergeWithExistingElements		:  0,
								SkipEmptyCells				:  1);
					
							axll::ReadSet(
								SetReference    			:  node_names,
								SetRange        			:  FormatString("I4:I%i",axll::LastUsedRowNumber),
								ExtendSuperSets 			:  1,
								MergeWithExistingElements		:  0,
								SkipEmptyCells				:  1);
					
							axll::ReadSet(
								SetReference    			:  energy_labels,
								SetRange        			:  FormatString("K4:K%i",axll::LastUsedRowNumber),
								ExtendSuperSets 			:  1,
								MergeWithExistingElements		:  0,
								SkipEmptyCells				:  1);
					
							axll::ReadSet(
								SetReference    			:  sectors_kev,
								SetRange        			:  FormatString("N4:N%i",axll::LastUsedRowNumber),
								ExtendSuperSets 			:  1,
								MergeWithExistingElements		:  0,
								SkipEmptyCells				:  1);
					
							!Read the data
							axll::ReadList(
							       IdentifierReference 		:  IEM_sector,
							       RowHeaderRange      		:  FormatString("F4:F%i",axll::LastUsedRowNumber),
							       DataRange        		:  FormatString("G4:G%i",axll::LastUsedRowNumber),
							       MergeWithExistingData		:  0);
					
							axll::ReadList(
							       IdentifierReference 		:  namePer_node,
							       RowHeaderRange      		:  FormatString("H4:H%i",axll::LastUsedRowNumber),
							       DataRange        		:  FormatString("I4:I%i",axll::LastUsedRowNumber),
							       MergeWithExistingData		:  0);
					
							axll::ReadList(
							       IdentifierReference 		:  IEM_node,
							       RowHeaderRange      		:  FormatString("H4:H%i",axll::LastUsedRowNumber),
							       DataRange        		:  FormatString("J4:J%i",axll::LastUsedRowNumber),
							       MergeWithExistingData		:  0);
					
							axll::ReadList(
							       IdentifierReference 		:  is_renewable,
							       RowHeaderRange      		:  FormatString("K4:K%i",axll::LastUsedRowNumber),
							       DataRange        		:  FormatString("L4:L%i",axll::LastUsedRowNumber),
							       MergeWithExistingData		:  0);
					
							!Select the workbook sheet
							axll::SelectSheet("NodeParameters");
					
							!Read the data
							axll::ReadTable(
							       IdentifierReference 		:  emissionTarget,
							       RowHeaderRange      		:  FormatString("A5:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange		:  "B3:H3",
							       DataRange        		:  FormatString("B5:H%i",axll::LastUsedRowNumber),
							       MergeWithExistingData		:  0);
					
							axll::ReadList(
							       IdentifierReference 		:  emissionTarget_cum,
							       RowHeaderRange      		:  FormatString("A5:A%i",axll::LastUsedRowNumber),
							       DataRange        		:  FormatString("I5:I%i",axll::LastUsedRowNumber),
							       MergeWithExistingData		:  0);
					
							axll::ReadList(
							       IdentifierReference 		:  cumulative_CO2storage,
							       RowHeaderRange      		:  FormatString("A5:A%i",axll::LastUsedRowNumber),
							       DataRange        		:  FormatString("J5:J%i",axll::LastUsedRowNumber),
							       MergeWithExistingData		:  0);
					
							axll::ReadTable(
							       IdentifierReference 		:  emissionTarget_inclScope3,
							       RowHeaderRange      		:  FormatString("A5:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange		:  "R3:X3",
							       DataRange        		:  FormatString("R5:X%i",axll::LastUsedRowNumber),
							       MergeWithExistingData		:  0);
					
							!Select the workbook sheet
							axll::SelectSheet("Activities");
					
					!		Read the sets
					!		axll::ReadSet(
					!			SetReference    			:  periods,
					!			SetRange        			:  "C3:I3",
					!			ExtendSuperSets 			:  1,
					!			MergeWithExistingElements		:  0,
					!			SkipEmptyCells				:  1);
					
							axll::ReadSet(
								SetReference    			:  activities_original,
								SetRange        			:  FormatString("A9:A%i",axll::LastUsedRowNumber),
								ExtendSuperSets 			:  1,
								MergeWithExistingElements		:  0,
								SkipEmptyCells				:  1);
					
							axll::ReadList(
							       IdentifierReference 	:   act_units,
							       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("B9:B%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:   actChange_maxOrig,
							       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("J9:J%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:   dispatchType_act,
							       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("K9:K%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:   activityType_act,
							       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("L9:L%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  nodePer_act,
							       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("M9:M%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  emissionTarget_bin,
							       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("N9:N%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  labelPer_act,
							       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("O9:O%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadTable(
							       IdentifierReference 	:  activities_netVolumesOrig,
							       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "C8:I8",
							       DataRange           	:  FormatString("C9:I%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							!Select the workbook sheet
							axll::SelectSheet("HourlyProfiles");
					
							axll::ColumnName(axll::LastUsedColumnNumber,ColName);
					
							!Read the sets
							axll::ReadSet(
								SetReference    			:  hours_orig,
								SetRange        			:  FormatString("A5:A%i",axll::LastUsedRowNumber),
								ExtendSuperSets 			:  1,
								MergeWithExistingElements		:  0,
								SkipEmptyCells				:  1);
					
							axll::ReadSet(
							       SetReference    			:  profile_typeRead,
							       SetRange        			:  "D3:"+ColName+"3",
							       ExtendSuperSets 			:  1,
							       MergeWithExistingElements	:  0,
							       SkipEmptyCells			:  1);
					
							axll::ReadList(
							       IdentifierReference 	:  monthPer_hourOrig,
							       RowHeaderRange      	:  FormatString("A5:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("C5:C%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadTable(
							       IdentifierReference 	:  hourly_profilesReadOrig,
							       RowHeaderRange      	:  FormatString("A5:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "D3:"+ColName+"3",
							       DataRange           	:  "D5:"+ColName+FormatString("%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);       
					
							!Select the workbook sheet
							axll::SelectSheet("Technologies");
					
							!Read the sets
							axll::ReadSet(
								SetReference    			:  tech_balancers,
								SetRange        			:  FormatString("A7:A%i",axll::LastUsedRowNumber),
								ExtendSuperSets 			:  1,
								MergeWithExistingElements		:  0,
								SkipEmptyCells				:  1);
					
							!Read tech info
					
					
							axll::ReadList(
							       IdentifierReference 	:  tech_sector_kev,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("B7:B%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  tech_category,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("C7:C%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  tech_sector,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("D7:D%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  tech_subsector,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("E7:E%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  activityPer_techOrig,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("F7:F%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  tech_name,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("G7:G%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  tech_units,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("H7:H%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							!Read the data
							axll::ReadTable(
							       IdentifierReference 	:  inv_cost,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "I4:O4",
							       DataRange           	:  FormatString("I7:O%i",axll::LastUsedRowNumber),,
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  Salvage_value,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("P7:P%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadTable(
							       IdentifierReference 	:  fom_cost,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "Q4:W4",
							       DataRange           	:  FormatString("Q7:W%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadTable(
							       IdentifierReference 	:  vom_cost,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "X4:AD4",
							       DataRange           	:  FormatString("X7:AD%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  WACC,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("AE7:AE%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  construction_time,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("AF7:AF%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  ec_lifetime,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("AG7:AG%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  tec_lifetime,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("AH7:AH%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  cap2act,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("AI7:AI%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  processType_tech,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("AJ7:AJ%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  profileType_techRead,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("AK7:AK%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  ramping,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("AL7:AL%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  CHP_prodOrig,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("AM7:AM%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  CHP_fuelOrig,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("AN7:AN%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  CHP_eta,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("AO7:AO%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  CHP_range,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("AP7:AP%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  CHPdev_use,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("AQ7:AQ%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  CHPdev_PtoH,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("AR7:AR%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  shed_capacity_percentage,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("AS7:AS%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  shed_volume,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("AT7:AT%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  shed_range,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("AU7:AU%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  phs_capacity,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("AV7:AV%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  phs_storage,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("AW7:AW%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  phs_losses,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("AX7:AX%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  flexibilityType_tech,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("AY7:AY%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  flex_activityOrig,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("AZ7:AZ%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  flex_capacity_percentage,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("BA7:BA%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  flex_storage,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("BB7:BB%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  flex_range,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("BC7:BC%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  flex_losses,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("BD7:BD%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  flex_nnLoad,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("BE7:BE%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  avg_journey,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("BF7:BF%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  avg_speed,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("BG7:BG%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);       
					
							axll::ReadList(
							       IdentifierReference 	:  buffer_activityOrig,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("BH7:BH%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  bufferUP_capacity,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("BI7:BI%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  bufferDW_capacity,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("BJ7:BJ%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  buffer_storage,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange        	:  FormatString("BL7:BL%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  techChange_max,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("BM7:BM%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  techStock_exist,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("BN7:BN%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadTable(
							       IdentifierReference 	:  decom_planned,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "BO5:BT5",
							       DataRange           	:  FormatString("BO7:BT%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadTable(
							       IdentifierReference 	:  techStock_min,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "BU5:CA5",
							       DataRange           	:  FormatString("BU7:CA%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadTable(
							       IdentifierReference 	:  techStock_max,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "CB5:CH5",
							       DataRange           	:  FormatString("CB7:CH%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
							axll::ReadTable(
							       IdentifierReference 	:  techUse_min,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "CI5:CO5",
							       DataRange           	:  FormatString("CI7:CO%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadTable(
							       IdentifierReference 	:  techUse_max,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "CP5:CV5",
							       DataRange           	:  FormatString("CP7:CV%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadTable(
							       IdentifierReference 	:  no_new_invest,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "CW5:DC5",
							       DataRange           	:  FormatString("CW7:DC%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadTable(
							       IdentifierReference 	:  no_eco_decom,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "DD5:DJ5",
							       DataRange           	:  FormatString("DD7:DJ%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
					
					
							!Select the workbook sheet
							axll::SelectSheet("EnergyBalance");
					
							axll::ColumnName(axll::LastUsedColumnNumber,ColName);
					
							axll::ReadTable(
							       IdentifierReference 	:  activity_balancesRef,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),                                           
							       ColumnHeaderRange      	:  "Q3:"+ColName+"3", 						 !!!!
							       DataRange           	:  "Q7:"+ColName+FormatString("%i",axll::LastUsedRowNumber), 
							       MergeWithExistingData	:  0);
					
							!Select the workbook sheet
							axll::SelectSheet("Infrastructure");
					
							axll::ColumnName(axll::LastUsedColumnNumber,ColName);
					
							!Read the sets
							axll::ReadSet(
								SetReference    			:  tech_infra,
								SetRange        			:  "A6:A100",
								ExtendSuperSets 			:  1,
								MergeWithExistingElements		:  0,
								SkipEmptyCells				:  1);
					
							!Include infra technologies into th set of technologies
							technologies := tech_balancers + tech_infra;
					
							axll::ReadList(
							       IdentifierReference 	:  tech_sector_kev,
							       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("B6:B%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  1);
					
							axll::ReadList(
							       IdentifierReference 	:  tech_category,
							       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("C6:C%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  1);
					
							axll::ReadList(
							       IdentifierReference 	:  tech_sector,
							       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("D6:D%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  1);
					
							axll::ReadList(
							       IdentifierReference 	:  tech_subsector,
							       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("E6:E%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  1);
					
							axll::ReadList(
							       IdentifierReference 	:  tech_name,
							       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("F6:F%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  1);
					
							axll::ReadList(
							       IdentifierReference 	:  tech_units,
							       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("G6:G%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  1);
					
							axll::ReadTable(
							       IdentifierReference 	:  inv_cost,
							       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "H4:N4",
							       DataRange           	:  FormatString("H6:N%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  1);
					
							axll::ReadList(
							       IdentifierReference 	:  Salvage_value,
							       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("O6:O%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  1);
					
							axll::ReadTable(
							       IdentifierReference 	:  fom_cost,
							       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "P4:V4",
							       DataRange           	:  FormatString("P6:V%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  1);
					
							axll::ReadList(
							       IdentifierReference 	:  WACC,
							       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("W6:W%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  1);
					
							axll::ReadList(
							       IdentifierReference 	:  ec_lifetime,
							       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("X6:X%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  1);
					
							axll::ReadList(
							       IdentifierReference 	:  tec_lifetime,
							       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("Y6:Y%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  1);
					
							axll::ReadList(
							       IdentifierReference 	:  cap2act,
							       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("Z6:Z%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  1);
					
							axll::ReadList(
							       IdentifierReference 	:  infra_range,
							       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("AA6:AA%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);       
					
							axll::ReadList(
							       IdentifierReference 	:  infra_activityOrig,
							       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("AB6:AB%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  techChange_max,
							       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("AD6:AD%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  1);
					
							axll::ReadList(
							       IdentifierReference 	:  techStock_exist,
							       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("AE6:AE%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  1);
					
							axll::ReadTable(
							       IdentifierReference 	:  decom_planned,
							       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "AF3:AK3",
							       DataRange           	:  FormatString("AF6:AK%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  1);
					
							axll::ReadTable(
							       IdentifierReference 	:  techStock_min,
							       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "AL3:AR3",
							       DataRange           	:  FormatString("AL6:AR%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  1);
					
							axll::ReadTable(
							       IdentifierReference 	:  techStock_max,
							       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "AS3:AY3",
							       DataRange           	:  FormatString("AS6:AY%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  1);
					
							!Select the workbook sheet
							axll::SelectSheet("PriceProfiles");
					
							axll::ColumnName(axll::LastUsedColumnNumber,ColName);
					
							axll::ReadTable(
							       IdentifierReference 	:  interconnectedHourly_pricesOrig,
							       RowHeaderRange      	:  FormatString("A5:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "D2:"+ColName+"3",
							       DataRange           	:  "D5:"+ColName+FormatString("%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);  
					
							!Select the workbook sheet
							axll::SelectSheet("ActGrouping");
					
							!Read the sets
							axll::ReadSet(
							       SetReference    			:  activities_group,
							       SetRange        			:  FormatString("A4:A%i",axll::LastUsedRowNumber),
							       ExtendSuperSets 			:  1,
							       MergeWithExistingElements	:  0,
							       SkipEmptyCells			:  1);
					
							axll::ReadList(
							       IdentifierReference 	:  dispatchType_act,
							       RowHeaderRange      	:  FormatString("A4:A%i",Max(axll::LastUsedRowNumber,4)),
							       DataRange           	:  FormatString("B4:B%i",Max(axll::LastUsedRowNumber,4)),
							       MergeWithExistingData	:  1);
					
							axll::ReadList(
							       IdentifierReference 	:  activityType_act,
							       RowHeaderRange      	:  FormatString("A4:A%i",Max(axll::LastUsedRowNumber,4)),
							       DataRange           	:  FormatString("C4:C%i",Max(axll::LastUsedRowNumber,4)),
							       MergeWithExistingData	:  1);
					
							axll::ReadList(
							       IdentifierReference 	:  nodePer_act,
							       RowHeaderRange      	:  FormatString("A4:A%i",Max(axll::LastUsedRowNumber,4)),
							       DataRange           	:  FormatString("D4:D%i",Max(axll::LastUsedRowNumber,4)),
							       MergeWithExistingData	:  1);
					
							axll::ReadList(
							       IdentifierReference 	:  emissionTarget_bin,
							       RowHeaderRange      	:  FormatString("A4:A%i",Max(axll::LastUsedRowNumber,4)),
							       DataRange           	:  FormatString("E4:E%i",Max(axll::LastUsedRowNumber,4)),
							       MergeWithExistingData	:  1);
					
							axll::ReadList(
							       IdentifierReference 	:  labelPer_act,
							       RowHeaderRange      	:  FormatString("A4:A%i",Max(axll::LastUsedRowNumber,4)),
							       DataRange           	:  FormatString("F4:F%i",Max(axll::LastUsedRowNumber,4)),
							       MergeWithExistingData	:  1);
					
							!Read the data
							axll::ReadTable(
							       IdentifierReference 	:  groupOf_activities,
							       RowHeaderRange      	:  FormatString("H4:I%i",Max(axll::LastUsedRowNumber,4)),
							       ColumnHeaderRange      	:  "",
							       DataRange           	:  FormatString("J4:J%i",Max(axll::LastUsedRowNumber,4)),
							       MergeWithExistingData	:  0);
					
							!Select the workbook sheet
							axll::SelectSheet("EffLearning");
					
							axll::ReadTable(
							       IdentifierReference 	:  activity_EffImprov,
							       RowHeaderRange      	:  FormatString("C4:D%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "E3:K3",
							       DataRange           	:  FormatString("E4:K%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							!Select the workbook sheet
							axll::SelectSheet("Feedstocks");
					
							axll::ReadList(
							       IdentifierReference 	:  feedstockUse_techOrig,
							       RowHeaderRange      	:  FormatString("C4:D%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("H4:H%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							!Select the workbook sheet
							axll::SelectSheet("Retrofitting");
					
							axll::ReadList(
							       IdentifierReference 	:  retrofit_relations,
							       RowHeaderRange      	:  FormatString("A4:B%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("F4:F%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::ReadList(
							       IdentifierReference 	:  retro_cost,
							       RowHeaderRange      	:  FormatString("A4:B%i",axll::LastUsedRowNumber),
							       DataRange           	:  FormatString("G4:G%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  0);
					
							axll::CloseWorkBook(FileLocation);
					
					!	onerror err do
					!
					!	errh::MarkAsHandled(err , 1) ;
					!
					!endblock;
					!
				}
				StringParameter ColName;
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure DataReadingBatch {
				Arguments: (FileLocation);
				Body: {
					block 
					
							! Open the workbook
							if axll::WorkBookIsOpen(FileLocation) then
							       axll::SelectWorkBook(FileLocation);
							else
							       axll::OpenWorkBook(FileLocation);
							endif;
					
					!		!Select the workbook sheet
					!		axll::SelectSheet("IESA-Opt database");
					!
					!		!Read a scalar
					!		axll::ReadSingleValue(
					!			ScalarReference 	:  scenario_description,
					!			Cell           		:  "E21");
					!
					!		!Select the workbook sheet
					!		axll::SelectSheet("Parameters");
					!
					!
					!		!Read a scalar
					!		axll::ReadSingleValue(
					!			ScalarReference 	:  XC_TransmissionLoss,
					!			Cell           		:  "B5");
					!
					!		!Read a scalar
					!		axll::ReadSingleValue(
					!			ScalarReference 	:  baseload_treshold,
					!			Cell           		:  "B6");
					!
					!		!Read a scalar
					!		axll::ReadSingleValue(
					!			ScalarReference 	:  shedding_inLoad,
					!			Cell           		:  "B7");
					!
					!		!Read a scalar
					!		axll::ReadSingleValue(
					!			ScalarReference 	:  social_discount_rate,
					!			Cell           		:  "B12");
					!
					!		!Read a scalar
					!		axll::ReadSingleValue(
					!			ScalarReference 	:  base_year,
					!			Cell           		:  "B13");
					!
					!		!Select the workbook sheet
					!		axll::SelectSheet("Types");
					!		if (REF2020Value='no') then
					!			!Read the sets
					!			axll::ReadSet(
					!				SetReference    			:  dispatch_type,
					!				SetRange        			:  FormatString("A4:A%i",axll::LastUsedRowNumber),
					!				ExtendSuperSets 			:  1,
					!				MergeWithExistingElements		:  1,
					!				SkipEmptyCells				:  1);
					!
					!			axll::ReadSet(
					!				SetReference    			:  activity_type,
					!				SetRange        			:  FormatString("B4:B%i",axll::LastUsedRowNumber), !revised by Kira to include material conversion
					!				ExtendSuperSets 			:  1,
					!				MergeWithExistingElements		:  1,
					!				SkipEmptyCells				:  1);
					!
					!			axll::ReadSet(
					!				SetReference    			:  process_type,
					!				SetRange        			:  FormatString("C4:C%i",axll::LastUsedRowNumber),
					!				ExtendSuperSets 			:  1,
					!				MergeWithExistingElements		:  1,
					!				SkipEmptyCells				:  1);
					!
					!			axll::ReadSet(
					!				SetReference    			:  flexibility_type,
					!				SetRange        			:  FormatString("D4:D%i",axll::LastUsedRowNumber),
					!				ExtendSuperSets 			:  1,
					!				MergeWithExistingElements		:  1,
					!				SkipEmptyCells				:  1);
					!
					!			axll::ReadSet(
					!				SetReference    			:  range_type,
					!				SetRange        			:  FormatString("E4:E%i",axll::LastUsedRowNumber),
					!				ExtendSuperSets 			:  1,
					!				MergeWithExistingElements		:  1,
					!				SkipEmptyCells				:  1);
					!
					!			axll::ReadSet(
					!				SetReference    			:  sectors,
					!				SetRange        			:  FormatString("F4:F%i",axll::LastUsedRowNumber),
					!				ExtendSuperSets 			:  1,
					!				MergeWithExistingElements		:  1,
					!				SkipEmptyCells				:  1);
					!
					!			axll::ReadSet(
					!				SetReference    			:  nodes,
					!				SetRange        			:  FormatString("H4:H%i",axll::LastUsedRowNumber),
					!				ExtendSuperSets 			:  1,
					!				MergeWithExistingElements		:  1,
					!				SkipEmptyCells				:  1);
					!
					!			axll::ReadSet(
					!				SetReference    			:  node_names,
					!				SetRange        			:  FormatString("I4:I%i",axll::LastUsedRowNumber),
					!				ExtendSuperSets 			:  1,
					!				MergeWithExistingElements		:  1,
					!				SkipEmptyCells				:  1);
					!
					!			axll::ReadSet(
					!				SetReference    			:  energy_labels,
					!				SetRange        			:  FormatString("K4:K%i",axll::LastUsedRowNumber),
					!				ExtendSuperSets 			:  1,
					!				MergeWithExistingElements		:  1,
					!				SkipEmptyCells				:  1);
					!
					!			axll::ReadSet(
					!				SetReference    			:  sectors_kev,
					!				SetRange        			:  FormatString("N4:N%i",axll::LastUsedRowNumber),
					!				ExtendSuperSets 			:  1,
					!				MergeWithExistingElements		:  1,
					!				SkipEmptyCells				:  1);
					!		endif;
					!
					!		!Read the data
					!		axll::ReadList(
					!		       IdentifierReference 		:  IEM_sector,
					!		       RowHeaderRange      		:  FormatString("F4:F%i",axll::LastUsedRowNumber),
					!		       DataRange        		:  FormatString("G4:G%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData		:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 		:  namePer_node,
					!		       RowHeaderRange      		:  FormatString("H4:H%i",axll::LastUsedRowNumber),
					!		       DataRange        		:  FormatString("I4:I%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData		:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 		:  IEM_node,
					!		       RowHeaderRange      		:  FormatString("H4:H%i",axll::LastUsedRowNumber),
					!		       DataRange        		:  FormatString("J4:J%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData		:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 		:  is_renewable,
					!		       RowHeaderRange      		:  FormatString("K4:K%i",axll::LastUsedRowNumber),
					!		       DataRange        		:  FormatString("L4:L%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData		:  1);
					
							!Select the workbook sheet
							axll::SelectSheet("NodeParameters");
					
							!Read the data
							axll::ReadTable(
							       IdentifierReference 		:  emissionTarget,
							       RowHeaderRange      		:  FormatString("A5:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange		:  "B3:H3",
							       DataRange        		:  FormatString("B5:H%i",axll::LastUsedRowNumber),
							       MergeWithExistingData		:  1);
					
					!		axll::ReadList(
					!		       IdentifierReference 		:  emissionTarget_cum,
					!		       RowHeaderRange      		:  FormatString("A5:A%i",axll::LastUsedRowNumber),
					!		       DataRange        		:  FormatString("I5:I%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData		:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 		:  cumulative_CO2storage,
					!		       RowHeaderRange      		:  FormatString("A5:A%i",axll::LastUsedRowNumber),
					!		       DataRange        		:  FormatString("J5:J%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData		:  1);
					!
					!		axll::ReadTable(
					!		       IdentifierReference 		:  emissionTarget_inclScope3,
					!		       RowHeaderRange      		:  FormatString("A5:A%i",axll::LastUsedRowNumber),
					!		       ColumnHeaderRange		:  "R3:X3",
					!		       DataRange        		:  FormatString("R5:X%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					
					!		!Select the workbook sheet
					!		axll::SelectSheet("Activities");
					!
					!		if (REF2020Value='no') then
					!			!Read the sets
					!		!	axll::ReadSet(
					!		!		SetReference    			:  periods,
					!		!		SetRange        			:  "C3:I3",
					!		!		ExtendSuperSets 			:  1,
					!		!		MergeWithExistingElements		:  1,
					!		!		SkipEmptyCells				:  1);
					!
					!			axll::ReadSet(
					!				SetReference    			:  activities_original,
					!				SetRange        			:  FormatString("A9:A%i",axll::LastUsedRowNumber),
					!				ExtendSuperSets 			:  1,
					!				MergeWithExistingElements		:  1,
					!				SkipEmptyCells				:  1);
					!		endif;
					!
					!		!Read the data       
					!		axll::ReadList(
					!		       IdentifierReference 	:   act_units,
					!		       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("B9:B%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:   actChange_maxOrig,
					!		       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("J9:J%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:   dispatchType_act,
					!		       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("K9:K%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:   activityType_act,
					!		       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("L9:L%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  nodePer_act,
					!		       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("M9:M%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  emissionTarget_bin,
					!		       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("N9:N%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  labelPer_act,
					!		       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("O9:O%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadTable(
					!		       IdentifierReference 	:  activities_netVolumesOrig,
					!		       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
					!		       ColumnHeaderRange      	:  "C8:I8",
					!		       DataRange           	:  FormatString("C9:I%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		!Select the workbook sheet
					!		axll::SelectSheet("HourlyProfiles");
					!
					!		axll::ColumnName(axll::LastUsedColumnNumber,ColName);
					!
					!		!Read the sets
					!		if (REF2020Value='no') then
					!			axll::ReadSet(
					!				SetReference    			:  hours_orig,
					!				SetRange        			:  FormatString("A5:A%i",axll::LastUsedRowNumber),
					!				ExtendSuperSets 			:  1,
					!				MergeWithExistingElements		:  1,
					!				SkipEmptyCells				:  1);
					!		endif;
					!
					!		axll::ReadSet(
					!		       SetReference    			:  profile_typeRead,
					!		       SetRange        			:  "D3:"+ColName+"3",
					!		       ExtendSuperSets 			:  1,
					!		       MergeWithExistingElements	:  1,
					!		       SkipEmptyCells			:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  monthPer_hourOrig,
					!		       RowHeaderRange      	:  FormatString("A5:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("C5:C%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadTable(
					!		       IdentifierReference 	:  hourly_profilesReadOrig,
					!		       RowHeaderRange      	:  FormatString("A5:A%i",axll::LastUsedRowNumber),
					!		       ColumnHeaderRange      	:  "D3:"+ColName+"3",
					!		       DataRange           	:  "D5:"+ColName+FormatString("%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);       
					
							!Select the workbook sheet
							axll::SelectSheet("Technologies");
					
							!Read the sets
							axll::ReadSet(
								SetReference    			:  tech_balancers,
								SetRange        			:  FormatString("A7:A%i",axll::LastUsedRowNumber),
								ExtendSuperSets 			:  1,
								MergeWithExistingElements		:  1,
								SkipEmptyCells				:  1);
					
							!Read tech info
					
					
					!		axll::ReadList(
					!		       IdentifierReference 	:  tech_sector_kev,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("B7:B%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  tech_category,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("C7:C%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  tech_sector,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("D7:D%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  tech_subsector,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("E7:E%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  activityPer_techOrig,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("F7:F%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  tech_name,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("G7:G%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  tech_units,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("H7:H%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					
							!Read the data
							axll::ReadTable(
							       IdentifierReference 	:  inv_cost,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "I4:O4",
							       DataRange           	:  FormatString("I7:O%i",axll::LastUsedRowNumber),,
							       MergeWithExistingData	:  1);
					
					!		axll::ReadList(
					!		       IdentifierReference 	:  salvage_value,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("P7:P%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadTable(
					!		       IdentifierReference 	:  fom_cost,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       ColumnHeaderRange      	:  "Q4:W4",
					!		       DataRange           	:  FormatString("Q7:W%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadTable(
					!		       IdentifierReference 	:  vom_cost,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       ColumnHeaderRange      	:  "X4:AD4",
					!		       DataRange           	:  FormatString("X7:AD%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  WACC,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("AE7:AE%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  construction_time,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("AF7:AF%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  ec_lifetime,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("AG7:AG%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  tec_lifetime,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("AH7:AH%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  cap2act,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("AI7:AI%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  processType_tech,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("AJ7:AJ%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  profileType_techRead,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("AK7:AK%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  ramping,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("AL7:AL%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  CHP_prodOrig,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("AM7:AM%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  CHP_fuelOrig,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("AN7:AN%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  CHP_eta,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("AO7:AO%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  CHP_range,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("AP7:AP%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  CHPdev_use,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("AQ7:AQ%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  CHPdev_PtoH,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("AR7:AR%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  shed_capacity_percentage,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("AS7:AS%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  shed_volume,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("AT7:AT%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  shed_range,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("AU7:AU%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  phs_capacity,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("AV7:AV%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  phs_storage,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("AW7:AW%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  phs_losses,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("AX7:AX%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  flexibilityType_tech,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("AY7:AY%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  flex_activityOrig,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("AZ7:AZ%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  flex_capacity_percentage,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("BA7:BA%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  flex_storage,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("BB7:BB%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  flex_range,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("BC7:BC%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  flex_losses,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("BD7:BD%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  flex_nnLoad,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("BE7:BE%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  avg_journey,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("BF7:BF%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  avg_speed,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("BG7:BG%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);       
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  buffer_activityOrig,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("BH7:BH%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  bufferUP_capacity,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("BI7:BI%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  bufferDW_capacity,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("BJ7:BJ%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  buffer_storage,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange        	:  FormatString("BL7:BL%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  techChange_max,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("BM7:BM%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  techStock_exist,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("BN7:BN%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadTable(
					!		       IdentifierReference 	:  decom_planned,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       ColumnHeaderRange      	:  "BO5:BT5",
					!		       DataRange           	:  FormatString("BO7:BT%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					
							axll::ReadTable(
							       IdentifierReference 	:  techStock_min,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "BU5:CA5",
							       DataRange           	:  FormatString("BU7:CA%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  1);
					
							axll::ReadTable(
							       IdentifierReference 	:  techStock_max,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "CB5:CH5",
							       DataRange           	:  FormatString("CB7:CH%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  1);
							axll::ReadTable(
							       IdentifierReference 	:  techUse_min,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "CI5:CO5",
							       DataRange           	:  FormatString("CI7:CO%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  1);
					
							axll::ReadTable(
							       IdentifierReference 	:  techUse_max,
							       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
							       ColumnHeaderRange      	:  "CP5:CV5",
							       DataRange           	:  FormatString("CP7:CV%i",axll::LastUsedRowNumber),
							       MergeWithExistingData	:  1);
					!
					!		axll::ReadTable(
					!		       IdentifierReference 	:  no_new_invest,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       ColumnHeaderRange      	:  "CW5:DC5",
					!		       DataRange           	:  FormatString("CW7:DC%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadTable(
					!		       IdentifierReference 	:  no_eco_decom,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
					!		       ColumnHeaderRange      	:  "DD5:DJ5",
					!		       DataRange           	:  FormatString("DD7:DJ%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					
					
					
					!		!Select the workbook sheet
					!		axll::SelectSheet("EnergyBalance");
					!
					!		axll::ColumnName(axll::LastUsedColumnNumber,ColName);
					!
					!		axll::ReadTable(
					!		       IdentifierReference 	:  activity_balancesRef,
					!		       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),                                           
					!		       ColumnHeaderRange      	:  "Q3:"+ColName+"3", 						 !!!!
					!		       DataRange           	:  "Q7:"+ColName+FormatString("%i",axll::LastUsedRowNumber), 
					!		       MergeWithExistingData	:  1);
					!
					!		!Select the workbook sheet
					!		axll::SelectSheet("Infrastructure");
					!
					!		axll::ColumnName(axll::LastUsedColumnNumber,ColName);
					!
					!		!Read the sets
					!		if (REF2020Value='no') then
					!			axll::ReadSet(
					!				SetReference    			:  tech_infra,
					!				SetRange        			:  "A6:A100",
					!				ExtendSuperSets 			:  1,
					!				MergeWithExistingElements		:  1,
					!				SkipEmptyCells				:  1);
					!		endif;
					!
					!		!Include infra technologies into th set of technologies
					!		technologies := tech_balancers + tech_infra;
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  tech_sector_kev,
					!		       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("B6:B%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  tech_category,
					!		       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("C6:C%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  tech_sector,
					!		       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("D6:D%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  tech_subsector,
					!		       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("E6:E%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  tech_name,
					!		       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("F6:F%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  tech_units,
					!		       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("G6:G%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadTable(
					!		       IdentifierReference 	:  inv_cost,
					!		       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
					!		       ColumnHeaderRange      	:  "H4:N4",
					!		       DataRange           	:  FormatString("H6:N%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  salvage_value,
					!		       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("O6:O%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadTable(
					!		       IdentifierReference 	:  fom_cost,
					!		       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
					!		       ColumnHeaderRange      	:  "P4:V4",
					!		       DataRange           	:  FormatString("P6:V%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  WACC,
					!		       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("W6:W%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  ec_lifetime,
					!		       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("X6:X%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  tec_lifetime,
					!		       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("Y6:Y%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  cap2act,
					!		       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("Z6:Z%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  infra_range,
					!		       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("AA6:AA%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);       
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  infra_activityOrig,
					!		       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("AB6:AB%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  techChange_max,
					!		       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("AD6:AD%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  techStock_exist,
					!		       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("AE6:AE%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadTable(
					!		       IdentifierReference 	:  decom_planned,
					!		       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
					!		       ColumnHeaderRange      	:  "AF3:AK3",
					!		       DataRange           	:  FormatString("AF6:AK%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadTable(
					!		       IdentifierReference 	:  techStock_min,
					!		       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
					!		       ColumnHeaderRange      	:  "AL3:AR3",
					!		       DataRange           	:  FormatString("AL6:AR%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadTable(
					!		       IdentifierReference 	:  techStock_max,
					!		       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
					!		       ColumnHeaderRange      	:  "AS3:AY3",
					!		       DataRange           	:  FormatString("AS6:AY%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		!Select the workbook sheet
					!		axll::SelectSheet("PriceProfiles");
					!
					!		axll::ColumnName(axll::LastUsedColumnNumber,ColName);
					!
					!		axll::ReadTable(
					!		       IdentifierReference 	:  interconnectedHourly_pricesOrig,
					!		       RowHeaderRange      	:  FormatString("A5:A%i",axll::LastUsedRowNumber),
					!		       ColumnHeaderRange      	:  "D2:"+ColName+"3",
					!		       DataRange           	:  "D5:"+ColName+FormatString("%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);  
					!
					!		!Select the workbook sheet
					!		axll::SelectSheet("ActGrouping");
					!
					!		!Read the sets
					!		axll::ReadSet(
					!		       SetReference    			:  activities_group,
					!		       SetRange        			:  FormatString("A4:A%i",axll::LastUsedRowNumber),
					!		       ExtendSuperSets 			:  1,
					!		       MergeWithExistingElements	:  1,
					!		       SkipEmptyCells			:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  dispatchType_act,
					!		       RowHeaderRange      	:  FormatString("A4:A%i",Max(axll::LastUsedRowNumber,4)),
					!		       DataRange           	:  FormatString("B4:B%i",Max(axll::LastUsedRowNumber,4)),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  activityType_act,
					!		       RowHeaderRange      	:  FormatString("A4:A%i",Max(axll::LastUsedRowNumber,4)),
					!		       DataRange           	:  FormatString("C4:C%i",Max(axll::LastUsedRowNumber,4)),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  nodePer_act,
					!		       RowHeaderRange      	:  FormatString("A4:A%i",Max(axll::LastUsedRowNumber,4)),
					!		       DataRange           	:  FormatString("D4:D%i",Max(axll::LastUsedRowNumber,4)),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  emissionTarget_bin,
					!		       RowHeaderRange      	:  FormatString("A4:A%i",Max(axll::LastUsedRowNumber,4)),
					!		       DataRange           	:  FormatString("E4:E%i",Max(axll::LastUsedRowNumber,4)),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  labelPer_act,
					!		       RowHeaderRange      	:  FormatString("A4:A%i",Max(axll::LastUsedRowNumber,4)),
					!		       DataRange           	:  FormatString("F4:F%i",Max(axll::LastUsedRowNumber,4)),
					!		       MergeWithExistingData	:  1);
					!
					!		!Read the data
					!		axll::ReadTable(
					!		       IdentifierReference 	:  groupOf_activities,
					!		       RowHeaderRange      	:  FormatString("H4:I%i",Max(axll::LastUsedRowNumber,4)),
					!		       ColumnHeaderRange      	:  "",
					!		       DataRange           	:  FormatString("J4:J%i",Max(axll::LastUsedRowNumber,4)),
					!		       MergeWithExistingData	:  1);
					!
					!		!Select the workbook sheet
					!		axll::SelectSheet("EffLearning");
					!
					!		axll::ReadTable(
					!		       IdentifierReference 	:  activity_EffImprov,
					!		       RowHeaderRange      	:  FormatString("C4:D%i",axll::LastUsedRowNumber),
					!		       ColumnHeaderRange      	:  "E3:K3",
					!		       DataRange           	:  FormatString("E4:K%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		!Select the workbook sheet
					!		axll::SelectSheet("Feedstocks");
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  feedstockUse_techOrig,
					!		       RowHeaderRange      	:  FormatString("C4:D%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("H4:H%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		!Select the workbook sheet
					!		axll::SelectSheet("Retrofitting");
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  retrofit_relations,
					!		       RowHeaderRange      	:  FormatString("A4:B%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("F4:F%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					!
					!		axll::ReadList(
					!		       IdentifierReference 	:  retro_cost,
					!		       RowHeaderRange      	:  FormatString("A4:B%i",axll::LastUsedRowNumber),
					!		       DataRange           	:  FormatString("G4:G%i",axll::LastUsedRowNumber),
					!		       MergeWithExistingData	:  1);
					
							axll::CloseWorkBook(FileLocation);
					
						onerror err do
					
						errh::MarkAsHandled(err , 1) ;
					
					endblock;
					!
				}
				StringParameter ColName;
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure runDataReading {
				Body: {
					!!Assign an input file manually if the UI is not used
					!DataReadingLocation := 'data\IntegratedEnergySystem_v36full'
					
					!StatusMessage("Reading data file: " + DataReadingLocation);
					Empty_parameters;
					DataReading(DataReadingLocation);
					
					!Build the tech names set
					BuildTechNominals;
					
					!Expand set of everything
					set_of_everything := set_of_everything + {'Exports','Losses','Primary'};
					typesOf_sankeyElements := energy_labels - 'NA' + sectors + {'Exports','Losses','Primary'};
					
					!!!Define sets from reading of element parameters  $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
					!Set of activities that are hourly constrained by infrastructure
					for (iti_h in tech_infraH) do
						act_infraH:=act_infraH+infra_activity(iti_h);
					endfor;
					!Set of activities that are daily constrained by infrastructure
					for (iti_d in tech_infraD) do
						act_infraD:=act_infraD+infra_activity(iti_d);
					endfor;
					
					
					!StatusMessage("Finished reading the input data. The model is ready to run.");
					!
				}
			}
			Procedure runDataReadingBatch {
				Body: {
					!Build the tech names set
					BuildTechNominals;
					
					!Expand set of everything
					set_of_everything := set_of_everything + {'Exports','Losses','Primary'};
					typesOf_sankeyElements := energy_labels - 'NA' + sectors + {'Exports','Losses','Primary'};
					
					!!!Define sets from reading of element parameters  $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
					!Set of activities that are hourly constrained by infrastructure
					for (iti_h in tech_infraH) do
						act_infraH:=act_infraH+infra_activity(iti_h);
					endfor;
					!Set of activities that are daily constrained by infrastructure
					for (iti_d in tech_infraD) do
						act_infraD:=act_infraD+infra_activity(iti_d);
					endfor;
				}
			}
			Procedure Empty_parameters {
				Body: {
					! Clear the parameters
					empty hours_orig, activities_original, tech_balancers, tech_infra, dispatch_type, activity_type;
					empty  process_type, profile_typeRead, flexibility_type, range_type, energy_labels, sectors, nodes, node_names;
					
					empty activities_original, dispatchType_act, activityType_act, activityPer_techOrig, processType_tech, profileType_techRead, flexibilityType_tech, interconnectedHourly_pricesOrig; 
					empty act_units, tech_name, tech_category, tech_sector, tech_subsector, tech_units, scenario_description, feedstockUse_techOrig;
					empty activities_netVolumesOrig, activity_balancesRef, activity_EffImprov, hourly_profilesReadOrig, monthPer_hourOrig, XC_TransmissionLoss, emissionTarget;
					empty emissionTarget_bin, inv_cost, Salvage_value, fom_cost, vom_cost, WACC, construction_time, ec_lifetime, tec_lifetime;
					empty cap2act, ramping, HVtoMV_TransformerLoss, MVtoLV_TransformerLoss, HVtoLV_TransformerLoss, infra_range, infra_activityOrig;
					empty techStock_exist, decom_planned, techStock_min, techStock_max, flex_capacity_percentage, flex_losses, flex_storage, flex_range, flex_activityOrig, retro_cost;
					empty flex_nnLoad, avg_journey, avg_speed, buffer_activityOrig, bufferUP_capacity, bufferDW_capacity, buffer_storage, baseload_treshold, shedding_inLoad;
					empty namePer_node, IEM_node, IEM_sector, is_renewable, labelPer_act, actChange_maxOrig, techChange_max, phs_capacity, phs_storage ,phs_losses;
					empty CHP_prodOrig, CHP_fuelOrig, CHP_eta, CHP_range, CHPdev_use, CHPdev_PtoH, shed_capacity_percentage, shed_volume, shed_range, hybrid_substitute, hybrid_ratio;
					empty cumulative_CO2storage;
					
					AllViolations := {} ;
				}
			}
			Procedure BuildTechNominals {
				Body: {
					! File to build the tech nominals set
					for(t in technologies) do
						tech_nominals := tech_nominals + StringToElement(tech_nominals,tech_name(t),1);
					endfor;
					!StatusMessage("Tech nominals set built." );
				}
			}
		}
		Section Data_Writing {
			Procedure DataWriting_General {
				Arguments: (FileLocation);
				Body: {
					!Open the workbook
					if axll::WorkBookIsOpen(FileLocation) then
					       axll::SelectWorkBook(FileLocation);
					else
					       !Create a new workbook
						axll::CreateNewWorkBook(
						WorkbookFilename:FileLocation,
						FirstSheetName: "Key_Indicators"
						);
						!Creating sheets
						axll::CreateSheet(SheetName:"System_Costs");
						axll::CreateSheet(SheetName:"FinalSector_Costs");
						axll::CreateSheet(SheetName:"Sectoral_Costs");
						axll::CreateSheet(SheetName:"Activity_Costs");
						axll::CreateSheet(SheetName:"Sectoral_Cascade");
						axll::CreateSheet(SheetName:"Configuration_Stock");
						axll::CreateSheet(SheetName:"Configuration_Use");
						axll::CreateSheet(SheetName:"Planning_Decissions");
						axll::CreateSheet(SheetName:"FinalEnergy_Use");
						axll::CreateSheet(SheetName:"FinalEnergy_Activities");
						axll::CreateSheet(SheetName:"FinalEnergy_Matrix");
						axll::CreateSheet(SheetName:"EnergyUse_Activities");
						axll::CreateSheet(SheetName:"EnergyCosts");
						axll::CreateSheet(SheetName:"EnergyCosts_secondary");
						axll::CreateSheet(SheetName:"ShadowEnergyPrices");	
						axll::CreateSheet(SheetName:"ShadowGHGPrices");
						axll::CreateSheet(SheetName:"ShadowCO2Prices");
						axll::CreateSheet(SheetName:"Primary_Balance");
						axll::CreateSheet(SheetName:"Primary_Renewable");
						axll::CreateSheet(SheetName:"Final_Decomposition");
						axll::CreateSheet(SheetName:"Sankey");
						axll::CreateSheet(SheetName:"SupplyDemand");
						axll::CreateSheet(SheetName:"CO2_Emissions");
						axll::CreateSheet(SheetName:"Sectoral_Emissions");
						axll::CreateSheet(SheetName:"Activity_Emissions");
						axll::CreateSheet(SheetName:"Technology_Emissions");
						axll::CreateSheet(SheetName:"Power_Stock");
						axll::CreateSheet(SheetName:"Power_Gen");
						axll::CreateSheet(SheetName:"XC_Stock");
						axll::CreateSheet(SheetName:"XC_Use");
						axll::CreateSheet(SheetName:"Power_EU");
						axll::CreateSheet(SheetName:"XC_EU");
						axll::CreateSheet(SheetName:"RES_Curtailment");
						axll::CreateSheet(SheetName:"Electricity_Parameters");
						axll::CreateSheet(SheetName:"Flexibility_Volumes");
						axll::CreateSheet(SheetName:"Flexibility_Activities");
						axll::CreateSheet(SheetName:"Flexibility_Technologies");
						axll::CreateSheet(SheetName:"ResLoad_Decomposition");
						axll::CreateSheet(SheetName:"LCOPs_Conversion");
						axll::CreateSheet(SheetName:"LCOPs_Activities");
						axll::CreateSheet(SheetName:"LCOEs");
						axll::CreateSheet(SheetName:"International_Transport");
						axll::CreateSheet(SheetName:"TechInfo");
						axll::CreateSheet(SheetName:"FlexInfo");
						!axll::CreateSheet(SheetName:"ActInfo");
						axll::CreateSheet(SheetName:"Capacity_constraints");
						axll::CreateSheet(SheetName:"Emission_constraints");	
						axll::CreateSheet(SheetName:"Scenario");
						axll::CreateSheet(SheetName:"MathProgram");
					
					endif;
					
					!-----------------------------------------------------------------------------------
					
					!Write the table: Key Indicators (node name, type of indicator, period)=================================================================================
					axll::SelectSheet("Key_Indicators");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Rkey_indicators(nn,tok,pnz),
					  RowHeaderRange : "A2:B100",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ100",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "B1"
					);
					
					!Write the table: System Cost (node name, type of cost, period)=================================================================================
					axll::SelectSheet("System_Costs");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RSystemCosts_n(nn,toc,pnz),
					  RowHeaderRange : "A2:B100",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ100",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "B1"
					);
					
					!Write the table:  SystemCosts_sec_tot(node name, sector, period)=================================================================================
					axll::SelectSheet("FinalSector_Costs");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RSystemCosts_sec_tot(nn,z,pnz),
					  RowHeaderRange : "A2:B100",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ100",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					
					!Write the table: Sectoral Cost (node name, sector, type of tech source, type of cost, period)==================================================
					axll::SelectSheet("Sectoral_Costs");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RSystemCosts_sec_n(nn,z,tots,toc,pnz),
					  RowHeaderRange : "A2:D100",
					  ColumnHeaderRange : "E1:ZZ1",
					  DataRange : "E2:ZZ100",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type1_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type2_string,
						Cell           		:  "D1"
					);
					
					!Write the table: Activity Cost (node name, sector, activity, type of tech source, type of cost, period)==================================================
					axll::SelectSheet("Activity_Costs");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RSystemCosts_act_n(nn,z,a,tots,toc,pnz),
					  RowHeaderRange : "A2:E100",
					  ColumnHeaderRange : "F1:ZZ1",
					  DataRange : "F2:ZZ100",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Activity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type1_string,
						Cell           		:  "D1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type2_string,
						Cell           		:  "E1"
					);
					
					!Write the table: Sectoral Cost Cascade (node name, sector, type of cost, period)===============================================================
					axll::SelectSheet("Sectoral_Cascade");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RSectoralCosts_cascade(nn,z,toc,pnz),
					  RowHeaderRange : "A2:C100",
					  ColumnHeaderRange : "D1:ZZ1",
					  DataRange : "D2:ZZ100",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "C1"
					);
					
					!Write the table: Configuration Stock (node name, sector, activity, type of source, technology, period)=========================================
					axll::SelectSheet("Configuration_Stock");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RSectoralConfiguration_stock(nn,z,as,tots,t,pnz),
					  RowHeaderRange : "A2:E5000",
					  ColumnHeaderRange : "F1:ZZ1",
					  DataRange : "F2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Activity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	: type_string,
						Cell           		:  "D1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	: techID_string,
						Cell           		:  "E1"
					);
					
					!Write the table: Configuration Use (node name, sector, activity, type of source, technology, period)===========================================
					axll::SelectSheet("Configuration_Use");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RSectoralConfiguration_use(nn,z,as,tots,t,pnz),
					  RowHeaderRange : "A2:E5000",
					  ColumnHeaderRange : "F1:ZZ1",
					  DataRange : "F2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Activity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	: type_string,
						Cell           		:  "D1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	: techID_string,
						Cell           		:  "E1"
					);
					
					!Write the table: Planning Decissions (node name, technology, type of decission, period)===========================================
					axll::SelectSheet("Planning_Decissions");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RPlanningDecissions_tech(nn,t,topd,pnz),
					  RowHeaderRange : "A2:C5000",
					  ColumnHeaderRange : "D1:ZZ1",
					  DataRange : "D2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					axll:: WriteSingleValue(
						ScalarReference 	: techID_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	: type_string,
						Cell           		:  "C1"
					);
					
					!Write the table: Final Energy Use (node name, sector, type of final, energy label, period)=====================================================
					axll::SelectSheet("FinalEnergy_Use");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RfinalEnergy_matrix(nn,z,tof,el,pnz),
					  RowHeaderRange : "A2:D5000",
					  ColumnHeaderRange : "E1:ZZ1",
					  DataRange : "E2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Energy
					axll:: WriteSingleValue(
						ScalarReference 	: energy_string,
						Cell           		:  "D1"
					);
					
					!Write the table: Final Energy Activities (node name, sector, activity, period)=================================================================
					axll::SelectSheet("FinalEnergy_Activities");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RfinalEnergy_act(nn,z,as,pnz),
					  RowHeaderRange : "A2:C5000",
					  ColumnHeaderRange : "D1:ZZ1",
					  DataRange : "D2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "C1"
					);
					
					!Write the table: Final Energy Matrix (node name, sector, activity, type, energy, period)=================================================================
					axll::SelectSheet("FinalEnergy_Matrix");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RfinalEnergy_matrixAct(nn,z,as,tof,el,pnz),
					  RowHeaderRange : "A2:E5000",
					  ColumnHeaderRange : "F1:ZZ1",
					  DataRange : "F2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Activity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "C1"
					);
					
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "D1"
					);
					!Write the parameter: Energy
					axll:: WriteSingleValue(
						ScalarReference 	:  energy_string,
						Cell           		:  "E1"
					);
					
					!Write the table: Energy Use Activities (node name, sector, activity, energy, period)=================================================================
					axll::SelectSheet("EnergyUse_Activities");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RenergyUse_act(nn,z,as,ae,pnz),
					  RowHeaderRange : "A2:D5000",
					  ColumnHeaderRange : "E1:ZZ1",
					  DataRange : "E2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Activity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "C1"
					);
					
					!Write the parameter: Energy
					axll:: WriteSingleValue(
						ScalarReference 	:  energy_string,
						Cell           		:  "D1"
					);
					
					!Write the table: Energy Costs (node name, activity, period) (note from Kira: these are average hourly energy costs on an annual basis)=================================================================
					axll::SelectSheet("EnergyCosts");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : REnergyCosts_node(nn,ae,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "B1"
					);
					
					!Write the table: Energy Costs Secondary (node name, activity, period) (note from Kira: these are average hourly energy costs on an annual basis)=================================================================
					axll::SelectSheet("EnergyCosts_secondary");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : REnergyCosts_node_secondary(nn,ass,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "B1"
					);
					
					!Write the table: Shadow Energy Prices (node name, activity, period)=================================================================
					axll::SelectSheet("ShadowEnergyPrices");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Rshadow_energyPrices(nn,ae,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "B1"
					);
					
					!Write the table: Shadow GHG Prices (node name, activity, period)=================================================================
					axll::SelectSheet("ShadowGHGPrices");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Rshadow_CO2Prices(nn,acf,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "B1"
					);
					
					!Write the table: Shadow CO2 Prices (node name, activity, period)=================================================================
					axll::SelectSheet("ShadowCO2Prices");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Rshadow_CO2Prices_single(n,p),
					  RowHeaderRange : "A2:A5000",
					  ColumnHeaderRange : "B1:ZZ1",
					  DataRange : "B2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					
					
					!Write the table: Primary Balance (node name, type of primary, energy label,  period)===========================================================
					axll::SelectSheet("Primary_Balance");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RprimaryBalance(nn,tope,el,pnz),
					  RowHeaderRange : "A2:C5000",
					  ColumnHeaderRange : "D1:ZZ1",
					  DataRange : "D2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Energy
					axll:: WriteSingleValue(
						ScalarReference 	:  energy_string,
						Cell           		:  "C1"
					);
					
					!Write the table: Primary Renewable (node name, energy label,  period)===========================================================
					axll::SelectSheet("Primary_Renewable");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Rprimary_renewable(nn,el,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Energy
					axll:: WriteSingleValue(
						ScalarReference 	:  energy_string,
						Cell           		:  "B1"
					);
					
					!Write the table: Final Decomposition (node name, type of decomposition,  period)===============================================================
					axll::SelectSheet("Final_Decomposition");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Rfinal_decomposition(nn,tod,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "B1"
					);
					
					!Write the table: Sankey Flows (node name, type of use, source, sink,  period)===========================================================
					axll::SelectSheet("Sankey");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Rsankey_flows(nn,tou,itos,jtos,pnz),
					  RowHeaderRange : "A2:D5000",
					  ColumnHeaderRange : "E1:ZZ1",
					  DataRange : "E2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Source
					axll:: WriteSingleValue(
						ScalarReference 	:  source_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Sink
					axll:: WriteSingleValue(
						ScalarReference 	:  sink_string,
						Cell           		:  "D1"
					);
					
					!Write the table: SupplyDemand (node name, activity, type of balance, technology, period)=======================================================
					axll::SelectSheet("SupplyDemand");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RsupdemAct_tech(nn,as,tob,tb,tn,pnz),
					  RowHeaderRange : "A2:E5000",
					  ColumnHeaderRange : "F1:ZZ1",
					  DataRange : "F2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Activity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	: type_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	: techID_string,
						Cell           		:  "D1"
					);
					!Write the parameter: Name
					axll:: WriteSingleValue(
						ScalarReference 	: name_string,
						Cell           		:  "E1"
					);
					
					!Write the table: CO2 emissions (node name, technology, period)=================================================================================
					axll::SelectSheet("CO2_Emissions");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Remissions_all(nn,t_c,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	:  techID_string,
						Cell           		:  "B1"
					);
					
					!Write the table: Sectoral emissions (node name, sector, activity, period)======================================================================
					axll::SelectSheet("Sectoral_Emissions");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Remissions_sec(nn,z,aer,pnz),
					  RowHeaderRange : "A2:C5000",
					  ColumnHeaderRange : "D1:ZZ1",
					  DataRange : "D2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Actvity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "C1"
					);
					
					!Write the table: Activity emissions (node name, sector, activity, activity, period)======================================================================
					axll::SelectSheet("Activity_Emissions");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Remissions_act(nn,z,as,aer,pnz),
					  RowHeaderRange : "A2:D5000",
					  ColumnHeaderRange : "E1:ZZ1",
					  DataRange : "E2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Actvity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "D1"
					);
					
					!Write the table: Technology emissions (node name, sector, activity,, technology, activity, period)======================================================================
					axll::SelectSheet("Technology_Emissions");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Remissions_tech(nn,z,as,tb,tn,aer,pnz),
					  RowHeaderRange : "A2:F5000",
					  ColumnHeaderRange : "G1:ZZ1",
					  DataRange : "G2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Actvity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Technology
					axll:: WriteSingleValue(
						ScalarReference 	:  techID_string,
						Cell           		:  "D1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "E1"
					);
					
					!Write the table: Power Stock(node name,technology, period)=====================================================================================
					axll::SelectSheet("Power_Stock");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RPower_stock(nn,tb,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	: techID_string,
						Cell           		:  "B1"
					);
					
					!Write the table: Power Gen(node name,technology, period)=======================================================================================
					axll::SelectSheet("Power_Gen");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RPower_gen(nn,tb,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	: techID_string,
						Cell           		:  "B1"
					);
					
					!Write the table: XC Stock(source,node,technology, period)======================================================================================
					axll::SelectSheet("XC_Stock");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RXC_stock(inn,nn,tb,pnz),
					  RowHeaderRange : "A2:C5000",
					  ColumnHeaderRange : "D1:ZZ1",
					  DataRange : "D2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  from_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  to_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	: techID_string,
						Cell           		:  "C1"
					);
					
					!Write the table: XC Use(source,node name,technology, period)===================================================================================
					axll::SelectSheet("XC_Use");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RXC_use(inn,nn,tb,pnz),
					  RowHeaderRange : "A2:C5000",
					  ColumnHeaderRange : "D1:ZZ1",
					  DataRange : "D2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  from_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  to_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	: techID_string,
						Cell           		:  "C1"
					);
					
					!Write the table: Power EU(activity,type,technology,period)===================================================================================
					axll::SelectSheet("Power_EU");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RPowerInfo_act(ahee,topi,tb,pnz),
					  RowHeaderRange : "A2:C5000",
					  ColumnHeaderRange : "D1:ZZ1",
					  DataRange : "D2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Activity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	: techID_string,
						Cell           		:  "C1"
					);
					
					!Write the table: XC EU(source,activity,type,technology,period)===================================================================================
					axll::SelectSheet("XC_EU");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RXCinfo_act(iahee,ahee,topi,tb,pnz),
					  RowHeaderRange : "A2:D5000",
					  ColumnHeaderRange : "E1:ZZ1",
					  DataRange : "E2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: From
					axll:: WriteSingleValue(
						ScalarReference 	:  from_string,
						Cell           		:  "A1"
					);
					!Write the parameter: To
					axll:: WriteSingleValue(
						ScalarReference 	:  to_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	: techID_string,
						Cell           		:  "D1"
					);
					
					!Write the table: RES curtailment(node, technology, period)=====================================================================================
					axll::SelectSheet("RES_Curtailment");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RcurtailmentRES(nn,th,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	: techID_string,
						Cell           		:  "B1"
					);
					
					!Write the table: Electricity Parameters(node, type, period)====================================================================================
					axll::SelectSheet("Electricity_Parameters");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Relectricity_parameters(nn,toep,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "B1"
					);
					
					!Write the table: Flexibility Volumes(node, type, period)=======================================================================================
					axll::SelectSheet("Flexibility_Volumes");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Rflexibility_volumes(nn,tox,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "B1"
					);
					
					!Write the table: Flexibility Activities(node, sector, activity, technology, type, period)=======================================================================================
					axll::SelectSheet("Flexibility_Activities");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Rflexibility_volumesAct(nn,z,as,tox,pnz),
					  RowHeaderRange : "A2:D5000",
					  ColumnHeaderRange : "E1:ZZ1",
					  DataRange : "E2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Activity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "D1"
					);
					
					!Write the table: Flexibility Technologies(node, technology, type, period)=======================================================================================
					axll::SelectSheet("Flexibility_Technologies");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Rflexibility_volumesTech(nn,tb,tox,pnz),
					  RowHeaderRange : "A2:C5000",
					  ColumnHeaderRange : "D1:ZZ1",
					  DataRange : "D2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Technology
					axll:: WriteSingleValue(
						ScalarReference 	:  techID_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "C1"
					);
					
					!Write the table: ResLoad Decomposition(node, type, period)=======================================================================================
					axll::SelectSheet("ResLoad_Decomposition");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Rdecomposition_resLoadY(nn,torlf,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "B1"
					);
					
					!Write the table: LCOPs Sector(nn,z,tots,toc,pnz)=======================================================================================
					axll::SelectSheet("LCOPs_Conversion");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RLCOP_secE(nn,z,tots,toc,pnz),
					  RowHeaderRange : "A2:D5000",
					  ColumnHeaderRange : "E1:ZZ1",
					  DataRange : "E2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Type1
					axll:: WriteSingleValue(
						ScalarReference 	:  type1_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Type2
					axll:: WriteSingleValue(
						ScalarReference 	:  type2_string,
						Cell           		:  "D1"
					);
					
					!Write the table: LCOPs Activity(nn,z,as,tots,toc,pnz)=======================================================================================
					axll::SelectSheet("LCOPs_Activities");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RLCOP_act(nn,z,as,tots,toc,pnz),
					  RowHeaderRange : "A2:E5000",
					  ColumnHeaderRange : "F1:ZZ1",
					  DataRange : "F2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Activity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Type1
					axll:: WriteSingleValue(
						ScalarReference 	:  type1_string,
						Cell           		:  "D1"
					);
					!Write the parameter: Type2
					axll:: WriteSingleValue(
						ScalarReference 	:  type2_string,
						Cell           		:  "E1"
					);
					
					!Write the table: LCOE(nn,as,tb,tol,pnz)=======================================================================================
					axll::SelectSheet("LCOEs");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RLCOE(nn,as,tb,tolm,tol,pnz),
					  RowHeaderRange : "A2:E5000",
					  ColumnHeaderRange : "F1:ZZ1",
					  DataRange : "F2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Activity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	:  techID_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Type1
					axll:: WriteSingleValue(
						ScalarReference 	:  type1_string,
						Cell           		:  "D1"
					);
					!Write the parameter: Type2
					axll:: WriteSingleValue(
						ScalarReference 	:  type2_string,
						Cell           		:  "E1"
					);
					
					!Write the table: Internatrional Transport(type, period)=======================================================================================
					axll::SelectSheet("International_Transport");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RintTransport_indicators(toitr,pnz),
					  RowHeaderRange : "A2:A5000",
					  ColumnHeaderRange : "B1:ZZ1",
					  DataRange : "B2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "A1"
					);
					
					!Write the table: tech_info(technology, types of info)==========================================================================================
					axll::SelectSheet("TechInfo");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : tech_info(t,tit),
					  RowHeaderRange : "A2:A5000",
					  ColumnHeaderRange : "B1:ZZ1",
					  DataRange : "B2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: TECH_ID
					axll:: WriteSingleValue(
						ScalarReference 	:  techID_string,
						Cell           		:  "A1"
					);
					
					!Write the table: flex_info(tff,a)=================================================================================================================
					axll::SelectSheet("FlexInfo");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : flex_info(tff,a),
					  RowHeaderRange : "A2:B1000",
					  ColumnHeaderRange : "",
					  DataRange : "C2:C1000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: TECH_ID
					axll:: WriteSingleValue(
						ScalarReference 	:  techID_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Activity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "C1"
					);
					
					!!Write the table: act_units(as)=================================================================================================================
					!axll::SelectSheet("ActInfo");
					!axll::ClearActiveSheet;	
					!axll::WriteTable(
					!  IdentifierReference : act_info(as,tia),
					!  RowHeaderRange : "A2:A1000",
					!  ColumnHeaderRange : "B1:ZZ1",
					!  DataRange : "B2:ZZ1000",
					!  allowRangeOverflow : 1,
					!  writeZeros : 1,
					!);
					!!Write the parameter: TECH_ID
					!axll:: WriteSingleValue(
					!	ScalarReference 	:  act_string,
					!	Cell           		:  "A1"
					!);
					
					!Write the parameter: scenario_description======================================================================================================
					axll::SelectSheet("Scenario");
					axll::ClearActiveSheet;	
					axll:: WriteSingleValue(
						ScalarReference 	:  scenario_description,
						Cell           		:  "A3"
					);
					
					!Write the parameters: MathProgram details======================================================================================================
					axll::SelectSheet("MathProgram");
					axll::ClearActiveSheet;
					axll::WriteTable(
					  IdentifierReference		: MathProgramParameters,
					  RowHeaderRange 		: "A2:A1000",
					  ColumnHeaderRange 		: "B1:ZZ1",
					  DataRange 			: "B2:ZZ1000",
					  allowRangeOverflow 		: 1,
					  writeZeros 			: 1,
					);       
					
					
					axll::CloseWorkBook(FileLocation);
				}
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure DataWriting_HourlyDispatch {
				Arguments: (FileLocation);
				Body: {
					if axll::WorkBookIsOpen(FileLocation) then
						!Open the workbook
					        axll::SelectWorkBook(FileLocation);
					else
						!Create a new workbook
						axll::CreateNewWorkBook(
						WorkbookFilename:FileLocation,
						FirstSheetName: "temp"
						);
					endif;
					
					!--------------------------------------------------------------------------------
					
					for (ipnz in periods_nonzeros) do
						axll::CreateSheet(SheetName : ipnz);
						axll::SelectSheet(ipnz);
						axll::ClearActiveSheet;	
						axll::WriteTable(
							IdentifierReference : RPower_dispatch(nn,h,tb,ipnz),
							RowHeaderRange : "A2:B300000",
							ColumnHeaderRange : "C1:ZZ1",
							DataRange : "C2:ZZ300000",
							allowRangeOverflow : 1,
							includeEmptyRowsColumns : 0,
							writeZeros : 1
						);
						!Write the parameter: Node
						axll:: WriteSingleValue(
							ScalarReference 	:  node_string,
							Cell           		:  "A1"
						);
						!Write the parameter: Hour
						axll:: WriteSingleValue(
							ScalarReference 	:  hour_string,
							Cell           		:  "B1"
						);
					endfor;
					
					axll::DeleteSheet(SheetName: "temp");
					
					axll::CloseWorkBook(FileLocation);
				}
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure DataWriting_LoadProfile_H {
				Arguments: (FileLocation);
				Body: {
					if axll::WorkBookIsOpen(FileLocation) then
						!Open the workbook
					        axll::SelectWorkBook(FileLocation);
					else
						!Create a new workbook
						axll::CreateNewWorkBook(
						WorkbookFilename:FileLocation,
						FirstSheetName: "temp"
						);
					endif;
					
					!--------------------------------------------------------------------------------
					
					for (ipnz in periods_nonzeros) do
						axll::CreateSheet(SheetName : ipnz);
						axll::SelectSheet(ipnz);
						axll::ClearActiveSheet;	
						axll::WriteTable(
							IdentifierReference : RloadProfiles_H(nn,h,ah,ipnz),
							RowHeaderRange : "A2:B300000",
							ColumnHeaderRange : "C1:ZZ1",
							DataRange : "C2:ZZ300000",
							allowRangeOverflow : 1,
							includeEmptyRowsColumns : 0,
							writeZeros : 1
						);
						!Write the parameter: Node
						axll:: WriteSingleValue(
							ScalarReference 	:  node_string,
							Cell           		:  "A1"
						);
						!Write the parameter: Hour
						axll:: WriteSingleValue(
							ScalarReference 	:  hour_string,
							Cell           		:  "B1"
						);
					endfor;
					
					axll::DeleteSheet(SheetName: "temp");
					
					axll::CloseWorkBook(FileLocation);
				}
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure DataWriting_FlexProfile_H {
				Arguments: (FileLocation);
				Body: {
					if axll::WorkBookIsOpen(FileLocation) then
						!Open the workbook
					        axll::SelectWorkBook(FileLocation);
					else
						!Create a new workbook
						axll::CreateNewWorkBook(
						WorkbookFilename:FileLocation,
						FirstSheetName: "temp"
						);
					endif;
					
					!--------------------------------------------------------------------------------
					
					for (ipnz in periods_nonzeros) do
						axll::CreateSheet(SheetName : ipnz);
						axll::SelectSheet(ipnz);
						axll::ClearActiveSheet;	
						axll::WriteTable(
							IdentifierReference : RflexProfiles_H(nn,topp,h,tb,ipnz),
							RowHeaderRange : "A2:C300000",
							ColumnHeaderRange : "D1:ZZ1",
							DataRange : "D2:ZZ300000",
							allowRangeOverflow : 1,
							includeEmptyRowsColumns : 0,
							writeZeros : 1
						);
						!Write the parameter: Node
						axll:: WriteSingleValue(
							ScalarReference 	:  node_string,
							Cell           		:  "A1"
						);
						!Write the parameter: Type
						axll:: WriteSingleValue(
							ScalarReference 	:  type_string,
							Cell           		:  "B1"
						);
						!Write the parameter: Hour
						axll:: WriteSingleValue(
							ScalarReference 	:  hour_string,
							Cell           		:  "C1"
						);
					endfor;
					
					axll::DeleteSheet(SheetName: "temp");
					
					axll::CloseWorkBook(FileLocation);
				}
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure DataWriting_EnergyCosts_H {
				Arguments: (FileLocation);
				Body: {
					if axll::WorkBookIsOpen(FileLocation) then
						!Open the workbook
					        axll::SelectWorkBook(FileLocation);
					else
						!Create a new workbook
						axll::CreateNewWorkBook(
						WorkbookFilename:FileLocation,
						FirstSheetName: "temp"
						);
					endif;
					
					!--------------------------------------------------------------------------------
					
					for (ipnz in periods_nonzeros) do
						axll::CreateSheet(SheetName : ipnz);
						axll::SelectSheet(ipnz);
						axll::ClearActiveSheet;	
						axll::WriteTable(
							IdentifierReference : REnergyCosts_hourly(h,ah,ipnz),
							RowHeaderRange : "A2:A10000",
							ColumnHeaderRange : "B1:ZZ1",
							DataRange : "B2:ZZ10000",
							allowRangeOverflow : 1,
							includeEmptyRowsColumns : 0,
							writeZeros : 1
						);
						!Write the parameter: Hour
						axll:: WriteSingleValue(
							ScalarReference 	:  hour_string,
							Cell           		:  "A1"
						);
					endfor;
					
					axll::DeleteSheet(SheetName: "temp");
					
					axll::CloseWorkBook(FileLocation);
				}
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure DataWriting_LoadProfile_D {
				Arguments: (FileLocation);
				Body: {
					if axll::WorkBookIsOpen(FileLocation) then
						!Open the workbook
					        axll::SelectWorkBook(FileLocation);
					else
						!Create a new workbook
						axll::CreateNewWorkBook(
						WorkbookFilename:FileLocation,
						FirstSheetName: "temp"
						);
					endif;
					
					!--------------------------------------------------------------------------------
					
					for (ipnz in periods_nonzeros) do
						axll::CreateSheet(SheetName : ipnz);
						axll::SelectSheet(ipnz);
						axll::ClearActiveSheet;	
						axll::WriteTable(
							IdentifierReference : RloadProfiles_D(nn,d,ad,ipnz),
							RowHeaderRange : "A2:B300000",
							ColumnHeaderRange : "C1:ZZ1",
							DataRange : "C2:ZZ300000",
							allowRangeOverflow : 1,
							includeEmptyRowsColumns : 0,
							writeZeros : 1
						);
						!Write the parameter: Node
						axll:: WriteSingleValue(
							ScalarReference 	:  node_string,
							Cell           		:  "A1"
						);
						!Write the parameter: Hour
						axll:: WriteSingleValue(
							ScalarReference 	:  day_string,
							Cell           		:  "B1"
						);
					endfor;
					
					axll::DeleteSheet(SheetName: "temp");
					
					axll::CloseWorkBook(FileLocation);
				}
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure DataWriting_FlexProfile_D {
				Arguments: (FileLocation);
				Body: {
					if axll::WorkBookIsOpen(FileLocation) then
						!Open the workbook
					        axll::SelectWorkBook(FileLocation);
					else
						!Create a new workbook
						axll::CreateNewWorkBook(
						WorkbookFilename:FileLocation,
						FirstSheetName: "temp"
						);
					endif;
					
					!--------------------------------------------------------------------------------
					
					for (ipnz in periods_nonzeros) do
						axll::CreateSheet(SheetName : ipnz);
						axll::SelectSheet(ipnz);
						axll::ClearActiveSheet;	
						axll::WriteTable(
							IdentifierReference : RfinProfiles_D(nn,d,tg,ipnz),
							RowHeaderRange : "A2:B300000",
							ColumnHeaderRange : "C1:ZZ1",
							DataRange : "C2:ZZ300000",
							allowRangeOverflow : 1,
							includeEmptyRowsColumns : 0,
							writeZeros : 1
						);
						!Write the parameter: Node
						axll:: WriteSingleValue(
							ScalarReference 	:  node_string,
							Cell           		:  "A1"
						);
						!Write the parameter: Hour
						axll:: WriteSingleValue(
							ScalarReference 	:  day_string,
							Cell           		:  "B1"
						);
					endfor;
					
					axll::DeleteSheet(SheetName: "temp");
					
					axll::CloseWorkBook(FileLocation);
				}
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure DataWriting_EnergyCosts_D {
				Arguments: (FileLocation);
				Body: {
					if axll::WorkBookIsOpen(FileLocation) then
						!Open the workbook
					        axll::SelectWorkBook(FileLocation);
					else
						!Create a new workbook
						axll::CreateNewWorkBook(
						WorkbookFilename:FileLocation,
						FirstSheetName: "temp"
						);
					endif;
					
					!--------------------------------------------------------------------------------
					
					for (ipnz in periods_nonzeros) do
						axll::CreateSheet(SheetName : ipnz);
						axll::SelectSheet(ipnz);
						axll::ClearActiveSheet;	
						axll::WriteTable(
							IdentifierReference : REnergyCosts_nodeD(nn,d,ad,ipnz),
							RowHeaderRange : "A2:B10000",
							ColumnHeaderRange : "C1:ZZ1",
							DataRange : "C2:ZZ10000",
							allowRangeOverflow : 1,
							includeEmptyRowsColumns : 0,
							writeZeros : 1
						);
						!Write the parameter: Node
						axll:: WriteSingleValue(
							ScalarReference 	:  node_string,
							Cell           		:  "A1"
						);
						!Write the parameter: Day
						axll:: WriteSingleValue(
							ScalarReference 	:  day_string,
							Cell           		:  "B1"
						);
					endfor;
					
					axll::DeleteSheet(SheetName: "temp");
					
					axll::CloseWorkBook(FileLocation);
				}
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure DataWriting_Profile_3D {
				Arguments: (FileLocation);
				Body: {
					if axll::WorkBookIsOpen(FileLocation) then
						!Open the workbook
					        axll::SelectWorkBook(FileLocation);
					else
						!Create a new workbook
						axll::CreateNewWorkBook(
						WorkbookFilename:FileLocation,
						FirstSheetName: "temp"
						);
					endif;
					
					!--------------------------------------------------------------------------------
					
					for (ipnz in periods_nonzeros) do
						axll::CreateSheet(SheetName : ipnz);
						axll::SelectSheet(ipnz);
						axll::ClearActiveSheet;	
						axll::WriteTable(
							IdentifierReference : Rprofiles3D(nn,w,h_d,t3a,ipnz),
							RowHeaderRange : "A2:C300000",
							ColumnHeaderRange : "D1:ZZ1",
							DataRange : "D2:ZZ300000",
							allowRangeOverflow : 1,
							includeEmptyRowsColumns : 0,
							writeZeros : 1
						);
						!Write the parameter: Node
						axll:: WriteSingleValue(
							ScalarReference 	:  node_string,
							Cell           		:  "A1"
						);
						!Write the parameter: Week
						axll:: WriteSingleValue(
							ScalarReference 	:  week_string,
							Cell           		:  "B1"
						);
						!Write the parameter: Hour
						axll:: WriteSingleValue(
							ScalarReference 	:  hour_string,
							Cell           		:  "C1"
						);
					endfor;
					
					axll::DeleteSheet(SheetName: "temp");
					
					axll::CloseWorkBook(FileLocation);
				}
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure DataWriting_ResidualLoad {
				Arguments: (FileLocation);
				Body: {
					if axll::WorkBookIsOpen(FileLocation) then
						!Open the workbook
					        axll::SelectWorkBook(FileLocation);
					else
						!Create a new workbook
						axll::CreateNewWorkBook(
						WorkbookFilename:FileLocation,
						FirstSheetName: "temp"
						);
					endif;
					
					!--------------------------------------------------------------------------------
					
					for (ipnz in periods_nonzeros) do
						axll::CreateSheet(SheetName : ipnz);
						axll::SelectSheet(ipnz);
						axll::ClearActiveSheet;	
						axll::WriteTable(
							IdentifierReference : Rresidual_load(nn,h,torl,ipnz),
							RowHeaderRange : "A2:B300000",
							ColumnHeaderRange : "C1:ZZ1",
							DataRange : "C2:ZZ300000",
							allowRangeOverflow : 1,
							includeEmptyRowsColumns : 0,
							writeZeros : 1
						);
						!Write the parameter: Node
						axll:: WriteSingleValue(
							ScalarReference 	:  node_string,
							Cell           		:  "A1"
						);
						!Write the parameter: Hour
						axll:: WriteSingleValue(
							ScalarReference 	:  hour_string,
							Cell           		:  "B1"
						);
					endfor;
					
					axll::DeleteSheet(SheetName: "temp");
					
					axll::CloseWorkBook(FileLocation);
				}
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure DataWriting_supplyResLoad {
				Arguments: (FileLocation);
				Body: {
					if axll::WorkBookIsOpen(FileLocation) then
						!Open the workbook
					        axll::SelectWorkBook(FileLocation);
					else
						!Create a new workbook
						axll::CreateNewWorkBook(
						WorkbookFilename:FileLocation,
						FirstSheetName: "temp"
						);
					endif;
					
					!--------------------------------------------------------------------------------
					
					for (ipnz in periods_nonzeros) do
						axll::CreateSheet(SheetName : ipnz);
						axll::SelectSheet(ipnz);
						axll::ClearActiveSheet;	
						axll::WriteTable(
							IdentifierReference : Rdecomposition_resLoad(nn,h,torlf,ipnz),
							RowHeaderRange : "A2:B300000",
							ColumnHeaderRange : "C1:ZZ1",
							DataRange : "C2:ZZ300000",
							allowRangeOverflow : 1,
							includeEmptyRowsColumns : 0,
							writeZeros : 1
						);
						!Write the parameter: Node
						axll:: WriteSingleValue(
							ScalarReference 	:  node_string,
							Cell           		:  "A1"
						);
						!Write the parameter: Hour
						axll:: WriteSingleValue(
							ScalarReference 	:  hour_string,
							Cell           		:  "B1"
						);
					endfor;
					
					axll::DeleteSheet(SheetName: "temp");
					
					axll::CloseWorkBook(FileLocation);
				}
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure runDataWritingTransition {
				Body: {
					!General data
					StatusMessage("Saving Output_General.xlsx ..." );
					DataWriting_General("Output/"+OutputFolderName+"/"+OutputFolderName+"_General.xlsx");
					
					!If hourly reports are required
					if (HourlyReportValue = 'yes') then
						StatusMessage("Saving Output_HourlyDispatch.xlsx ..." );
						DataWriting_HourlyDispatch("Output/"+OutputFolderName+"/"+OutputFolderName+"_HourlyDispatch.xlsx");
						StatusMessage("Saving Output_LoadProfile_H.xlsx ..." );
						DataWriting_LoadProfile_H("Output/"+OutputFolderName+"/"+OutputFolderName+"_LoadProfile_H.xlsx");
						StatusMessage("Saving Output_FlexProfile_H.xlsx ..." );
						DataWriting_FlexProfile_H("Output/"+OutputFolderName+"/"+OutputFolderName+"_FlexProfile_H.xlsx");
						StatusMessage("Saving Output_EnergyCosts_H.xlsx ..." );
						DataWriting_EnergyCosts_H("Output/"+OutputFolderName+"/"+OutputFolderName+"_EnergyCosts_H.xlsx");
						StatusMessage("Saving Output_LoadProfile_D.xlsx ..." );
						DataWriting_LoadProfile_D("Output/"+OutputFolderName+"/"+OutputFolderName+"_LoadProfile_D.xlsx");
						StatusMessage("Saving Output_FlexProfile_D.xlsx ..." );
						DataWriting_FlexProfile_D("Output/"+OutputFolderName+"/"+OutputFolderName+"_FlexProfile_D.xlsx");
						StatusMessage("Saving Output_EnergyCosts_D.xlsx ..." );
						DataWriting_EnergyCosts_D("Output/"+OutputFolderName+"/"+OutputFolderName+"_EnergyCosts_D.xlsx");
						StatusMessage("Saving Output_Profile_3D.xlsx ..." );
						DataWriting_Profile_3D("Output/"+OutputFolderName+"/"+OutputFolderName+"_Profile_3D.xlsx");
						StatusMessage("Saving Output_ResidualLoad.xlsx ..." );
						DataWriting_ResidualLoad("Output/"+OutputFolderName+"/"+OutputFolderName+"_ResidualLoad.xlsx");
						StatusMessage("Saving Output_supplyResLoad.xlsx ..." );
						DataWriting_supplyResLoad("Output/"+OutputFolderName+"/"+OutputFolderName+"_supplyResLoad.xlsx");
					endif;
					
					StatusMessage("Saving excel outputs Finished!" );
				}
			}
			DeclarationSection Batch_Writer_path {
				StringParameter totalCosts_CSV {
					Definition: "Output_Batch/"+OutputFolderName+"/totalCosts.CSV";
				}
				StringParameter tech_Use_CSV {
					Definition: "Output_Batch/"+OutputFolderName+"/tech_Use.CSV";
				}
				StringParameter tech_Stock_CSV {
					Definition: "Output_Batch/"+OutputFolderName+"/tech_Stock.CSV";
				}
				StringParameter commodity_prices_CSV {
					Definition: "Output_Batch/"+OutputFolderName+"/commodity_prices.CSV";
				}
				StringParameter CO2_price_CSV {
					Definition: "Output_Batch/"+OutputFolderName+"/CO2_price.CSV";
				}
				StringParameter tech_Use_h_CSV {
					Definition: "Output_Batch/"+OutputFolderName+"/tech_Use_h.CSV";
				}
				StringParameter tech_Use_d_CSV {
					Definition: "Output_Batch/"+OutputFolderName+"/tech_Use_d.CSV";
				}
			}
			Procedure Batch_Writer {
				Body: {
					dex::ReadAllMappings(); 
					
					dex::WriteToFile(
						dataFile    :  totalCosts_CSV, 
						mappingName :  "totalCosts_CSV", 
						pretty      :  1);
					
					dex::WriteToFile(
						dataFile    :  tech_Use_CSV ,
						mappingName :  "tech_use_CSV", 
						pretty      :  1);
					
					dex::WriteToFile(
						dataFile    :  tech_Stock_CSV, 
						mappingName :  "techStock_CSV", 
						pretty      :  1);
					
					dex::WriteToFile(
						dataFile    :  commodity_prices_CSV, 
						mappingName :  "yearly_prices_CSV", 
						pretty      :  1);
					
					dex::WriteToFile(
						dataFile    :  CO2_price_CSV, 
						mappingName :  "CO2_price_CSV", 
						pretty      :  1);
					
					! other hourly variables need to be mapped and written later
					if (HourlyReportValue = 'yes') then
						dex::WriteToFile(
							dataFile    :  tech_Use_h_CSV, 
							mappingName :  "tech_use_h_CSV", 
							pretty      :  1);
					
						dex::WriteToFile(
							dataFile    :  tech_Use_d_CSV, 
							mappingName :  "tech_use_d_CSV", 
							pretty      :  1);
					endif;
				}
				Comment: "Please make sure the parameter names are the same in the model and the mapping .xml files in ./Mappings";
			}
		}
		Procedure LoadCase_fromFile {
			Body: {
				!Load case as active from a data file
				CaseFileLoad(DataCaseLocation);
				
				StatusMessage("Data case was succesfully loaded" );
			}
		}
	}
	Section ProjectSpecific {
		DeclarationSection Linking {
			Parameter CO2_ETS_costs {
				IndexDomain: (tb,ps);
				Definition: {
					if activity_balances(tb,'CO2 Air ETS',ps)>0
						then activity_balances(tb,'CO2 Air ETS',ps)*vom_cost('Emi02_01',ps)
						else 0
					
					endif;
				}
			}
			Constraint EED_FinalEnergy_2030 {
				IndexDomain: ps | ps>='2030';
				Definition: {
					sum[(tb,ae) | ((nodePer_techBal(tb)='NL')*(tech_category(tb)='Final')*(activityPer_tech(tb)<>'Bunker Navigation')*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
						(-1)
						*
						(tech_use(tb,ps)+sum[h, deltaU_CHP(h,tb,ps)]+sum[h, deltaS_shed(h,tb,ps)])
						*(activity_balances(tb,ae,ps) - feedstockUse_tech(tb,ae))				! final energy minus feedstock
						+sum[h, (PdeltaQ_UP(h,tb,ps)+PdeltaQ_DW(h,tb,ps))]*dQ_hourly(tb,ae)			!Impact of flexibility in hourly activities
						+sum[h, PdeltaP_CHP(h,tb,ps)]*dP_electricity(tb,ae)					!Impact in power of power output ratio deviation of CHp
						+sum[h, -CHP_eta(tb)*PdeltaP_CHP(h,tb,ps)/CHP_eps(tb,ps)]*dP_heat(tb,ae)		!Impact in heat of power output ratio deviation of CHp
					] 
					
					!Final energy use for industrial material conversion processes
					+ sum[(tb,ae) | ((nodePer_techBal(tb)='NL')*(tech_category(tb)='Conversion')*(tech_sector(tb)='Industry')*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
						(-1)
						*
						(tech_use(tb,ps)+sum[h, deltaU_CHP(h,tb,ps)]+sum[h, deltaS_shed(h,tb,ps)])
						*(activity_balances(tb,ae,ps) - feedstockUse_tech(tb,ae))				! final energy minus feedstock
						+sum[h, (PdeltaQ_UP(h,tb,ps)+PdeltaQ_DW(h,tb,ps))]*dQ_hourly(tb,ae)			!Impact of flexibility in hourly activities
						+sum[h, PdeltaP_CHP(h,tb,ps)]*dP_electricity(tb,ae)					!Impact in power of power output ratio deviation of CHp
						+sum[h, -CHP_eta(tb)*PdeltaP_CHP(h,tb,ps)/CHP_eps(tb,ps)]*dP_heat(tb,ae)		!Impact in heat of power output ratio deviation of CHp
					]
					
					
					!CCS (DACs)
					+ sum[(tb,ae) | ((nodePer_techBal(tb)='NL')*(tech_category(tb)='Conversion')*(tech_sector(tb)='Industry')*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
						(-1)
						*
						(tech_use(tb,ps)+sum[h, deltaU_CHP(h,tb,ps)]+sum[h, deltaS_shed(h,tb,ps)])
						*(activity_balances(tb,ae,ps) - feedstockUse_tech(tb,ae))				! final energy minus feedstock
						+sum[h, (PdeltaQ_UP(h,tb,ps)+PdeltaQ_DW(h,tb,ps))]*dQ_hourly(tb,ae)			!Impact of flexibility in hourly activities
						+sum[h, PdeltaP_CHP(h,tb,ps)]*dP_electricity(tb,ae)					!Impact in power of power output ratio deviation of CHp
						+sum[h, -CHP_eta(tb)*PdeltaP_CHP(h,tb,ps)/CHP_eps(tb,ps)]*dP_heat(tb,ae)		!Impact in heat of power output ratio deviation of CHp
					]
					
					<= 1609  ! EED target by 2030
				}
			}
		}
		DeclarationSection Nuclear {
			Constraint MinLoad {
				IndexDomain: (h,thh,ps) | (StringOccurrences(tech_name(thh),'Nuclear')>=1);
				Definition: {
					tech_useHourly(h,thh,ps)
					>= 0.3*techStock(thh,ps)*cap2act(thh)*hourly_profiles(h,'Flat')
				}
			}
			Parameter NuclearCycleCount {
				IndexDomain: (t,ps) | (StringOccurrences(tech_name(t),'Nuclear')>=1);
				Definition: {
					round(sum[h , abs(tech_useHourly(h,t,ps)-tech_useHourly(h+1,t,ps))
					>0.1*(techStock(t,ps)>0.001)*techStock(t,ps)*cap2act(t)*hourly_profiles(h,profileType_tech(t))
					]/2,1)
				}
			}
		}
		DeclarationSection Adapt_Sena {
			Parameter test {
				IndexDomain: p;
				Definition: {
					sum[(atb,t), (tech_sector_kev(t)='Bunkerbrandstoffen')*(tech_activity(t)='Bunker Navigation')*
						(tech_use(t,p)+				! Reference activity balance
							sum[h, deltaU_CHP(h,t,p)]+		!Impact of use deviation of CHPs
							sum[h, deltaS_shed(h,t,p)])*		!Impact of shedding load
						activity_balances(t,atb,p)
					]
				}
			}
			Constraint Adapt_SectoTarget_emi_R {
				IndexDomain: ps | ps='2030';
				Definition: {
					sum[(act,t), (tech_sector_kev(t)='Gebouwde omgeving')*
					               (tech_use(t,ps)+                                                      ! Reference activity balance
					                             sum[h, deltaU_CHP(h,t,ps)]+                !Impact of use deviation of CHPs
					                             sum[h, deltaS_shed(h,t,ps)])*               !Impact of shedding load
					               activity_balances(t,act,ps)
					] 
					 <= 14.1;
				}
			}
			Constraint Adapt_SectoTarget_emi_A {
				IndexDomain: ps | ps='2030';
				Definition: {
					sum[(act,t), (tech_sector_kev(t)='Landbouw')*
					                                                         (tech_use(t,ps)+                                                      ! Reference activity balance
					                                                                       sum[h, deltaU_CHP(h,t,ps)]+                !Impact of use deviation of CHPs
					                                                                       sum[h, deltaS_shed(h,t,ps)])*               !Impact of shedding load
					                                                         activity_balances(t,act,ps)
					                                          ]  
					                                          <= 19.1;
				}
			}
			Constraint Adapt_SectoTarget_emi_T {
				IndexDomain: ps | ps='2030';
				Definition: {
					sum[(act,t), (tech_sector_kev(t)='Mobiliteit')*
					                                                         (tech_use(t,ps)+                                                      ! Reference activity balance
					                                                                       sum[h, deltaU_CHP(h,t,ps)]+                !Impact of use deviation of CHPs
					                                                                       sum[h, deltaS_shed(h,t,ps)])*               !Impact of shedding load
					                                                         activity_balances(t,act,ps)
					                                          ] 
					                                          <= 22.4
				}
			}
			Constraint Adapt_SectoTarget_emi_I {
				IndexDomain: ps | ps='2030';
				Definition: {
					sum[(act,t), 
					                                                         (tech_sector_kev(t)='Industrie')*
					                                                         (tech_use(t,ps)+                                                      ! Reference activity balance
					                                                                       sum[h, deltaU_CHP(h,t,ps)]+                !Impact of use deviation of CHPs
					                                                                       sum[h, deltaS_shed(h,t,ps)])*               !Impact of shedding load
					                                                         activity_balances(t,act,ps)
					                                          ] 
					                                          <= 31.4;
				}
			}
			Constraint Adapt_SectoTarget_emi_E {
				IndexDomain: ps | ps='2030';
				Definition: {
					sum[(act,t), (tech_sector_kev(t)='Elektriciteit')*
					                                                         (tech_use(t,ps)+                                                      ! Reference activity balance
					                                                                       sum[h, deltaU_CHP(h,t,ps)]+                !Impact of use deviation of CHPs
					                                                                       sum[h, deltaS_shed(h,t,ps)])*               !Impact of shedding load
					                                                         activity_balances(t,act,ps)
					                                          ] 
					                                          <= 13.9;
				}
			}
			Constraint Adapt_SectoTarget_emi30_BunkerNav {
				IndexDomain: ps | ps='2030';
				Definition: {
					sum[(ac,t), (tech_sector_kev(t)='Bunkerbrandstoffen')*(tech_activity(t)='Bunker Navigation')*
						(tech_use(t,ps)+				! Reference activity balance
							sum[h, deltaU_CHP(h,t,ps)]+		!Impact of use deviation of CHPs
							sum[h, deltaS_shed(h,t,ps)])*		!Impact of shedding load
						activity_balances(t,ac,ps)
					] 
					-
					sum[(tb,acr) | (tb='TNB01_10')<>0,
					(-1)
					*
					(tech_use(tb,ps)
					*activity_balances(tb,acr,ps))
					]    
					<= 34.4 ! Based on 10% emission reduction compared to the 2019 (37 Mton CO2)
				}
			}
			Constraint Adapt_SectoTarget_emi35_BunkerNav {
				IndexDomain: ps | ps='2035';
				Definition: {
					sum[(ac,t), (tech_sector_kev(t)='Bunkerbrandstoffen')*(tech_activity(t)='Bunker Navigation')*
						(tech_use(t,ps)+				! Reference activity balance
							sum[h, deltaU_CHP(h,t,ps)]+		!Impact of use deviation of CHPs
							sum[h, deltaS_shed(h,t,ps)])*		!Impact of shedding load
						activity_balances(t,ac,ps)
					] 
					-
					sum[(tb,acr) | (tb='TNB01_10')<>0,
					(-1)
					*
					(tech_use(tb,ps)
					*activity_balances(tb,acr,ps))
					]    
					<= 32.5
				}
			}
			Constraint Adapt_SectoTarget_emi40_BunkerNav {
				IndexDomain: ps | ps='2040';
				Definition: {
					sum[(ac,t), (tech_sector_kev(t)='Bunkerbrandstoffen')*(tech_activity(t)='Bunker Navigation')*
						(tech_use(t,ps)+				! Reference activity balance
							sum[h, deltaU_CHP(h,t,ps)]+		!Impact of use deviation of CHPs
							sum[h, deltaS_shed(h,t,ps)])*		!Impact of shedding load
						activity_balances(t,ac,ps)
					] 
					-
					sum[(tb,acr) | (tb='TNB01_10')<>0,
					(-1)
					*
					(tech_use(tb,ps)
					*activity_balances(tb,acr,ps))
					]    
					<= 30.5
				}
			}
			Constraint Adapt_SectoTarget_emi45_BunkerNav {
				IndexDomain: ps | ps='2045';
				Definition: {
					sum[(ac,t), (tech_sector_kev(t)='Bunkerbrandstoffen')*(tech_activity(t)='Bunker Navigation')*
						(tech_use(t,ps)+				! Reference activity balance
							sum[h, deltaU_CHP(h,t,ps)]+		!Impact of use deviation of CHPs
							sum[h, deltaS_shed(h,t,ps)])*		!Impact of shedding load
						activity_balances(t,ac,ps)
					] 
					-
					sum[(tb,acr) | (tb='TNB01_10')<>0,
					(-1)
					*
					(tech_use(tb,ps)
					*activity_balances(tb,acr,ps))
					]    
					<= 28.6
				}
			}
			Constraint Adapt_SectoTarget_emi50_BunkerNav {
				IndexDomain: ps | ps='2050';
				Definition: {
					sum[(ac,t), (tech_sector_kev(t)='Bunkerbrandstoffen')*(tech_activity(t)='Bunker Navigation')*
						(tech_use(t,ps)+				! Reference activity balance
							sum[h, deltaU_CHP(h,t,ps)]+		!Impact of use deviation of CHPs
							sum[h, deltaS_shed(h,t,ps)])*		!Impact of shedding load
						activity_balances(t,ac,ps)
					] 
					-
					sum[(tb,acr) | (tb='TNB01_10')<>0,
					(-1)
					*
					(tech_use(tb,ps)
					*activity_balances(tb,acr,ps))
					]    
					<= 26.7
				}
			}
			Constraint Adapt_SectoTarget_emi30_BunkerAvi {
				IndexDomain: ps | ps='2030';
				Definition: {
					sum[(ac,t), (tech_sector_kev(t)='Bunkerbrandstoffen')*(tech_activity(t)='Bunker Aviation')*
					               (tech_use(t,ps)+                                                      ! Reference activity balance
					               sum[h, deltaU_CHP(h,t,ps)]+                !Impact of use deviation of CHPs
					               sum[h, deltaS_shed(h,t,ps)])*               !Impact of shedding load
					               activity_balances(t,ac,ps)
					               ] 
					-
					sum[(tb,acr) | (tb='TAI01_07')<>0,
					(-1)
					*
					(tech_use(tb,ps)
					*activity_balances(tb,acr,ps))
					]    
					<= 10.7
				}
			}
			Constraint Adapt_SectoTarget_emi35_BunkerAvi {
				IndexDomain: ps | ps='2035';
				Definition: {
					sum[(ac,t), (tech_sector_kev(t)='Bunkerbrandstoffen')*(tech_activity(t)='Bunker Aviation')*
					               (tech_use(t,ps)+                                                      ! Reference activity balance
					               sum[h, deltaU_CHP(h,t,ps)]+                !Impact of use deviation of CHPs
					               sum[h, deltaS_shed(h,t,ps)])*               !Impact of shedding load
					               activity_balances(t,ac,ps)
					               ] 
					-
					sum[(tb,acr) | (tb='TAI01_07')<>0,
					(-1)
					*
					(tech_use(tb,ps)
					*activity_balances(tb,acr,ps))
					]    
					<= 9.4
				}
			}
			Constraint Adapt_SectoTarget_emi40_BunkerAvi {
				IndexDomain: ps | ps='2040';
				Definition: {
					sum[(ac,t), (tech_sector_kev(t)='Bunkerbrandstoffen')*(tech_activity(t)='Bunker Aviation')*
					               (tech_use(t,ps)+                                                      ! Reference activity balance
					               sum[h, deltaU_CHP(h,t,ps)]+                !Impact of use deviation of CHPs
					               sum[h, deltaS_shed(h,t,ps)])*               !Impact of shedding load
					               activity_balances(t,ac,ps)
					               ] 
					-
					sum[(tb,acr) | (tb='TAI01_07')<>0,
					(-1)
					*
					(tech_use(tb,ps)
					*activity_balances(tb,acr,ps))
					]    
					<= 8.1
				}
			}
			Constraint Adapt_SectoTarget_emi45_BunkerAvi {
				IndexDomain: ps | ps='2045';
				Definition: {
					sum[(ac,t), (tech_sector_kev(t)='Bunkerbrandstoffen')*(tech_activity(t)='Bunker Aviation')*
					               (tech_use(t,ps)+                                                      ! Reference activity balance
					               sum[h, deltaU_CHP(h,t,ps)]+                !Impact of use deviation of CHPs
					               sum[h, deltaS_shed(h,t,ps)])*               !Impact of shedding load
					               activity_balances(t,ac,ps)
					               ] 
					-
					sum[(tb,acr) | (tb='TAI01_07')<>0,
					(-1)
					*
					(tech_use(tb,ps)
					*activity_balances(tb,acr,ps))
					]  
					<= 6.2
				}
			}
			Constraint Adapt_SectoTarget_emi50_BunkerAvi {
				IndexDomain: ps | ps='2050';
				Definition: {
					sum[(ac,t), (tech_sector_kev(t)='Bunkerbrandstoffen')*(tech_activity(t)='Bunker Aviation')*
					               (tech_use(t,ps)+                                                      ! Reference activity balance
					               sum[h, deltaU_CHP(h,t,ps)]+                !Impact of use deviation of CHPs
					               sum[h, deltaS_shed(h,t,ps)])*               !Impact of shedding load
					               activity_balances(t,ac,ps)
					               ] 
					-
					sum[(tb,acr) | (tb='TAI01_07')<>0,
					(-1)
					*
					(tech_use(tb,ps)
					*activity_balances(tb,acr,ps))
					]             
					<= 5.5
				}
			}
			Constraint Adapt_RefinProd_2030 {
				IndexDomain: ps | ps='2030';
				Definition: {
					sum[(a,t) | a in activities_energy, (tech_sector(t)='Refineries' and tech_subsector(t)='Fossil Based')*(activity_balances(t,a,ps)>0)*
						(tech_use(t,ps)+				! Reference activity balance
							sum[h, deltaU_CHP(h,t,ps)]+		!Impact of use deviation of CHPs
							sum[h, deltaS_shed(h,t,ps)])*		!Impact of shedding load
						activity_balances(t,a,ps)
					] 
					<= 1802
				}
			}
			Constraint Adapt_RefinProd_2050 {
				IndexDomain: ps | ps='2050';
				Definition: {
					sum[(a,t) | a in activities_energy, (tech_sector(t)='Refineries' and tech_subsector(t)='Fossil Based')*(activity_balances(t,a,ps)>0)*
						(tech_use(t,ps)+				! Reference activity balance
							sum[h, deltaU_CHP(h,t,ps)]+		!Impact of use deviation of CHPs
							sum[h, deltaS_shed(h,t,ps)])*		!Impact of shedding load
						activity_balances(t,a,ps)
					] 
					<= 1202
				}
			}
			Constraint Adapt_FinalEnergy_2030 {
				IndexDomain: ps | ps='2030';
				Definition: {
					sum[(tb,ae) | ((nodePer_techBal(tb)='NL')*(tech_category(tb)='Final')*(activityPer_tech(tb)<>'Bunker Navigation')*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
						(-1)
						*
						(tech_use(tb,ps)+sum[h, deltaU_CHP(h,tb,ps)]+sum[h, deltaS_shed(h,tb,ps)])
						*(activity_balances(tb,ae,ps) - feedstockUse_tech(tb,ae))				! final energy minus feedstock
						+sum[h, (PdeltaQ_UP(h,tb,ps)+PdeltaQ_DW(h,tb,ps))]*dQ_hourly(tb,ae)			!Impact of flexibility in hourly activities
						+sum[h, PdeltaP_CHP(h,tb,ps)]*dP_electricity(tb,ae)					!Impact in power of power output ratio deviation of CHp
						+sum[h, -CHP_eta(tb)*PdeltaP_CHP(h,tb,ps)/CHP_eps(tb,ps)]*dP_heat(tb,ae)		!Impact in heat of power output ratio deviation of CHp
					] 
					
					!Final energy use for industrial material conversion processes
					+ sum[(tb,ae) | ((nodePer_techBal(tb)='NL')*(tech_category(tb)='Conversion')*(tech_sector(tb)='Industry')*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
						(-1)
						*
						(tech_use(tb,ps)+sum[h, deltaU_CHP(h,tb,ps)]+sum[h, deltaS_shed(h,tb,ps)])
						*(activity_balances(tb,ae,ps) - feedstockUse_tech(tb,ae))				! final energy minus feedstock
						+sum[h, (PdeltaQ_UP(h,tb,ps)+PdeltaQ_DW(h,tb,ps))]*dQ_hourly(tb,ae)			!Impact of flexibility in hourly activities
						+sum[h, PdeltaP_CHP(h,tb,ps)]*dP_electricity(tb,ae)					!Impact in power of power output ratio deviation of CHp
						+sum[h, -CHP_eta(tb)*PdeltaP_CHP(h,tb,ps)/CHP_eps(tb,ps)]*dP_heat(tb,ae)		!Impact in heat of power output ratio deviation of CHp
					]
					
					
					!CCS (DACs)
					+ sum[(tb,ae) | ((nodePer_techBal(tb)='NL')*(tech_category(tb)='Conversion')*(tech_sector(tb)='Industry')*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
						(-1)
						*
						(tech_use(tb,ps)+sum[h, deltaU_CHP(h,tb,ps)]+sum[h, deltaS_shed(h,tb,ps)])
						*(activity_balances(tb,ae,ps) - feedstockUse_tech(tb,ae))				! final energy minus feedstock
						+sum[h, (PdeltaQ_UP(h,tb,ps)+PdeltaQ_DW(h,tb,ps))]*dQ_hourly(tb,ae)			!Impact of flexibility in hourly activities
						+sum[h, PdeltaP_CHP(h,tb,ps)]*dP_electricity(tb,ae)					!Impact in power of power output ratio deviation of CHp
						+sum[h, -CHP_eta(tb)*PdeltaP_CHP(h,tb,ps)/CHP_eps(tb,ps)]*dP_heat(tb,ae)		!Impact in heat of power output ratio deviation of CHp
					]
					
					<= 1609  ! EED target by 2030
				}
			}
			Constraint CO2_credits_Avi {
				IndexDomain: ps;
				Definition: {
					!Sum of all CO2 credits for aviation must be equal to the CO2 inputs to e-kerosene and synkerosene used in the Bunker Aviation sector
					!>= would allow additional credits to be used in this sector beyond what would correspond to the synthetic fuel use
					
					sum[(tb,acr) | (tb='TAI01_07')<>0,
					(-1)
					*
					(tech_use(tb,ps)
					*activity_balances(tb,acr,ps))
					]
					-
					([sum[(tb,ae) | (activityPer_tech(tb)='Bunker Aviation')*(ae='E-Kerosene'),
					(-1)
					*
					tech_use(tb,ps)
					*activity_balances(tb,ae,ps)]
					]
					+
					[sum[(tb,ae) | (activityPer_tech(tb)='Bunker Aviation')*(ae='Syn Kerosene'),
					(-1)
					*
					tech_use(tb,ps)
					*activity_balances(tb,ae,ps)]
					])
					*0.072 !CO2 input to e-kerosene production (Mton/PJ) - rough estimate because different conversion efficiencies per process
					=0;
				}
			}
			Constraint CO2_credits_Nav {
				IndexDomain: ps;
				Definition: {
					!Sum of all CO2 credits for aviation must be equal to the CO2 inputs to methanol and syn-diesel used in the Bunker Navigation sector
					! >= would allow additional credits to be used in this sector beyond what would correspond to the synthetic fuel use
					
					sum[(tb,acr) | (tb='TNB01_10')<>0,
					(-1)
					*
					(tech_use(tb,ps)
					*activity_balances(tb,acr,ps))
					]
					-
					([sum[(tb,ae) | (activityPer_tech(tb)='Bunker Navigation')*(ae='Methanol'),
					(-1)
					*
					tech_use(tb,ps)
					*activity_balances(tb,ae,ps)]
					*0.074 !CO2 input to methanol production (Mton/PJ)
					]
					+
					[sum[(tb,ae) | (activityPer_tech(tb)='Bunker Navigation')*(ae='E-Methanol'),
					(-1)
					*
					tech_use(tb,ps)
					*activity_balances(tb,ae,ps)]
					*0.074 !CO2 input to methanol production (Mton/PJ)
					]
					+
					[sum[(tb,ae) | (activityPer_tech(tb)='Bunker Navigation')*(ae='Syn Diesel'),
					(-1)
					*
					tech_use(tb,ps)
					*activity_balances(tb,ae,ps)]
					]
					*0.073 !CO2 input to diesel (Mton/PJ) - rough estimate because different conversion efficiencies per process
					)
					=0;
				}
			}
		}
		DeclarationSection ReFuelEU_Aviation {
			Parameter ReFuelEU_Aviation_eSAF_target {
				IndexDomain: p;
				Definition: {
					data { 2030 : 0.012,  2035 : 0.050,  2040 : 0.100,  2045 : 0.150,  2050 : 0.350 }
					
					!eSAF targets from ReFuel EU Aviation
				}
			}
			Parameter ReFuelEU_Aviation_SAF_target {
				IndexDomain: p;
				Definition: data { 2030 : 0.060,  2035 : 0.200,  2040 : 0.340,  2045 : 0.420,  2050 : 0.700 };
			}
			Constraint eSAF_Aviation {
				IndexDomain: p | p>='2030';
				Definition: {
					!E-kerosene use in Bunker Aviation must be greater than or equal target e-SAF level times total Bunker Aviation energy use
					
					
					sum[(tb,ae) | (activityPer_tech(tb)='Bunker Aviation')*(ae='E-Kerosene')<>0,
					(-1)
					*
					(tech_use(tb,p)
					*activity_balances(tb,ae,p))
					]
					-
					sum[(tb,ae) | activityPer_tech(tb)='Bunker Aviation',
					(-1)
					*
					(tech_use(tb,p)
					*activity_balances(tb,ae,p))
					]
					*ReFuelEU_Aviation_eSAF_target(p)
					>=0;
				}
			}
			Constraint SAF_Aviation {
				IndexDomain: p | p>='2030';
				Definition: {
					!Sum of e-kerosene, synkerosene, and biokerosene use in Bunker Aviation sector must meet the target percentage of total Bunker Aviation energy use
					
					sum[(tb,ae) | (activityPer_tech(tb)='Bunker Aviation')*(ae='E-Kerosene')<>0,
					(-1)
					*
					(tech_use(tb,p)
					*activity_balances(tb,ae,p))
					]
					+
					sum[(tb,ae) | (activityPer_tech(tb)='Bunker Aviation')*(ae='Bio Kerosene')<>0,
					(-1)
					*
					(tech_use(tb,p)
					*activity_balances(tb,ae,p))
					]
					+
					sum[(tb,ae) | (activityPer_tech(tb)='Bunker Aviation')*(ae='Syn Kerosene')<>0,
					(-1)
					*
					(tech_use(tb,p)
					*activity_balances(tb,ae,p))
					]
					-
					sum[(tb,ae) | activityPer_tech(tb)='Bunker Aviation',
					(-1)
					*
					(tech_use(tb,p)
					*activity_balances(tb,ae,p))
					]
					*ReFuelEU_Aviation_SAF_target(p) !SAF target from ReFuelEU Aviation
					>=0;
				}
			}
			Constraint H2_credits_Avi {
				IndexDomain: ps;
				Definition: {
					!Sum of all H2 credits for aviation must be equal to the H2 inputs to e-kerosene used in the Bunker Aviation sector
					!This represents the RFNBO obligation under ReFuelEU Aviation
					!Synkerosene use with other types of hydrogen are still allowed (synkerosene airplanes)
					!H2 input is approximate
					!>= would allow additional credits to be used in this sector beyond what would correspond to the synthetic fuel use
					
					sum[(tb,acr) | (tb='TAI01_06')<>0,
					(-1)
					*
					(tech_use(tb,ps)
					*activity_balances(tb,acr,ps))
					]
					-
					[sum[(tb,ae) | (activityPer_tech(tb)='Bunker Aviation')*(ae='E-Kerosene'),
					(-1)
					*
					tech_use(tb,ps)
					*activity_balances(tb,ae,ps)]
					*2.1 !hydrogen input to e-kerosene production (PJ/PJ) - rough estimate because different conversion efficiencies per process
					]
					=0;
				}
			}
		}
		DeclarationSection FuelEU_Maritime {
			Parameter FuelEU_Maritime_target {
				IndexDomain: p;
				Definition: {
					data { 2030 : 35.000,  2035 : 32.200,  2040 : 26.700,  2045 : 16.400,  2050 : 10.400 }
					
					! 2030 Based on 6% emission reduction compared to the 2019 (37 Mton CO2)
				}
			}
			Constraint SectorTarget_emi_BunkerNav {
				IndexDomain: p | p>'2030';
				Definition: {
					!Total accounted emissions from Bunker Navigation sector (including emissions from synfuels) minus CO2 credits used in Bunker Aviation less than or equal to the target
					
					sum[(atb,t), (tech_sector_kev(t)='Bunkerbrandstoffen')*(tech_activity(t)='Bunker Navigation')*
						(tech_use(t,p)+				! Reference activity balance
							sum[h, deltaU_CHP(h,t,p)]+		!Impact of use deviation of CHPs
							sum[h, deltaS_shed(h,t,p)])*		!Impact of shedding load
						activity_balances(t,atb,p)
					] 
					-
					sum[(tb,acr) | (tb='TNB01_10')<>0,
					(-1)
					*
					(tech_use(tb,p)
					*activity_balances(tb,acr,p))
					]    
					<= FuelEU_Maritime_target(p); !emission target values contained in this (manually added) parameter
				}
			}
			Constraint H2_credits_Nav {
				IndexDomain: ps;
				Definition: {
					!Sum of all H2 credits for navigation must be equal to the H2 inputs to methanol or ammonia used in the Bunker Navigation sector
					!This represents the RFNBO obligation under FuelEU Maritime
					!Syndiesel use with other types of hydrogen are still allowed (syndiesel ships)
					!H2 input is approximate
					!>= would allow additional credits to be used in this sector beyond what would correspond to the synthetic fuel use
					
					sum[(tb,acr) | (tb='TNB01_09')<>0,
					(-1)
					*
					(tech_use(tb,ps)
					*activity_balances(tb,acr,ps))
					]
					-
					([sum[(tb,ae) | (activityPer_tech(tb)='Bunker Navigation')*(ae='Ammonia'),
					(-1)
					*
					tech_use(tb,ps)
					*activity_balances(tb,ae,ps)]
					*1.15 !hydrogen input to methanol production (PJ/PJ) 
					]
					+
					[sum[(tb,ae) | (activityPer_tech(tb)='Bunker Navigation')*(ae='Methanol'),
					(-1)
					*
					tech_use(tb,ps)
					*activity_balances(tb,ae,ps)]
					*1.20 !hydrogen input to ammonia production (PJ/PJ) 
					])
					
					=0;
				}
			}
		}
		DeclarationSection Kira_paper;
		DeclarationSection Transform {
			Constraint Transform_SectoTarget_emi_R {
				IndexDomain: ps | ps='2030';
				Definition: {
					sum[(act,t), (tech_sector_kev(t)='Gebouwde omgeving')*
						(tech_use(t,ps)+				! Reference activity balance
							sum[h, deltaU_CHP(h,t,ps)]+		!Impact of use deviation of CHPs
							sum[h, deltaS_shed(h,t,ps)])*		!Impact of shedding load
						activity_balances(t,act,ps)
					] 
					 <= 14.1;
				}
			}
			Constraint Transform_SectoTarget_emi_A {
				IndexDomain: ps | ps='2030';
				Definition: {
					sum[(act,t), (tech_sector_kev(t)='Landbouw')*
						(tech_use(t,ps)+				! Reference activity balance
							sum[h, deltaU_CHP(h,t,ps)]+		!Impact of use deviation of CHPs
							sum[h, deltaS_shed(h,t,ps)])*		!Impact of shedding load
						activity_balances(t,act,ps)
					]  
					<= 19.1
				}
			}
			Constraint Transform_SectoTarget_emi_T {
				IndexDomain: ps | ps='2030';
				Definition: {
					sum[(act,t), (tech_sector_kev(t)='Mobiliteit')*
						(tech_use(t,ps)+				! Reference activity balance
							sum[h, deltaU_CHP(h,t,ps)]+		!Impact of use deviation of CHPs
							sum[h, deltaS_shed(h,t,ps)])*		!Impact of shedding load
						activity_balances(t,act,ps)
					] 
					<= 22.4
				}
			}
			Constraint Transform_SectoTarget_emi_I {
				IndexDomain: ps | ps='2030';
				Definition: {
					sum[(act,t), 
						(tech_sector_kev(t)='Industrie')*
						(tech_use(t,ps)+				! Reference activity balance
							sum[h, deltaU_CHP(h,t,ps)]+		!Impact of use deviation of CHPs
							sum[h, deltaS_shed(h,t,ps)])*		!Impact of shedding load
						activity_balances(t,act,ps)
					] 
					<= 31.4
				}
			}
			Constraint Transform_SectoTarget_emi_E {
				IndexDomain: ps | ps='2030';
				Definition: {
					sum[(act,t), (tech_sector_kev(t)='Elektriciteit')*
						(tech_use(t,ps)+				! Reference activity balance
							sum[h, deltaU_CHP(h,t,ps)]+		!Impact of use deviation of CHPs
							sum[h, deltaS_shed(h,t,ps)])*		!Impact of shedding load
						activity_balances(t,act,ps)
					] 
					<= 13.9
				}
			}
			Constraint Transform_SectoTarget_emi_BunkerAvi {
				IndexDomain: ps | ps='2030';
				Definition: {
					sum[(atb,t), (tech_sector_kev(t)='Bunkerbrandstoffen')*(tech_activity(t)='Bunker Aviation')*
						(tech_use(t,ps)+				! Reference activity balance
							sum[h, deltaU_CHP(h,t,ps)]+		!Impact of use deviation of CHPs
							sum[h, deltaS_shed(h,t,ps)])*		!Impact of shedding load
						activity_balances(t,atb,ps)
					] 
					<= 9.21
				}
			}
			Constraint Transform_SectoTarget_emi_BunkerNav {
				IndexDomain: ps | ps='2030';
				Definition: {
					sum[(atb,t), (tech_sector_kev(t)='Bunkerbrandstoffen')*(tech_activity(t)='Bunker Navigation')*
						(tech_use(t,ps)+				! Reference activity balance
							sum[h, deltaU_CHP(h,t,ps)]+		!Impact of use deviation of CHPs
							sum[h, deltaS_shed(h,t,ps)])*		!Impact of shedding load
						activity_balances(t,atb,ps)
					] 
					<= 31.24
				}
			}
			Constraint Transform_RefinProd_2030 {
				IndexDomain: ps | ps='2030';
				Definition: {
					sum[(a,t) | a in activities_energy, (tech_sector(t)='Refineries' and tech_subsector(t)='Fossil Based')*(activity_balances(t,a,ps)>0)*
						(tech_use(t,ps)+				! Reference activity balance
							sum[h, deltaU_CHP(h,t,ps)]+		!Impact of use deviation of CHPs
							sum[h, deltaS_shed(h,t,ps)])*		!Impact of shedding load
						activity_balances(t,a,ps)
					] 
					<= 1330
				}
			}
			Constraint Transform_RefinProd_2050 {
				IndexDomain: ps | ps='2050';
				Definition: {
					sum[(a,t) | a in activities_energy, (tech_sector(t)='Refineries' and tech_subsector(t)='Fossil Based')*(activity_balances(t,a,ps)>0)*
						(tech_use(t,ps)+				! Reference activity balance
							sum[h, deltaU_CHP(h,t,ps)]+		!Impact of use deviation of CHPs
							sum[h, deltaS_shed(h,t,ps)])*		!Impact of shedding load
						activity_balances(t,a,ps)
					] 
					<= 335
				}
			}
			Constraint Transform_FinalEnergy_2030 {
				IndexDomain: ps | ps='2030';
				Definition: {
					sum[(tb,ae) | ((nodePer_techBal(tb)='NL')*(tech_category(tb)='Final')*(activityPer_tech(tb)<>'Bunker Navigation')*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
						(-1)
						*
						(tech_use(tb,ps)+sum[h, deltaU_CHP(h,tb,ps)]+sum[h, deltaS_shed(h,tb,ps)])
						*(activity_balances(tb,ae,ps) - feedstockUse_tech(tb,ae))				! final energy minus feedstock
						+sum[h, (PdeltaQ_UP(h,tb,ps)+PdeltaQ_DW(h,tb,ps))]*dQ_hourly(tb,ae)			!Impact of flexibility in hourly activities
						+sum[h, PdeltaP_CHP(h,tb,ps)]*dP_electricity(tb,ae)					!Impact in power of power output ratio deviation of CHp
						+sum[h, -CHP_eta(tb)*PdeltaP_CHP(h,tb,ps)/CHP_eps(tb,ps)]*dP_heat(tb,ae)		!Impact in heat of power output ratio deviation of CHp
					] 
					
					!Final energy use for industrial material conversion processes
					+ sum[(tb,ae) | ((nodePer_techBal(tb)='NL')*(tech_category(tb)='Conversion')*(tech_sector(tb)='Industry')*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
						(-1)
						*
						(tech_use(tb,ps)+sum[h, deltaU_CHP(h,tb,ps)]+sum[h, deltaS_shed(h,tb,ps)])
						*(activity_balances(tb,ae,ps) - feedstockUse_tech(tb,ae))				! final energy minus feedstock
						+sum[h, (PdeltaQ_UP(h,tb,ps)+PdeltaQ_DW(h,tb,ps))]*dQ_hourly(tb,ae)			!Impact of flexibility in hourly activities
						+sum[h, PdeltaP_CHP(h,tb,ps)]*dP_electricity(tb,ae)					!Impact in power of power output ratio deviation of CHp
						+sum[h, -CHP_eta(tb)*PdeltaP_CHP(h,tb,ps)/CHP_eps(tb,ps)]*dP_heat(tb,ae)		!Impact in heat of power output ratio deviation of CHp
					]
					
					!CCS (DACs)
					+ sum[(tb,ae) | ((nodePer_techBal(tb)='NL')*(tech_category(tb)='Conversion')*(tech_sector(tb)='Industry')*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
						(-1)
						*
						(tech_use(tb,ps)+sum[h, deltaU_CHP(h,tb,ps)]+sum[h, deltaS_shed(h,tb,ps)])
						*(activity_balances(tb,ae,ps) - feedstockUse_tech(tb,ae))				! final energy minus feedstock
						+sum[h, (PdeltaQ_UP(h,tb,ps)+PdeltaQ_DW(h,tb,ps))]*dQ_hourly(tb,ae)			!Impact of flexibility in hourly activities
						+sum[h, PdeltaP_CHP(h,tb,ps)]*dP_electricity(tb,ae)					!Impact in power of power output ratio deviation of CHp
						+sum[h, -CHP_eta(tb)*PdeltaP_CHP(h,tb,ps)/CHP_eps(tb,ps)]*dP_heat(tb,ae)		!Impact in heat of power output ratio deviation of CHp
					]
					
					<= 1609  ! EED target by 2030
				}
			}
		}
		DeclarationSection RFNBO_Industry_and_Transport {
			Comment: {
				"https://energy.ec.europa.eu/topics/eus-energy-system/hydrogen/renewable-hydrogen_en
				
				RFNBO obligations for industry and transport under the Renewable Energy Directive
				42% of total H2 for industry must be RFNBO by 2030, 60% by 2035
				1% of total energy in transport must be RFNBO by 2030
				
				Targets for transport include bunkers:
				https://energy.ec.europa.eu/document/download/0c574279-b71d-4aa0-9403-daf9ea5a8491_en?filename=C_2024_5042_1_EN_ACT_part1_v8.pdf"
			}
			Parameter RFNBO_Industry_target {
				IndexDomain: p;
				Definition: data { 2030 : 0.420,  2035 : 0.600,  2040 : 0.600,  2045 : 0.600,  2050 : 0.600 };
			}
			Constraint RFNBO_industry {
				IndexDomain: p | p>='2030';
				Definition: {
					!Sum of RFNBO credits for industry >= 42% of total hydrogen use in industry
					!Klimaattafel industry sector is broader than other definitions (includes refining, ammonia, heat gen, etc)
					!This needs to be expanded to include synthetic fuel inputs to industry
					
					sum[(tb,acr) | (tb='ICR01_01')<>0,(-1)*(tech_use(tb,p)*activity_balances(tb,acr,p))] ! credits in industry
					-
					(sum[(tb,ae) | (tech_sector_kev(tb)='Industrie')*(ae='Hydrogen HD')*(activity_balances(tb,ae,p)<=0)<>0,(-1)*tech_use(tb,p)*activity_balances(tb,ae,p)]
					!direct hydrogen input to industry sector (Klimaattafel definition)
					+
					sum[(tb,ae) | (tech_sector_kev(tb)='Industrie')*(ae='Syndiesel')*(activity_balances(tb,ae,p)<=0)<>0,(-1)*tech_use(tb,p)*activity_balances(tb,ae,p)]*1.6
					!hydrogen for syndiesel input to industry sector (Klimaattafel definition)
					+
					sum[(tb,ae) | (tech_sector_kev(tb)='Industrie')*(ae='Ammonia')*(activity_balances(tb,ae,p)<=0)<>0,(-1)*tech_use(tb,p)*activity_balances(tb,ae,p)]*1.15
					!hydrogen for ammonia input to industry sector (Klimaattafel definition)
					+
					sum[(tb,ae) | (tech_sector_kev(tb)='Industrie')*(ae='Syn Naphtha')*(activity_balances(tb,ae,p)<=0)<>0,(-1)*tech_use(tb,p)*activity_balances(tb,ae,p)]*1.6*0.33
					!hydrogen for syn naphtha input to industry sector (Klimaattafel definition)
					+
					sum[(tb,ae) | (tech_sector_kev(tb)='Industrie')*(ae='Syn Kerosene')*(activity_balances(tb,ae,p)<=0)<>0,(-1)*tech_use(tb,p)*activity_balances(tb,ae,p)]*1.6*0.33
					!hydrogen for syn kerosene to industry sector (Klimaattafel definition)
					+
					sum[(tb,ae) | (tech_sector_kev(tb)='Industrie')*(ae='Syngas')*(activity_balances(tb,ae,p)<=0)<>0,(-1)*tech_use(tb,p)*activity_balances(tb,ae,p)]*1.35
					!hydrogen for syngas input to industry sector (Klimaattafel definition)
					)
					*RFNBO_Industry_target(p)
					>=0;
				}
			}
			Constraint RFNBO_transport {
				IndexDomain: ps | ps>='2030';
				Definition: {
					!Sum of RFNBO credits for transport >= 1% of total transport energy use
					
					sum[(tb,acr) | (tb='TAI01_06')<>0,(-1)*(tech_use(tb,ps)*activity_balances(tb,acr,ps))] ! credits in aviation bunkers
					+
					sum[(tb,acr) | (tb='TNB01_09')<>0,(-1)*(tech_use(tb,ps)*activity_balances(tb,acr,ps))] ! credits in navigation bunkers
					+
					sum[(tb,acr) | (tb='TOT01_03')<>0,(-1)*(tech_use(tb,ps)*activity_balances(tb,acr,ps))] ! credits in domestic transport
					-
					sum[(tb,ae) | tech_sector(tb)='Transport',(-1)*(tech_use(tb,ps)*activity_balances(tb,ae,ps))]*0.01 !1% RFNBO target in transport by 2030 (Renewable Energy Directive)
					>=0;
				}
			}
			Constraint H2_credits_transport {
				IndexDomain: ps;
				Definition: {
					!Sum of all H2 credits for domestic transport must be less than or equal to the H2 inputs to domestic transport (cannot use credits to offset, must be related to an actual use of H2)
					!Synfuel use with other types of hydrogen/CO2 are still allowed
					!>= would allow additional credits to be used in this sector beyond what would correspond to the synthetic fuel use
					
					sum[(tb,acr) | (tb='TOT01_03')<>0,(-1)*(tech_use(tb,ps)*activity_balances(tb,acr,ps))] !total credits used
					-
					(
					sum[(tb,ae) | (tech_sector(tb)='Transport')*(tech_sector_kev(tb)='Mobiliteit')*(ae='Hydrogen LD'),(-1)*tech_use(tb,ps)*activity_balances(tb,ae,ps)]
					!direct hydrogen input to domestic transport
					+
					sum[(tb,ae) | (tech_sector(tb)='Transport')*(tech_sector_kev(tb)='Mobiliteit')*(ae='Syndiesel'),(-1)*tech_use(tb,ps)*activity_balances(tb,ae,ps)]*1.6
					!H2 input to syndiesel for domestic transport (average of syngas inputs to FT and methanol to fuels options)
					+
					sum[(tb,ae) | (activityPer_tech(tb)='Domestic Navigation')*(ae='Ammonia'),(-1)*tech_use(tb,ps)*activity_balances(tb,ae,ps)]*1.15
					!H2 input to ammonia for inland shipping
					)
					<=0;
				}
			}
			Constraint H2_credits_industry {
				IndexDomain: ps;
				Definition: {
					!Sum of all H2 credits for industry must be less than or equal to the H2 inputs to industry(cannot use credits to offset, must be related to an actual use of H2)
					!Synfuel use with other types of hydrogen/CO2 are still allowed
					!>= would allow additional credits to be used in this sector beyond what would correspond to the synthetic fuel use
					
					sum[(tb,acr) | (tb='TCR01_01')<>0,(-1)*(tech_use(tb,ps)*activity_balances(tb,acr,ps))] !total credits used
					-
					(
					sum[(tb,ae) | (tech_sector_kev(tb)='Industrie')*(ae='Hydrogen HD'),(-1)*tech_use(tb,ps)*activity_balances(tb,ae,ps)]
					!direct hydrogen input to industry sector (Klimaattafel definition)
					+
					sum[(tb,ae) | (tech_sector_kev(tb)='Industrie')*(ae='Syndiesel'),(-1)*tech_use(tb,ps)*activity_balances(tb,ae,ps)]*1.6
					!hydrogen for syndiesel input to industry sector (Klimaattafel definition)
					+
					sum[(tb,ae) | (tech_sector_kev(tb)='Industrie')*(ae='Ammonia'),(-1)*tech_use(tb,ps)*activity_balances(tb,ae,ps)]*1.15
					!hydrogen for ammonia input to industry sector (Klimaattafel definition)
					+
					sum[(tb,ae) | (tech_sector_kev(tb)='Industrie')*(ae='Syn Naphtha'),(-1)*tech_use(tb,ps)*activity_balances(tb,ae,ps)]*1.6*0.33
					!hydrogen for syn naphtha input to industry sector (Klimaattafel definition)
					+
					sum[(tb,ae) | (tech_sector_kev(tb)='Industrie')*(ae='Syn Kerosene'),(-1)*tech_use(tb,ps)*activity_balances(tb,ae,ps)]*1.6*0.33
					!hydrogen for syn kerosene to industry sector (Klimaattafel definition)
					+
					sum[(tb,ae) | (tech_sector_kev(tb)='Industrie')*(ae='Syngas'),(-1)*tech_use(tb,ps)*activity_balances(tb,ae,ps)]*1.35
					!hydrogen for syngas input to industry sector (Klimaattafel definition)
					)
					<=0;
				}
			}
		}
	}
	Section RecycleBin;
}
